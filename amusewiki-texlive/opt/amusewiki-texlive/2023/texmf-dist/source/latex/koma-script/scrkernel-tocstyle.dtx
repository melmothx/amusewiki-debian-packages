% \iffalse meta-comment
% ======================================================================
% scrkernel-tocstyle.dtx
% Copyright (c) Markus Kohm, 2015-2023
%
% This file is part of the LaTeX2e KOMA-Script bundle.
%
% This work may be distributed and/or modified under the conditions of
% the LaTeX Project Public License, version 1.3c of the license.
% The latest version of this license is in
%   http://www.latex-project.org/lppl.txt
% and version 1.3c or later is part of all distributions of LaTeX 
% version 2005/12/01 or later and of this work.
%
% This work has the LPPL maintenance status "author-maintained".
%
% The Current Maintainer and author of this work is Markus Kohm.
%
% This work consists of all files listed in MANIFEST.md.
% ======================================================================
%%% From File: $Id: scrkernel-tocstyle.dtx 4060 2023-06-20 08:59:01Z kohm $
% The runs of run-time file generation:
%<preidentify>%%%            (run: preidentify)
% - everything that is needed before selfidentification of resulting files
%   (unused)
%<identify>%%%            (run: identify)
% - everything that is needed for selfidentification of resulting files
%   (unused)
%<prepare>%%%            (run: prepare)
% - everything that is needed to define options
%<option>%%%            (run: option)
% - definition of options (unused)
%<execoption>%%%            (run: execoption)
% - initial option executions up to \KOMAProcessOptions 
%   (unused)
%<body>%%%            (run: body)
% - everything, that should be done after \KOMAProcessOptions
%<exit>%%%            (run: exit)
% - everything, that should be done immediately before leaving the file
%   (unused) 
%<*dtx>
\ifx\ProvidesFile\undefined\def\ProvidesFile#1[#2]{}\fi
\begingroup
  \def\filedate$#1: #2-#3-#4 #5${\gdef\filedate{#2/#3/#4}}
  \filedate$Date: 2023-06-20 10:59:01 +0200 (Di, 20. Jun 2023) $
  \def\filerevision$#1: #2 ${\gdef\filerevision{r#2}}
  \filerevision$Revision: 4060 $
  \edef\reserved@a{%
    \noexpand\endgroup
    \noexpand\ProvidesFile{scrkernel-tocstyle.dtx}%
                          [\filedate\space\filerevision\space
                           KOMA-Script source (TOC styles)]
  }%
\reserved@a
\documentclass[USenglish]{koma-script-source-doc}
\usepackage{babel}
\setcounter{StandardModuleDepth}{3}
\begin{document}
\DocInput{scrkernel-tocstyle.dtx}
\end{document}
%</dtx>
% \fi
%
% \changes{v3.20}{2015/11/13}{new}
% \changes{v3.36}{2022/02/14}{switch over from \cls*{scrdoc} to
%   \cls*{koma-script-source-doc}}
% \changes{v3.36}{2022/02/14}{whole implementation documentation in English}
% \changes{v3.40}{2023/04/17}{guide names changed}
%
% \GetFileInfo{scrkernel-tocstyle.dtx}
% \title{The Predifined Directory Styles of
%   \href{https://komascript.de}{\KOMAScript} Package \pkg*{tocbasic} and the
%   \href{https://komascript.de}{\KOMAScript} Classes}
% \author{\href{mailto:komascript@gmx.info}{Markus Kohm}}
% \date{Revision \fileversion{} of \filedate}
% \maketitle
% \begin{abstract}
%   \file{scrkernel-tocstyle.dtx} provides the predefined directory (or ToC)
%   styles. The basic styles of \pkg*{tocbasic} are defined independent from
%   the \KOMAScript{} classes. However, the \KOMAScript{} classes define their
%   own styles depending on the styles of \pkg*{tocbasic}.
% \end{abstract}
% \tableofcontents
%
% \section{User Manual}
%
% You can find the user documentation the commands implemented here in the
% \KOMAScript{} manual, either the German \file{scrguide-de.pdf} or the
% English \file{scrguide-en.pdf}.
% 
% \MaybeStop{\PrintIndex}
%
% \section{Implementation of the Basic ToC Styles of Package
%  \pkg*{tocbasic} and the Specific ToC Styles of the \KOMAScript{} classes}
%
% \subsection{Settings independent from directories but nevertheless basis for
% them}
%
% Before \KOMAScript~3.20 the commands here were part of the \KOMAScript{}
% classes. But now they are part of package \pkg*{tocbasic}, because they
% are more basic than only to be used by the \KOMAScript{} classes.
%
%
% \begin{command}{\numberline}
% \changes{v3.20}{2016/03/10}{\cs{numberline} defined indirectly by
%   \cs{scr@numberline}}
% \begin{macro}{\scr@numberline}
% \changes{v2.3c}{1995/08/06}{\cs{numberline} redefined}
% \changes{v3.06}{2010/05/18}{Usage of\cs{numberline@prefix} and
%   \cs{numberline@postfix}}
% \changes{v3.12}{2013/11/22}{use \cs{numberline@numberformat} only, if the
%   argument expands to a non-empty string}
% \changes{v3.28}{2019/11/18}{\cs{ifstr} renamed into \cs{Ifstr}}
% This macro is used indirectly in the ToC and has to be redefined to fulfil
% rules~5 and 6 of DUDDEN, 20th edition.
%    \begin{macrocode}
%<*package&body>
\newcommand*{\scr@numberline}[1]{%
  \numberline@box{%
    \numberline@prefix
    \Ifstr{#1}{}{#1}{%
      \numberline@numberformat{#1}%
    }%
    \numberline@postfix
  }%
}
%    \end{macrocode}
% \begin{command}{\usetocbasicnumberline}
% \changes{v3.20}{2016/03/15}{added}
% The macro tests, whether \cs{numberline} used \cs{scr@numberline}. If not,
% the optional argument is executed and a afterwards \cs{numberline} is
% redefined.
%    \begin{macrocode}
\newcommand*{\usetocbasicnumberline}[1][%
  \PackageInfo{tocbasic}{Using my definition of `\string\numberline'}%
]{%
  \@tempswatrue
  \begingroup
    \def\scr@numberline##1{\global\@tempswafalse}%
%    \end{macrocode}
% For \cs{numberline} \cs{@tempdima} usually is the width reserved for the
% number. To avoid problems with to low values, we use the maximum value for
% the test.
%    \begin{macrocode}
    \@tempdima\maxdimen
    \sbox\@tempboxa{\numberline{0}}%
  \endgroup
  \if@tempswa #1\renewcommand*{\numberline}[1]{\scr@numberline{##1}}\fi
}
%    \end{macrocode}
% \end{command}^^A \usetocbasicnumberline
% \begin{macro}{\numberline@prefix}
% \changes{v3.06}{2010/05/18}{added}
% The default is just empty. It can be used, e.g., to print something before
% the number or to make the number right aligned.
%    \begin{macrocode}
\newcommand*{\numberline@prefix}{}
%    \end{macrocode}
% \end{macro}^^A \numberline@prefix
% \begin{macro}{\numberline@postfix}
% \changes{v3.06}{2010/05/18}{added} 
% The default is \cs{hfil} to make the number left aligned.
%    \begin{macrocode}
\newcommand*{\numberline@postfix}{\hfil}
%    \end{macrocode}
% \end{macro}^^A \numberline@postfix
% \begin{macro}{\numberline@numberformat}
% \changes{v3.06}{2010/05/18}{added}
% \changes{v3.12}{2013/11/22}{don't output anything, if argument expands to
%   an empty string}
% \changes{v3.28}{2019/11/18}{\cs{ifstr} renamed into \cs{Ifstr}}
% Used to fulfil rules~5 and 6 of DUDEN, 20th edition.
%    \begin{macrocode}
\newcommand*{\numberline@numberformat}[1]{%
  \Ifstr{#1}{}{}{\numberline@numberprefix#1\numberline@numberpostfix}%
}
%    \end{macrocode}
% \begin{macro}{\numberline@numberprefix}
% \changes{v3.20}{2016/03/15}{added}
% Used to prefix the number inside \cs{numberline@numberformat}. In opposite
% to \cs{numberline@prefix} it is only used, if the argument of
% \cs{numberline@numberformat} and therefore the argument of \cs{numberline}
% is not empty.
%    \begin{macrocode}
\newcommand*{\numberline@numberprefix}{}
%    \end{macrocode}
% \end{macro}^^A \numberline@numberprefix
% \begin{macro}{\numberline@numberpostfix}
% \changes{v3.20}{2016/03/15}{added}
% Used to postfix the number inside \cs{numberline@numberformat}. In opposite
% to \cs{numberline@prefix} it is only used, if the argument of
% \cs{numberline@numberformat} and therefore the argument of \cs{numberline}
% is not empty.
%    \begin{macrocode}
\newcommand*{\numberline@numberpostfix}{}
%    \end{macrocode}
% \end{macro}^^A \numberline@numberpostfix
% \end{macro}^^A \numberline@numberformat
% \begin{macro}{\numberline@box}
% \changes{v3.06}{2010/05/18}{added}
% Is used to put the sectioning number into a box.
%    \begin{macrocode}
\newcommand*{\numberline@box}[1]{\hb@xt@\@tempdima{#1}}
%</package&body>
%    \end{macrocode}
% \end{macro}^^A \numberline@box
% \end{macro}^^A \scr@numberline
%
%    \begin{macrocode}
%<*class&body>
\let\numberline\scr@numberline
%</class&body>
%    \end{macrocode}
% \end{command}^^A \numberline
%
%
% \subsection{The basics of the styles}
%
% From \KOMAScript~3.20 styles are a new basic feature for the entries into
% the table of contents and other directories. Each style consists of a
% command that defines the entry command and the corresponding options. The
% options are used to provide configuration features.
%
%    \begin{macrocode}
%<*package>
%    \end{macrocode}
%
% \changes{v3.20}{2015/11/17}{ToC styles have the \texttt{KOMAarg} member
%   \texttt{.dte}}
%    \begin{macrocode}
%<*body>
\DefineFamily{KOMAarg}
\DefineFamilyMember[.dte]{KOMAarg}
%</body>
%    \end{macrocode}
%
% \begin{macro}{\@DefineTOCEntryOption}
% \changes{v3.20}{2015/04/10}{added}
% The definition of the options is done by a general interface. Important is,
% that the definition of the option is done indirectly, which means: Here we
% define a command, that defines the options when needed. Note, not only the
% entry command interface itself but also the sectioning command interface may
% and should be able to setup options of the entry commands.
% The parameters:
% \begin{description}
% \item[\marg{style}: \meta{string},] name of the entry style
% \item[\marg{option}: \meta{string},] name of the option
% \item[\oarg{value}:] default value of the option depending on the
%   \meta{definition}
% \item[\marg{definition}: \meta{code},] definition of the option
% \end{description}
% \begin{macro}{\@DefineTOCEntryOptionWithoutDefault,\@DefineTOCEntryOptionWithDefault}
% \changes{v3.20}{2015/11/10}{added}
% Because of the options argument at position 3 (and because we've made this
% before \pkg{xparse} became part of the \LaTeX{} kernel), we need two
% auxiliary macros.
%    \begin{macrocode}
%<*body>
\newcommand*{\@DefineTOCEntryOption}[2]{%
  \edef\scr@dte@doopts{%
    \unexpanded\expandafter{\scr@dte@doopts}\noexpand\do{#2}%
  }%
  \kernel@ifnextchar [%]
    {\@DefineTOCEntryOptionWithDefault{#1}{#2}}%
    {\@DefineTOCEntryOptionWithoutDefault{#1}{#2}}%
}
\newcommand*{\@DefineTOCEntryOptionWithoutDefault}[3]{%
  \DefineFamilyKey[.dte]{KOMAarg}{#2}{#3}%
}
\newcommand*{\@DefineTOCEntryOptionWithDefault}{}
\def\@DefineTOCEntryOptionWithDefault#1#2[#3]#4{%
  \l@addto@macro\scr@dte@doopts{[{#3}]}%
  \DefineFamilyKey[.dte]{KOMAarg}{#2}[{#3}]{#4}%
}
%</body>
%    \end{macrocode}
% \end{macro}^^A \@DefineTOCEntryOptionWithoutDefault,\@DefineTOCEntryOptionWithDefault
% \end{macro}^^A \@DefineTOCEntryOption
%
% \begin{macro}{\@RelaxTOCEntryOptions}
% \changes{v3.20}{2015/04/10}{added}
% Reset all options of the current do-list back to \cs{relax}.
%    \begin{macrocode}
%<*body>
\newcommand*{\@RelaxTOCEntryOptions}{%
  \begingroup
    \def\do@endgroup{\endgroup}%
    \def\do##1{%
      \l@addto@macro\do@endgroup{%
        \RelaxFamilyKey[.dte]{KOMAarg}{##1}%
      }%
      \scr@dte@gobbleopt
    }%
    \scr@dte@doopts
  \do@endgroup
}
\newcommand{\scr@dte@gobbleopt}[1][]{}
%</body>
%    \end{macrocode}
% \end{macro}^^A \@RelaxTOCEntryOptions
%
% \begin{macro}{\@DefineTOCEntryListOption}
% \changes{v3.31}{2020/06/11}{added}
% Use \cs{DefineTOCEntryOption} to define an option that represents a list.
% It has following parameters:
% \begin{description}
% \item[\marg{style}: \meta{string},] name of the entry style
% \item[\marg{option}: \meta{string},] name of the option
% \item[\oarg{default}: \meta{string},] default value of the option
% \item[\marg{prefix}: \meta{string},] prefix of the macro to be defined
% \item[\marg{postfix}: \meta{string},] postfix of the macro to be defined
% \item[\marg{description}: \meta{String},] short description of the option
% \item[\oarg{init}: \meta{code},] initialization of the option
% \end{description}
% Between the \meta{prefix} and \meta{postfix} automatically
% \cs{scr@dte@current} will be added. A copy option using ``\opt{:=}''
% instead of ``\opt{=}'' and an add (append) option using ``\opt{+=}''
% instead of ``\opt{=}'' is also defined.
%    \begin{macrocode}
%<*body>
\newcommand*{\@DefineTOCEntryListOption}[2]{%
  \kernel@ifnextchar [%]
    {\@DefineTOCEntryListOptionWithDefault{#1}{#2}}
    {\@DefineTOCEntryListOptionWithoutDefault{#1}{#2}}%
}
%    \end{macrocode}
% \begin{macro}{\@DefineTOCEntryListOptionWithoutDefault}
% \changes{v3.31}{2020/06/11}{added}
% This is the case without default value. So we only have to define
% the three internal options, that manipulate a macro.
% \begin{macrocode}
\newcommand*{\@DefineTOCEntryListOptionWithoutDefault}[5]{%
  \@TOCEntryStyleNeedsCommandByOption{#1}{#3}{#4}{#2}{#5}%
  \@DefineTOCEntryOption{#1}{#2}{%
    \expandafter\protected@edef\csname #3\scr@dte@current#4\endcsname{##1}%
    \FamilyKeyStateProcessed
  }%
  \DefineFamilyKey[.dte]{KOMAarg}{#2:}{%
    \scr@ifundefinedorrelax{#3##1#4}{\FamilyKeyStateUnknownValue}{%
      \expandafter\let
      \csname #3\scr@dte@current#4\expandafter\endcsname
      \csname #3##1#4\endcsname
      \FamilyKeyStateProcessed
    }%
  }%
  \DefineFamilyKey[.dte]{KOMAarg}{#2+}{%
    \expandafter\protected@edef\csname #2\scr@dte@current#4\endcsname{%
      \csname #2\scr@dte@current#4\endcsname,##1}%
    \FamilyKeyStateProcessed
  }%
  \edef\scr@dte@doopts{%
    \unexpanded\expandafter{\scr@dte@doopts}\noexpand\do{#2:}\noexpand\do{#2+}%
  }%
}
%    \end{macrocode}
% \end{macro}^^A \@DefineTOCEntryListOptionWithoutDefault
% \begin{macro}{\@DefineTOCEntryListOptionWithDefault}
% \changes{v3.31}{2020/06/11}{added}
% This is the case with a default value. It's almost the same, but the
% argument numbers and using \cs{DefineFamilyKey} with optional argument.
%    \begin{macrocode}
\newcommand*{\@DefineTOCEntryListOptionWithDefault}{}
\def\@DefineTOCEntryListOptionWithDefault#1#2[#3]#4#5#6{%
  \@TOCEntryStyleNeedsCommandByOption{#1}{#4}{#5}{#2}{#6}%
  \@DefineTOCEntryOption{#1}{#2}[{#3]}{%
    \expandafter\protected@edef\csname #4\scr@dte@current#5\endcsname{##1}%
    \FamilyKeyStateProcessed
  }%
  \DefineFamilyKey[.dte]{KOMAarg}{#2:}{%
    \scr@ifundefinedorrelax{#4##1#5}{\FamilyKeyStateUnknownValue}{%
      \expandafter\let
      \csname #4\scr@dte@current#5\expandafter\endcsname
      \csname #4##1#5\endcsname
      \FamilyKeyStateProcessed
    }%
  }%
  \DefineFamilyKey[.dte]{KOMAarg}{#2+}{%
    \expandafter\protected@edef\csname #4\scr@dte@current#5\endcsname{%
      \csname #4\scr@dte@current#5\endcsname,##1}%
    \FamilyKeyStateProcessed
  }%
  \edef\scr@dte@doopts{%
    \unexpanded\expandafter{\scr@dte@doopts}\noexpand\do{#2:}\noexpand\do{#2+}%
  }%  
}
%</body>
%    \end{macrocode}
% \end{macro}^^A \@DefineTOCEntryListOptionWithDefault
% \end{macro}^^A \@DefineTOCEntryListOption
%
% \begin{macro}{\@DefineTOCEntryLengthOption}
% \changes{v3.20}{2015/12/04}{added}
% Use \cs{DefineTOCEntryOption} to define an option that represents a length
% macro. The parameters are:
% \begin{description}
% \item[\marg{style}: \meta{string},] name of the entry style
% \item[\marg{option}: \meta{string},] name of the option
% \item[\oarg{value}: \meta{length},] default value of the option
% \item[\marg{prefix}: \meta{string},] prefix of the name of the macro
% \item[\marg{postfix}: \meta{string},] postfix of the name of the macro
% \item[\marg{explanation}: \meta{string},] short description of the option
% \item[\oarg{init}: \meta{code},] initialisation code for the option
% \end{description}
% Later, when the option is defines, between \meta{prefix} and \meta{postfix}
% will be added \cs{scr@dte@current} automatically. This is the name of the
% entry level, e.g., |subsection| or |figure|. Additionally to
% the option \marg{option} itself a copy option \marg{option}\opt{:} will
% be defined. So it seems, that for the copy option a colon is before the
% equal sign. The value of the copy option has to be the name of another entry
% level and it copies the value of the same option of that entry
% level. Additionally an additive option with appended plus sign is
% defined. It adds the new value to the existing one.
% \begin{macro}{\@DefineTOCEntryLengthOptionWithoutDefault,
%               \@DefineTOCEntryLengthOptionWithDefault}
% \changes{v3.20}{2015/11/10}{added}
% \changes{v3.27}{2019/10/02}{automatic definition of copy option}
% \changes{v3.27}{2019/10/03}{automatic definition of add option}
% \begin{macro}{\@DefineTOCEntryLengthOptionMacro,\@DefineTOCEntryAddLengthOptionMacro}
% \changes{v3.27}{2019/10/03}{added}
% Because of the options argument at position 3 (and because we've made this
% before \pkg{xparse} became part of the \LaTeX{} kernel), we need three
% auxiliary macros.
%    \begin{macrocode}
%<*body>
\newcommand*{\@DefineTOCEntryLengthOption}[2]{%
  \kernel@ifnextchar [%]
    {\@DefineTOCEntryLengthOptionWithDefault{#1}{#2}}
    {\@DefineTOCEntryLengthOptionWithoutDefault{#1}{#2}}%
}
\newcommand*{\@DefineTOCEntryLengthOptionWithoutDefault}[5]{%
  \@TOCEntryStyleNeedsCommandByOption{#1}{#3}{#4}{#2}{#5}%
  \@DefineTOCEntryOption{#1}{#2}{%
    \@DefineTOCEntryLengthOptionMacro{#2}{#3}{#4}{##1}%
  }%
  \DefineFamilyKey[.dte]{KOMAarg}{#2:}{%
    \scr@ifundefinedorrelax{#3##1#4}{\FamilyKeyStateUnknownValue}{%
      \expandafter\let
      \csname #3\scr@dte@current#4\expandafter\endcsname
      \csname #3##1#4\endcsname
      \FamilyKeyStateProcessed
    }%
  }%
  \DefineFamilyKey[.dte]{KOMAarg}{#2+}{%
    \@DefineTOCEntryAddLengthOptionMacro{#2+}{#3}{#4}{##1}%
  }%
  \edef\scr@dte@doopts{%
    \unexpanded\expandafter{\scr@dte@doopts}%
    \noexpand\do{#2:}\noexpand\do{#2+}%
  }%
}
\newcommand*{\@DefineTOCEntryLengthOptionWithDefault}{}
\def\@DefineTOCEntryLengthOptionWithDefault#1#2[#3]#4#5#6{%
  \@TOCEntryStyleNeedsCommandByOption{#1}{#4}{#5}{#2}{#6}%
  \@DefineTOCEntryOption{#1}{#2}[{#3}]{%
    \@DefineTOCEntryLengthOptionMacro{#2}{#4}{#5}{##1}%
  }%
  \DefineFamilyKey[.dte]{KOMAarg}{#2:}{%
    \scr@ifundefinedorrelax{#4##1#5}{\FamilyKeyStateUnknownValue}{%
      \expandafter\let
      \csname #4\scr@dte@current#5\expandafter\endcsname
      \csname #4##1#5\endcsname
      \FamilyKeyStateProcessed
    }%
  }%
  \DefineFamilyKey[.dte]{KOMAarg}{#2+}{%
    \@DefineTOCEntryAddLengthOptionMacro{#2+}{#4}{#5}{##1}%
  }%
  \edef\scr@dte@doopts{%
    \unexpanded\expandafter{\scr@dte@doopts}%
    \noexpand\do{#2:}\noexpand\do{#2+}%
  }%
}
\newcommand*{\@DefineTOCEntryLengthOptionMacro}[4]{%
  \protected@edef\reserved@a{%
    \noexpand\FamilySetLength{KOMAarg}{#1}{\noexpand\@tempskipa}{#4}%
  }\reserved@a
  \ifx\FamilyKeyState\FamilyKeyStateProcessed
    \ifscr@dte@expandtopt
      \expandafter\edef\csname #2\scr@dte@current#3\endcsname{%
        \the\@tempskipa}%
    \else
      \expandafter\protected@edef\csname #2\scr@dte@current#3\endcsname{#4}%
    \fi
  \fi
}
\newcommand*{\@DefineTOCEntryAddLengthOptionMacro}[4]{%
  \@ifundefined{#2\scr@dte@current#3}{%
    \FamilyKeyStateUnknownValue
  }{%
    \protected@edef\reserved@a{%
      \noexpand\FamilySetLength{KOMAarg}{#1}{\noexpand\@tempskipa}{#4}%
    }\reserved@a
    \ifx\FamilyKeyState\FamilyKeyStateProcessed
      \ifscr@dte@expandtopt
        \expandafter\edef\csname #2\scr@dte@current#3\endcsname{%
          \the\glueexpr\@tempskipa
          +\csname #2\scr@dte@current#3\endcsname\relax}%
      \else
        \expandafter\protected@edef\csname #2\scr@dte@current#3\endcsname{%
          \the\glueexpr #4%
            +\csname #2\scr@dte@current#3\endcsname\relax}%
      \fi
    \fi
  }%
}
%</body>
%    \end{macrocode}
% \end{macro}^^A \@DefineTOCEntryAddLengthOptionMacro,\@DefineTOCEntryLengthOptionMacro
% \end{macro}^^A \@DefineTOCEntryLengthOptionWithDefault,\@DefineTOCEntryLengthOptionWithoutDefault
% \end{macro}^^A \@DefineTOCEntryLengthOption
%
% \begin{macro}{\@DefineTOCEntryNumberOption}
% \changes{v3.20}{2015/12/04}{added}
% Use \cs{DefineTOCEntryOption} to define an option that represents a number
% macro. The parameters are:
% \begin{description}
% \item[\marg{style}: \meta{string},] name of the entry style
% \item[\marg{option}: \meta{string},] name of the option
% \item[\oarg{value}: \meta{length},] default value of the option
% \item[\marg{prefix}: \meta{string},] prefix of the name of the macro
% \item[\marg{postfix}: \meta{string},] postfix of the name of the macro
% \item[\marg{explanation}: \meta{string},] short description of the option
% \item[\oarg{init}: \meta{code},] initialisation code for the option
% \end{description}
% Later, when the option is defines, between \meta{prefix} and \meta{postfix}
% will be added \cs{scr@dte@current} automatically. This is the name of the
% entry level, e.g., |subsection| or |figure|. Additionally to
% the option \marg{option} itself a copy option \marg{option}\opt{:} will
% be defined. So it seems, that for the copy option a colon is before the
% equal sign. The value of the copy option has to be the name of another entry
% level and it copies the value of the same option of that entry
% level. Additionally an additive option with appended plus sign is
% defined. It adds the new value to the existing one.
% \begin{macro}{\@DefineTOCEntryNumberOptionWithoutDefault,
%               \@DefineTOCEntryNumberOptionWithDefault}
% \changes{v3.20}{2015/11/12}{added}
% \changes{v3.27}{2019/10/02}{automatic definition of copy option}
% \changes{v3.27}{2019/10/03}{automatic definition of add option}
% \begin{macro}{\@DefineTOCEntryNumberOptionMacro,\@DefineTOCEntryAddNumberOptionMacro}
% \changes{v3.27}{2019/10/03}{added}
% Because of the options argument at position 3 (and because we've made this
% before \pkg{xparse} became part of the \LaTeX{} kernel), we need three
% auxiliary macros.
%    \begin{macrocode}
%<*body>
\newcommand*{\@DefineTOCEntryNumberOption}[2]{%
  \kernel@ifnextchar [%]
    {\@DefineTOCEntryNumberOptionWithDefault{#1}{#2}}
    {\@DefineTOCEntryNumberOptionWithoutDefault{#1}{#2}}%
}
\newcommand*{\@DefineTOCEntryNumberOptionWithoutDefault}[5]{%
  \@TOCEntryStyleNeedsCommandByOption{#1}{#3}{#4}{#2}{#5}%
  \@DefineTOCEntryOption{#1}{#2}{%
    \@DefineTOCEntryNumberOptionMacro{#2}{#3}{#4}{##1}%
  }%
  \DefineFamilyKey[.dte]{KOMAarg}{#2:}{%
    \scr@ifundefinedorrelax{#3##1#4}{\FamilyKeyStateUnknownValue}{%
      \expandafter\let
      \csname #3\scr@dte@current#4\expandafter\endcsname
      \csname #3##1#4\endcsname
      \FamilyKeyStateProcessed
    }%
  }%
  \DefineFamilyKey[.dte]{KOMAarg}{#2+}{%
    \@DefineTOCEntryAddNumberOptionMacro{#2+}{#3}{#4}{##1}%
  }%
  \edef\scr@dte@doopts{%
    \unexpanded\expandafter{\scr@dte@doopts}%
    \noexpand\do{#2:}\noexpand\do{#2+}%
  }%
}
\newcommand*{\@DefineTOCEntryNumberOptionWithDefault}{}
\def\@DefineTOCEntryNumberOptionWithDefault#1#2[#3]#4#5#6{%
  \@TOCEntryStyleNeedsCommandByOption{#1}{#4}{#5}{#2}{#6}%
  \@DefineTOCEntryOption{#1}{#2}[{#3}]{%
    \@DefineTOCEntryNumberOptionMacro{#2}{#4}{#5}{##1}%
  }%
  \DefineFamilyKey[.dte]{KOMAarg}{#2:}{%
    \scr@ifundefinedorrelax{#4##1#5}{\FamilyKeyStateUnknownValue}{%
      \expandafter\let
      \csname #4\scr@dte@current#5\expandafter\endcsname
      \csname #4##1#5\endcsname
      \FamilyKeyStateProcessed
    }%
  }%
  \DefineFamilyKey[.dte]{KOMAarg}{#2+}{%
    \@DefineTOCEntryAddNumberOptionMacro{#2+}{#4}{#5}{##1}%
  }%
  \edef\scr@dte@doopts{%
    \unexpanded\expandafter{\scr@dte@doopts}%
    \noexpand\do{#2:}\noexpand\do{#2+}%
  }%
}
\newcommand*{\@DefineTOCEntryNumberOptionMacro}[4]{%
  \protected@edef\reserved@a{%
    \noexpand\FamilySetCounterMacro{KOMAarg}{#1}{%
      \expandafter\noexpand\csname #2\scr@dte@current#3\endcsname
    }{#4}%
  }\reserved@a
}
\newcommand*{\@DefineTOCEntryAddNumberOptionMacro}[4]{%
  \@ifundefined{#2\scr@dte@current#3}{%
    \FamilyKeyStateUnknownValue
  }{%
    \FamilySetCounterMacro{KOMAarg}{#1}{%
      \reserved@a
    }{#4}%
    \ifx\FamilyKeyState\FamilyKeyStateProcessed
      \expandafter\edef\csname #2\scr@dte@current#3\endcsname{%
        \the\numexpr \reserved@a+\csname #2\scr@dte@current#3\endcsname\relax
      }%
    \fi
  }%
}
%</body>
%    \end{macrocode}
% \end{macro}^^A \@DefineTOCEntryAddNumberOptionMacro,\@DefineTOCEntryNumberOptionMacro
% \end{macro}^^A \@DefineTOCEntryNumberOptionWithDefault,\@DefineTOCEntryNumberOptionWithoutDefault
% \end{macro}^^A \@DefineTOCEntryNumberOption
%
% \begin{macro}{\@DefineTOCEntryBooleanOption}
% \changes{v3.20}{2015/12/04}{added}
% Use \cs{DefineTOCEntryOption} to define an option that represents a boolean
% switch. The parameters are:
% \begin{description}
% \item[\marg{style}: \meta{string},] name of the entry style
% \item[\marg{option}: \meta{string},] name of the option
% \item[\oarg{value}: \meta{length},] default value of the option
% \item[\marg{prefix}: \meta{string},] prefix of the name of the macro
% \item[\marg{postfix}: \meta{string},] postfix of the name of the macro
% \item[\marg{explanation}: \meta{string},] short description of the option
% \item[\oarg{init}: \meta{code},] initialisation code for the option
% \end{description}
% Later, when the option is defines, between \meta{prefix} and \meta{postfix}
% will be added \cs{scr@dte@current} automatically. This is the name of the
% entry level, e.g., |subsection| or |figure|. Additionally to
% the option \marg{option} itself a copy option \marg{option}\opt{:} will
% be defined. So it seems, that for the copy option a colon is before the
% equal sign. The value of the copy option has to be the name of another entry
% level and it copies the value of the same option of that entry
% level.
% \begin{macro}{\@DefineTOCEntryBoolOptionWithoutDefault,
%               \@DefineTOCEntryBoolOptionWithDefault}
% \changes{v3.20}{2015/11/12}{added}
% \changes{v3.27}{2019/10/02}{automatic definition of copy option}
% \begin{macro}{\@DefineTOCEntryBoolOptionMacro}
% \changes{v3.20}{2015/11/12}{added}
% Because of the options argument at position 3 (and because we've made this
% before \pkg{xparse} became part of the \LaTeX{} kernel), we need three
% auxiliary macros.
%    \begin{macrocode}
%<*body>
\newcommand*{\@DefineTOCEntryBooleanOption}[2]{%
  \kernel@ifnextchar [%]
    {\@DefineTOCEntryBoolOptionWithDefault{#1}{#2}}
    {\@DefineTOCEntryBoolOptionWithoutDefault{#1}{#2}}%
}
\newcommand*{\@DefineTOCEntryBoolOptionWithoutDefault}[5]{%
  \@TOCEntryStyleNeedsCommandByOption{#1}{if#3}{#4}{#2}{#5}%
  \@TOCEntryStyleNeedsCommandByOption{#1}{#3}{#4false}{#2}{#5}%
  \@TOCEntryStyleNeedsCommandByOption{#1}{#3}{#4false}{#2}{#5}%
  \@DefineTOCEntryOption{#1}{#2}[true]{%
    \@DefineTOCEntryBoolOptionMacro{#2}{#3}{#4}{##1}%
  }%
  \DefineFamilyKey[.dte]{KOMAarg}{#2:}{%
    \scr@ifundefinedorrelax{if#3##1#4}{\FamilyKeyStateUnknownValue}{%
      \expandafter\let
      \csname if#3\scr@dte@current#4\expandafter\endcsname
      \csname if#3##1#4\endcsname
      \FamilyKeyStateProcessed
    }%
  }%
  \edef\scr@dte@doopts{%
    \unexpanded\expandafter{\scr@dte@doopts}\noexpand\do{#2:}%
  }%
}
\newcommand*{\@DefineTOCEntryBoolOptionWithDefault}{}
\def\@DefineTOCEntryBoolOptionWithDefault#1#2[#3]#4#5#6{%
  \@TOCEntryStyleNeedsCommandByOption{#1}{if#4}{#5}{#2}{#6}%
  \@TOCEntryStyleNeedsCommandByOption{#1}{#4}{#5true}{#2}{#6}%
  \@TOCEntryStyleNeedsCommandByOption{#1}{#4}{#5false}{#2}{#6}%
  \@DefineTOCEntryOption{#1}{#2}[{#3}]{%
    \@DefineTOCEntryBoolOptionMacro{#2}{#4}{#5}{##1}%
  }%
  \DefineFamilyKey[.dte]{KOMAarg}{#2:}{%
    \scr@ifundefinedorrelax{if#4##1#5}{\FamilyKeyStateUnknownValue}{%
      \expandafter\let
      \csname if#4\scr@dte@current#5\expandafter\endcsname
      \csname if#4##1#5\endcsname
      \FamilyKeyStateProcessed
    }%
  }%
  \edef\scr@dte@doopts{%
    \unexpanded\expandafter{\scr@dte@doopts}\noexpand\do{#2:}%
  }%
}
\newcommand*{\@DefineTOCEntryBoolOptionMacro}[4]{%
  \@ifundefined{if#2\scr@dte@current#3}{%
    \expandafter\newif\csname if#2\scr@dte@current#3\endcsname
  }{}%
  \FamilySetBool{KOMAarg}{#1}{#2\scr@dte@current#3}{#4}%
}
%</body>
%    \end{macrocode}
% \end{macro}^^A \@DefineTOCEntryBoolOptionMacro
% \end{macro}^^A \@DefineTOCEntryBoolOptionWithDefault,\@DefineTOCEntryBoolOptionWithoutDefault
% \end{macro}^^A \@DefineTOCEntryBooleanOption
%
% \begin{macro}{\@DefineTOCEntryIfOption}
% \changes{v3.20}{2015/12/06}{added}
% Use \cs{DefineTOCEntryOption} to define an option that represents an if
% command. The option itself is a boolean option. The parameters are:
% \begin{description}
% \item[\marg{style}: \meta{string},] name of the entry style
% \item[\marg{option}: \meta{string},] name of the option
% \item[\oarg{value}: \meta{length},] default value of the option
% \item[\marg{prefix}: \meta{string},] prefix of the name of the macro
% \item[\marg{postfix}: \meta{string},] postfix of the name of the macro
% \item[\marg{explanation}: \meta{string},] short description of the option
% \end{description}
% Later, when the option is defines, between \meta{prefix} and \meta{postfix}
% will be added \cs{scr@dte@current} automatically. This is the name of the
% entry level, e.g., |subsection| or |figure|. Additionally to
% the option \marg{option} itself a copy option \marg{option}\opt{:} will
% be defined. So it seems, that for the copy option a colon is before the
% equal sign. The value of the copy option has to be the name of another entry
% level and it copies the value of the same option of that entry
% level.
% \begin{macro}{\@DefineTOCEntryIfOptionWithoutDefault,
%               \@DefineTOCEntryIfOptionWithDefault}
% \changes{v3.20}{2015/11/12}{added}
% \changes{v3.27}{2019/10/02}{automatic definition of copy option}
% \begin{macro}{\@DefineTOCEntryIfOptionMacro}
% \changes{v3.20}{2015/11/12}{added}
% Because of the options argument at position 3 (and because we've made this
% before \pkg{xparse} became part of the \LaTeX{} kernel), we need three
% auxiliary macros.
%    \begin{macrocode}
%<*body>
\newcommand*{\@DefineTOCEntryIfOption}[2]{%
  \kernel@ifnextchar [%]
    {\@DefineTOCEntryIfOptionWithDefault{#1}{#2}}
    {\@DefineTOCEntryIfOptionWithoutDefault{#1}{#2}}%
}
\newcommand*{\@DefineTOCEntryIfOptionWithoutDefault}[5]{%
  \@TOCEntryStyleNeedsCommandByOption{#1}{If#3}{#4}{#2}{#5}%
  \@DefineTOCEntryOption{#1}{#2}[true]{%
    \@DefineTOCEntryIfOptionMacro{#2}{#3}{#4}{##1}%
  }%
  \DefineFamilyKey[.dte]{KOMAarg}{#2:}{%
    \scr@ifundefinedorrelax{If#3##1#4}{\FamilyKeyStateUnknownValue}{%
      \expandafter\let
      \csname If#3\scr@dte@current#4\expandafter\endcsname
      \csname If#3##1#4\endcsname
      \FamilyKeyStateProcessed
    }%
  }%
  \edef\scr@dte@doopts{%
    \unexpanded\expandafter{\scr@dte@doopts}\noexpand\do{#2:}%
  }%
}
\newcommand*{\@DefineTOCEntryIfOptionWithDefault}{}
\def\@DefineTOCEntryIfOptionWithDefault#1#2[#3]#4#5#6{%
  \@TOCEntryStyleNeedsCommandByOption{#1}{If#4}{#5}{#2}{#6}%
  \@DefineTOCEntryOption{#1}{#2}[{#3}]{%
    \@DefineTOCEntryIfOptionMacro{#2}{#4}{#5}{##1}%
  }%
  \DefineFamilyKey[.dte]{KOMAarg}{#2:}{%
    \scr@ifundefinedorrelax{If#4##1#5}{\FamilyKeyStateUnknownValue}{%
      \expandafter\let
      \csname If#4\scr@dte@current#5\expandafter\endcsname
      \csname If#4##1#5\endcsname
      \FamilyKeyStateProcessed
    }%
  }%
  \edef\scr@dte@doopts{%
    \unexpanded\expandafter{\scr@dte@doopts}\noexpand\do{#2:}%
  }%
}
\newcommand*{\@DefineTOCEntryIfOptionMacro}[4]{%
  \FamilySetBool{KOMAarg}{#1}{@tempswa}{#4}%
  \ifx\FamilyKeyState\FamilyKeyStateProcessed
    \if@tempswa
      \expandafter\let\csname If#2\scr@dte@current#3\endcsname\@firstoftwo
    \else
      \expandafter\let\csname If#2\scr@dte@current#3\endcsname\@secondoftwo
    \fi
  \fi
}
%</body>
%    \end{macrocode}
% \end{macro}^^A \@DefineTOCEntryIfOptionMacro
% \end{macro}^^A \@DefineTOCEntryIfOptionWithDefault,\@DefineTOCEntryIfOptionWithoutDefault
% \end{macro}^^A \@DefineTOCEntryIfOption
%
% \begin{macro}{\@DefineTOCEntryCommandOption}
% \changes{v3.20}{2015/11/17}{added}
% Use \cs{DefineTOCEntryOption} to define an option that represents a
% macro. The parameters are:
% \begin{description}
% \item[\marg{style}: \meta{string},] name of the entry style
% \item[\marg{option}: \meta{string},] name of the option
% \item[\oarg{value}: \meta{length},] default value of the option
% \item[\marg{prefix}: \meta{string},] prefix of the name of the macro
% \item[\marg{postfix}: \meta{string},] postfix of the name of the macro
% \item[\marg{explanation}: \meta{string},] short description of the option
% \item[\oarg{init}: \meta{code},] initialisation code for the option
% \end{description}
% Later, when the option is defines, between \meta{prefix} and \meta{postfix}
% will be added \cs{scr@dte@current} automatically. This is the name of the
% entry level, e.g., |subsection| or |figure|. Additionally to
% the option \marg{option} itself a copy option \marg{option}\opt{:} will
% be defined. So it seems, that for the copy option a colon is before the
% equal sign. The value of the copy option has to be the name of another entry
% level and it copies the value of the same option of that entry
% level. Additionally an appending option with appended plus sign is
% defined. It appends the new code to the existing one.
% \begin{macro}{\@DefineTOCEntryCommandOptionWithoutDefault}
% \changes{v3.20}{2015/11/12}{added}
% \begin{macro}{\@@DefineTOCEntryCommandOptionWithoutDefault}
% \changes{v3.20}{2015/11/12}{added}
% \changes{v3.27}{2019/10/02}{automatic definition of copy option}
% \changes{v3.27}{2019/10/03}{automatic definition of add option}
% \begin{macro}{\@DefineTOCEntryCommandOptionWithDefault}
% \changes{v3.20}{2015/11/12}{added}
% \begin{macro}{\@@DefineTOCEntryCommandOptionWithDefault}
% \changes{v3.20}{2015/11/12}{added}
% \changes{v3.27}{2019/10/02}{automatic definition of copy option}
% \changes{v3.27}{2019/10/03}{automatic definition of add option}
% \begin{macro}{\@DefineTOCEntryCommandOptionMacro,\@@DefineTOCEntryCommandOptionMacro}
% \changes{v3.20}{2015/11/26}{added}
% Because of the options argument at position 3 (and because we've made this
% before \pkg{xparse} became part of the \LaTeX{} kernel), we need three
% auxiliary macros.
%    \begin{macrocode}
%<*body>
\newcommand*{\@DefineTOCEntryCommandOption}[2]{%
  \kernel@ifnextchar [%]
    {\@DefineTOCEntryCommandOptionWithDefault{#1}{#2}}
    {\@DefineTOCEntryCommandOptionWithoutDefault{#1}{#2}}%
}
\newcommand*{\@DefineTOCEntryCommandOptionWithoutDefault}[4]{%
  \@testopt{\@@DefineTOCEntryCommandOptionWithoutDefault{#1}{#2}{#3}{#4}}0%
}
\newcommand*{\@@DefineTOCEntryCommandOptionWithoutDefault}{}%
\def\@@DefineTOCEntryCommandOptionWithoutDefault#1#2#3#4[#5]#6{%
  \@TOCEntryStyleNeedsCommandByOption{#1}{#3}{#4}{#2}{#6}%
  \ifcase #5
    \@DefineTOCEntryOption{#1}{#2}{%
      \@DefineTOCEntryCommandOptionMacro{#2}{#3}{#4}[#5]{##1}%
    }%
    \DefineFamilyKey[.dte]{KOMAarg}{#2:}{%
      \scr@ifundefinedorrelax{#3##1#4}{\FamilyKeyStateUnknownValue}{%
        \expandafter\let
        \csname #3\scr@dte@current#4\expandafter\endcsname
        \csname #3##1#4\endcsname
        \FamilyKeyStateProcessed
      }%
    }%
    \edef\scr@dte@doopts{%
      \unexpanded\expandafter{\scr@dte@doopts}\noexpand\do{#2:}%
    }%
  \or
    \@DefineTOCEntryOption{#1}{#2}{%
      \@DefineTOCEntryCommandOptionMacro{#2}{#3}{#4}[#5]{##1{####1}}%
    }%
    \DefineFamilyKey[.dte]{KOMAarg}{#2:}{%
      \scr@ifundefinedorrelax{#3##1#4}{\FamilyKeyStateUnknownValue}{%
        \expandafter\let
        \csname #3\scr@dte@current#4\expandafter\endcsname
        \csname #3##1#4\endcsname
        \FamilyKeyStateProcessed
      }%
    }%
    \edef\scr@dte@doopts{%
      \unexpanded\expandafter{\scr@dte@doopts}\noexpand\do{#2:}%
    }%
  \else
    \PackageError{tocbasic}{only one argument supported}{%
      \string\DefineTOCEntryCommandOption\space currently supports only
      commands with\MessageBreak
      at most one argument not #5}%
  \fi
}
\newcommand*{\@DefineTOCEntryCommandOptionWithDefault}{}
\def\@DefineTOCEntryCommandOptionWithDefault#1#2[#3]#4#5{%
  \@testopt{\@@DefineTOCEntryCommandOptionWithDefault{#1}{#2}{#3}{#4}{#5}}0%
}
\def\@@DefineTOCEntryCommandOptionWithDefault#1#2#3#4#5[#6]#7{%
  \@TOCEntryStyleNeedsCommandByOption{#1}{#4}{#5}{#2}{#7}%
  \ifcase #6
    \@DefineTOCEntryOption{#1}{#2}[{#3}]{%
      \@DefineTOCEntryCommandOptionMacro{#2}{#4}{#5}[#6]{##1}%
    }%
    \DefineFamilyKey[.dte]{KOMAarg}{#2:}{%
      \scr@ifundefinedorrelax{#4##1#5}{\FamilyKeyStateUnknownValue}{%
        \expandafter\let
        \csname #4\scr@dte@current#5\expandafter\endcsname
        \csname #4##1#5\endcsname
        \FamilyKeyStateProcessed
      }%
    }%
    \edef\scr@dte@doopts{%
      \unexpanded\expandafter{\scr@dte@doopts}\noexpand\do{#2:}%
    }%
  \or
    \@DefineTOCEntryOption{#1}{#2}[{#3}]{%
      \@DefineTOCEntryCommandOptionMacro{#2}{#4}{#5}[#6]{##1{####1}}%
    }%
    \DefineFamilyKey[.dte]{KOMAarg}{#2:}{%
      \scr@ifundefinedorrelax{#4##1#5}{\FamilyKeyStateUnknownValue}{%
        \expandafter\let
        \csname #4\scr@dte@current#5\expandafter\endcsname
        \csname #4##1#5\endcsname
        \FamilyKeyStateProcessed
      }%
    }%
    \edef\scr@dte@doopts{%
      \unexpanded\expandafter{\scr@dte@doopts}\noexpand\do{#2:}%
    }%
  \or
    \@DefineTOCEntryOption{#1}{#2}[{#3}]{%
      \@DefineTOCEntryCommandOptionMacro{#2}{#4}{#5}[#6]{##1{####1}{####2}}%
    }%
    \DefineFamilyKey[.dte]{KOMAarg}{#2:}{%
      \scr@ifundefinedorrelax{#4##1#5}{\FamilyKeyStateUnknownValue}{%
        \expandafter\let
        \csname #4\scr@dte@current#5\expandafter\endcsname
        \csname #4##1#5\endcsname
        \FamilyKeyStateProcessed
      }%
    }%
    \edef\scr@dte@doopts{%
      \unexpanded\expandafter{\scr@dte@doopts}\noexpand\do{#2:}%
    }%
  \else
    \PackageError{tocbasic}{only one argument supported}{%
      \string\DefineTOCEntryCommandOption\space currently supports only
      commands with\MessageBreak
      at most two argument not #6}%
  \fi
}
\newcommand*{\@DefineTOCEntryCommandOptionMacro}[3]{%
  \@testopt{\@@DefineTOCEntryCommandOptionMacro{#1}{#2}{#3}}0%
}
\newcommand*{\@@DefineTOCEntryCommandOptionMacro}{}
\long\def\@@DefineTOCEntryCommandOptionMacro#1#2#3[#4]#5{%
  \let\l@ngrel@x\long
  \expandafter\@yargdef\csname #2\scr@dte@current#3\endcsname\@ne{#4}{#5}%
  \FamilyKeyStateProcessed
}
%</body>
%    \end{macrocode}
% \end{macro}^^A \@@DefineTOCEntryCommandOptionMacro,\@DefineTOCEntryCommandOptionMacro
% \end{macro}^^A \@@DefineTOCEntryCommandOptionWithDefault
% \end{macro}^^A \@DefineTOCEntryCommandOptionWithDefault
% \end{macro}^^A \@@DefineTOCEntryCommandOptionWithoutDefault
% \end{macro}^^A \@DefineTOCEntryCommandOptionWithoutDefault
% \end{macro}^^A \@DefineTOCEntryCommandOption
%
% \begin{macro}{\@AddToDeclareTOCStyleEntryPreCheckNeeds,
%               \@PreToDeclareTOCStyleEntryPreCheckNeeds}
% \changes{v3.20}{2015/12/06}{added}
% Before the existence of the mandatory commands can be tested in
% \cs{DeclareTOCStyleEntry}, a hook will be executed. To add code to this hook
% we have this command with the following parameter:
% \begin{description}
% \item[\marg{code}: \meta{code},] code to be executed.
% \end{description}
% Please note, this command is used inside the init code of styles, which
% means inside \cs{DeclareTOCEntryStyle}, but the hook is inside
% \cs{DeclareTOCStyleEntry}. The code of the hook has exactly one argument,
% the name of the ToC entry level.
%    \begin{macrocode}
%<*body>
\newcommand{\@AddToDeclareTOCEntryStylePreCheckNeeds}[1]{%
  \expandafter\providecommand\csname scr@dte@precheck\endcsname[1]{}%
  \expandafter\l@addto@macro@a\csname scr@dte@precheck\endcsname
}
\newcommand{\@PreToDeclareTOCEntryStylePreCheckNeeds}[1]{%
  \expandafter\providecommand\csname scr@dte@precheck\endcsname[1]{}%
  \expandafter\l@preto@macro@a\csname scr@dte@precheck\endcsname
}
%</body>
%    \end{macrocode}
% \end{macro}^^A \@AddToDeclareTOCStyleEntryPreCheckNeeds,\@PreToDeclareTOCStyleEntryPreCheckNeeds
%
% \begin{macro}{\@TOCEntryStyleNeedsCommandByOption}
% \changes{v3.20}{2015/12/04}{added}
% Adds one or more commands to the list of mandatory commands. The parameters
% are:
% \begin{description}
% \item[\marg{style}:] The style \meta{string}, that needs the command(s).
% \item[\marg{prefix}:] Prefix \meta{string} of the mandatory command(s).
% \item[\marg{postfix}:] Postfix \meta{string} of the mandatory command(s).
% \item[\marg{Option}:] Option \meta{string}, that defines the command(s).
% \item[\marg{explanation}:] Short description.
% \end{description}
% Between \meta{prefix} and \meta{postfix} will be added the name of the entry
% level automatically.
%    \begin{macrocode}
%<*body>
\newcommand*{\@TOCEntryStyleNeedsCommandByOption}[5]{%
  \expandafter\providecommand\expandafter*\csname scr@dte@#1@needs\endcsname{}%
  \expandafter\l@addto@macro\csname scr@dte@#1@needs\endcsname{%
    \do{#2}{#3}{#4}{#5}%
  }%
}
%</body>
%    \end{macrocode}
% \end{macro}^^A \@TOCEntryStyleNeedsCommandByOption
%
% \begin{command}{\TOCEntryStyleInitCode,\TOCEntryStyleInitCode*,
%                 \TOCEntryStyleStartInitCode}
% \changes{v3.20}{2015/11/25}{added}
% \changes{v3.41}{2023/06/20}{star variant \cs{TOCEntryStyleInitCode*} added}
% Executes commands before a ToC entry level command of this style is defined
% and before the \emph{needs} list will be executed. The parameters are:
% \begin{description}
% \item[\marg{style}:] The style \meta{string} that should be initialised.
% \item[\marg{code}:] The code that should be executed to initialise the
% style. The code has one argument \texttt{\#1} which is the name of the ToC
% entry level.
% \end{description}
%    \begin{macrocode}
%<*body>
\NewDocumentCommand\TOCEntryStyleInitCode{sm}{%
  \IfBooleanT{#1}{\expandafter\let\csname scr@dte@#2@init\endcsname\relax}%
  \scr@ifundefinedorrelax{scr@dte@#2@init}{%
    \expandafter\newcommand\expandafter*%
    \csname scr@dte@#2@init\endcsname[1]%
  }{%
    \expandafter\l@addto@macro@a\csname scr@dte@#2@init\endcsname
  }%
}
\newcommand{\TOCEntryStyleStartInitCode}[1]{%
  \scr@ifundefinedorrelax{scr@dte@#1@init}{%
    \expandafter\providecommand\expandafter*%
    \csname scr@dte@#1@init\endcsname[1]%
  }{%
    \expandafter\l@preto@macro@a\csname scr@dte@#1@init\endcsname
  }%
}
%    \end{macrocode}
% \end{command}^^A \TOCEntryStyleInitCode … \TOCEntryStyleStartInitCode
% \begin{macro}{\@ExecuteTOCEntryStyleInitCode}
% \changes{v3.20}{2015/12/04}{added}
% Executes the init code of one style. The first argument is the name of the
% style, the second the name of the ToC entry level, which will be used as
% argument of the init code (see above).
%    \begin{macrocode}
\newcommand*{\@ExecuteTOCEntryStyleInitCode}[2]{%
  \let\scr@dte@doopts\@empty
%    \end{macrocode}
% \changes{v3.27}{2019/10/02}{init \cs{scr@dte@\meta{Stil}@init}}
% Because the definition which options or which macros are needed for a style
% takes place via the declaration of the options and this declaration does not
% take place with the definition of the style but with the assignment of the
% style to an entry, the do list of this information must also be deleted
% here. Otherwise it would constantly grow over all entries of the same style
% and thus contain various entries several times. Probably it would be better
% to actually create a list per entry here instead of one per style, but
% that's just not how it is. So the same list is always rebuilt here and must
% therefore be reset at the beginning.
%    \begin{macrocode}
  \expandafter\let\csname scr@dte@#1@needs\endcsname\relax
  \scr@ifundefinedorrelax{scr@dte@#1@init}{}{%
    \def\DefineTOCEntryBooleanOption{\@DefineTOCEntryBooleanOption{#1}}%
    \def\DefineTOCEntryCommandOption{\@DefineTOCEntryCommandOption{#1}}%
    \def\DefineTOCEntryIfOption{\@DefineTOCEntryIfOption{#1}}%
    \def\DefineTOCEntryLengthOption{\@DefineTOCEntryLengthOption{#1}}%
    \def\DefineTOCEntryListOption{\@DefineTOCEntryListOption{#1}}%
    \def\DefineTOCEntryNumberOption{\@DefineTOCEntryNumberOption{#1}}%
    \def\DefineTOCEntryOption{\@DefineTOCEntryOption{#1}}%
    \def\AddToDeclareTOCEntryStylePreCheckNeeds{%
      \@AddToDeclareTOCEntryStylePreCheckNeeds{#1}}%
    \def\PreToDeclareTOCEntryStylePreCheckNeeds{%
      \@PreToDeclareTOCEntryStylePreCheckNeeds{#1}}%
    \def\TOCEntryStyleNeedsCommandByOption{%
      \@TOCEntryStyleNeedsCommandByOption{#1}}%
    \@nameuse{scr@dte@#1@init}{#2}%
    \let\TOCEntryStyleNeedsCommandByOption\relax
    \let\PreToDeclareTOCEntryStylePreCheckNeeds\relax
    \let\AddToDeclareTOCEntryStylePreCheckNeeds\relax
    \let\DefineTOCEntryOption\relax
    \let\DefineTOCEntryNumberOption\relax
    \let\DefineTOCEntryListOption\relax
    \let\DefineTOCEntryLengthOption\relax
    \let\DefineTOCEntryIfOption\relax
    \let\DefineTOCEntryCommandOption\relax
    \let\DefineTOCEntryBooleanOption\relax
  }%
}
%</body>
%    \end{macrocode}
% \end{macro}^^A \@ExecuteTOCEntryStyleInitCode
%
%
% \begin{command}{\DeclareTOCStyleEntry}
% \changes{v3.20}{2015/11/13}{added}
% \changes{v3.39}{2022/10/24}{error message about missing options improved}
% \changes{v3.41}{2023/06/20}{usage of style definition files supported}
% This user command defines a new ToC entry command. It tests, if all needed
% style macros are already defined. Otherwise an error will be shown and the
% ToC entry command will not be defined. The arguments are:
% \begin{description}
% \item[\oarg{options}:] comma-separated list of options to specify the entry;
% \item[\marg{style}:] a string, that specifies the style of the ToC entry;
% \item[\marg{level name}:] a string, that specifies the name of the
%   sectioning level (or float environment), related to the ToC entry;
% \end{description}
% The real macro to define a ToC entry command is
% \cs{scr@dte@def@l@\meta{style}}. That needs exactly one argument, the
% \meta{level name}.
%    \begin{macrocode}
%<*body>
\newcommand*{\DeclareTOCStyleEntry}[3][]{%
  \scr@ifundefinedorrelax{scr@dte@def@l@#2}{%
    \IfFileExists{tocbasic-tocstyle-#2.def}{%
      \edef\reserved@a{%
        \unexpanded{%
          \makeatletter
          \input{tocbasic-tocstyle-#2.def}%
          \catcode`\@=}\the\catcode`\@\relax
      }\reserved@a
    }{}%
  }{}%
  \scr@ifundefinedorrelax{scr@dte@def@l@#2}{%
    \PackageError{tocbasic}{toc entry style `#2' undefined}{%
      Somebody told me to define toc entry `#3' with style `#2',\MessageBreak
      but I do not know style `#2'.\MessageBreak
      You should first define the style then define the entry.\MessageBreak
      If you'll continue, I'll ignore the command. This could result
      in\MessageBreak
      further error messages.%
    }%
  }{%
    \let\scr@dte@precheck\@gobble
    \def\scr@dte@current{#3}%
    \@ExecuteTOCEntryStyleInitCode{#2}{#3}%
    \IfArgIsEmpty{#1}{}{%
      \FamilyBoolKey[.dte]{KOMAarg}{expandtopt}{scr@dte@expandtopt}%
      \scr@dte@expandtoptfalse
      \FamilyExecuteOptions[.dte]{KOMAarg}{#1}%
      \RelaxFamilyKey[.dte]{KOMAarg}{expandtopt}%
    }%
    \@RelaxTOCEntryOptions
    \let\scr@dte@doopts\relax
    \let\scr@dte@current\relax
    \scr@ifundefinedorrelax{#3tocdepth}{%
      \expandafter\let\csname #3tocdepth\expandafter\endcsname
      \csname #3numdepth\endcsname
    }{}%
    \scr@dte@precheck{#3}%
    \let\scr@dte@precheck\relax
    \begingroup
      \aftergroup\@tempswatrue
      \def\do##1##2##3##4{%
        \scr@ifundefinedorrelax{##1#3##2}{%
          \PackageError{tocbasic}{toc style `#2' needs ##4\MessageBreak
            of `#3'}{%
            Usually the ##4 is defined using option `##3'.\MessageBreak
            In some cases it may be set defining command
            `\expandafter\string\csname ##1#3##2\endcsname'.\MessageBreak
            If you'll continue, I'll ignore the command. This could result
            in\MessageBreak
            further error messages.%
          }%
          \aftergroup\@tempswafalse
        }{}%
      }%
      \do{}{tocdepth}{level}{toc style level}%
      \@nameuse{scr@dte@#2@needs}%
    \endgroup
    \if@tempswa
      \@nameuse{scr@dte@def@l@#2}{#3}%
%    \end{macrocode}
% \changes{v3.27}{2019/10/02}{macro name prefix for style information changed}
% Note: Before \KOMAScript~3.27 the style name of an entry was stored in
% \cs{scr@dte@\meta{level name}@style}. But this war wrong, because the prefix
% |scr@dte| is used for attributes of the style (while declaring an
% entry), but the style is an attribute of the entry. So usage of the prefix
% |scr@tso| would be much better. This means usage of
% \cs{scr@dte@\meta{level name}@style} is deprecated and should be replaced by
% \cs{scr@tso@\meta{level name}@style}.
%    \begin{macrocode}
      \expandafter\edef\csname scr@dte@#3@style\endcsname{#2}%
      \expandafter\edef\csname scr@tso@#3@style\endcsname{#2}%
%    \end{macrocode}
% \changes{v3.21}{2016/06/09}{\cs{toclevel@\emph{level}} added for \pkg{hyperref}}
% At least \pkg{hyperref}, but several other packages too, depend on a
% \pkg{hyperref} compatible storage of the level number. So we define it here
% additionally. Unfortunately \pkg{hyperref} overwrites this definition, so we
% do so after loading the package and sometimes also at |\begin{document}|.
%    \begin{macrocode}
      \expandafter\let\csname toclevel@#3\expandafter\endcsname
      \csname #3tocdepth\endcsname
      \if@atdocument\else
        \scr@ifundefinedorrelax{AfterPackage}{%
          \AtBeginDocument
        }{%
          \AfterPackage*{hyperref}%
        }%
        {%
          \expandafter\let\csname toclevel@#3\expandafter\endcsname
          \csname #3tocdepth\endcsname
        }%
      \fi
    \fi
  }%
}
%</body>
%    \end{macrocode}
% \end{command}^^A \DeclareTOCStyleEntry
%
% \begin{command}{\DeclareTOCStyleEntries}
% \changes{v3.26}{2018/08/27}{added}
% Use \cs{DeclareTOCStyleEntry} to define a list of entries, all with the same
% options and style.
%    \begin{macrocode}
%<*body>
\newcommand*{\DeclareTOCStyleEntries}[3][]{%
  \edef\reserved@a{#3}%
  \@for \reserved@a:=\reserved@a \do {%
    \scr@trim@spaces\reserved@a
    \ifx\reserved@a\@empty\else
      \IfArgIsEmpty{#1}{%
        \edef\reserved@a{%
          \unexpanded{\DeclareTOCStyleEntry{#2}}{\reserved@a}}%
      }{%
        \edef\reserved@a{%
          \unexpanded{\DeclareTOCStyleEntry[{#1}]{#2}}{\reserved@a}}%
      }%
      \reserved@a
    \fi
  }%
}
%</body>
%    \end{macrocode}
% \end{command}^^A \DeclareTOCStyleEntries
%
% \begin{command}{\DeclareTOCEntryStyle}
% \changes{v3.20}{2015/11/17}{added}
% \begin{macro}{\@DeclareTOCEntryStyle}
% \changes{v3.20}{2015/11/17}{added}
% \changes{v3.41}{2023/06/20}{using \cs{TOCEntryStyleInitCode*} instead of
%   \cs{TOCEntryStyleInitCode}}
% The user command is used to define a new style for ToC entries. The
% arguments are:
% \begin{description}
% \item[\marg{style}:] a string, that represents the name of the style;
% \item[\oarg{initialization code}:] code, e.g., to initialize the options,
%   that will be used to define the ToC entry command (note: this code can be
%   executed more than once);
% \item[\marg{code}:] code, that will be used to generate a ToC entry while
%   loading the auxiliary file of the ToC;
% \end{description}
% Independent from the \meta{initialization code}, \opt{level} is always
% defined, because a numerical ToC level is always needed.
%    \begin{macrocode}
%<*body>
\newcommand*{\DeclareTOCEntryStyle}[1]{%
  \kernel@ifnextchar [%]
    {\@DeclareTOCEntryStyle{#1}}%
    {\@DeclareTOCEntryStyle{#1}[]}%
}
\newcommand{\@DeclareTOCEntryStyle}{}
\long\def\@DeclareTOCEntryStyle#1[#2]#3{%
  \@namedef{scr@dte@def@l@#1}##1{%
    \@namedef{l@##1}####1####2{%
      \TOC@EntryStartHook{##1}%
      #3%
      \TOC@EntryEndHook{##1}%
    }%
  }%
  \TOCEntryStyleInitCode*{#1}{%
    \DefineTOCEntryNumberOption{level}{}{tocdepth}{toc entry level}%
    #2%
  }%
}
%</body>
%    \end{macrocode}
% \end{macro}^^A \@DeclareTOCEntryStyle
% \end{command}^^A \DeclareTOCEntryStyle
%
%
% \begin{macro}{\TOC@EntryStartHook,\TOC@EntryEndHook}
% \changes{v3.20}{2016/01/12}{added}
% For every ToC entry, that has been defined by \KOMAScript{}, there is one
% \emph{hook}, that will be executed before the corresponding ToC entry, and
% another \emph{hook}, that will executed after the corresponding ToC entry. Inside
% the \emph{hook} commands \texttt{\#1} is the name of the ToC level. Generally
% the \emph{hook} commands should not do any output and should neither change
% \cs{lastpenalty} nor \len{lastskip}. The user is responsible for this!
% However, because this \emph{hook} is very dangerous, we only have two
% internal macros for it but no user command to add new commands to the
% hook. So it is a kind of last chance mechanism.
%    \begin{macrocode}
%<*body>
\newcommand*{\TOC@EntryStartHook}[1]{}
\newcommand*{\TOC@EntryEndHook}[1]{}
%</body>
%    \end{macrocode}
% \end{macro}^^A \TOC@EntryStartHook,\TOC@EntryEndHook
%
%
% \begin{command}{\CloneTOCEntryStyle}
% \changes{v3.20}{2015/11/25}{added}
% The user command clones the style from \texttt{\#1} to style
% \texttt{\#2}. After cloning you can change the new style.
%    \begin{macrocode}
%<*body>
\newcommand*{\CloneTOCEntryStyle}[2]{%
%    \end{macrocode}
% First of all copy the ToC entry command.
%    \begin{macrocode}
  \expandafter\let\csname scr@dte@def@l@#2\expandafter\endcsname
  \csname scr@dte@def@l@#1\endcsname
%    \end{macrocode}
% Then copy the \meta{initialization code}.
%    \begin{macrocode}
  \expandafter\let\csname scr@dte@#2@init\expandafter\endcsname
  \csname scr@dte@#1@init\endcsname
}
%</body>
%    \end{macrocode}
% \end{command}
%
%
% \begin{macro}{\@pnumwidth,\@tocrmarg,\@dotsep}
% \changes{v3.27}{2019/05/11}{moved from the classes to the package}
% \begin{description}
% \item[\cs{@pnumwidth}] is the space of the page number.
% \item[\cs{@tocrmarg}] is the right margin of entries with more than one
%   line. Usually this should be larger than \cs{@pnumwidth}.
% \item[\cs{\@dotsep}] is the space between the dots of a dotted connecting line.
% \end{description}
%    \begin{macrocode}
%<*body>
\providecommand*\@pnumwidth{1.55em}
\providecommand*\@tocrmarg {2.55em}
\providecommand*\@dotsep   {4.5}
%</body>
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{Predefined ToC entry styles}
%
% You can read this code as examples for defining ToC entry styles using the
% commands from the previous sections. Some of them are very basic. Others are
% extensions of the basic styles. \file{scrdocstrip.tex} has to process this
% code several times to generate all the styles.
%
%    \begin{macrocode}
%<*style>
%    \end{macrocode}
% 
% \begin{macro}{\scr@dte@def@l@gobble}
% \changes{v3.20}{2015/11/20}{ToC style \texttt{gobble} added}
% Der aller einfachste Verzeichniseintragsstil ist |gobble|. Er nimmt
% die beiden Argumente für den Verzeichniseintrag und die Seitenzahl und
% vergisst sie unabhängig von der Ebene des Eintrags einfach. Daher benötigt
% dieser Stil auch keinerlei Optionen oder Initialisierung.
%    \begin{macrocode}
%<*gobble>
%%%            (run: style,gobble)
\DeclareTOCEntryStyle{gobble}{}%
%</gobble>
%    \end{macrocode}
% \end{macro}^^A \scr@dte@def@l@gobble
%
% \begin{macro}{\scr@dte@def@l@dottedtocline}
% \changes{v3.20}{2015/11/20}{ToC style \texttt{dottedtocline} added}
% The most simple real ToC entry style is |dottedtocline|. It used the
% \LaTeX{} kernel macro \cs{@dottedtocline}. You should not use this style for
% \KOMAScript. But it may be useful to be used with the standard
% classes. However, in my opinion style |tocline| would always be the better one.
% \begin{macro}{\scr@dte@def@l@undottedtocline}
% \changes{v3.20}{2015/11/20}{ToC style \texttt{undottedtocline} added}
% Style |undottedtocline| corresponds to the style, that is used for chapter
% entries of the standard class \cls*{book} or \cls*{report}. In opposite to
% that, it also supports an horizontal indent. So you can alternatively
% interpret it as a variant of |dottedtocline| without dots.
% \begin{macro}{\scr@dte@def@l@largetocline}
% \changes{v3.20}{2015/11/20}{ToC style \texttt{largetocline} added}
% Style |largetocline| corresponds to the style, that is used for part entries
% of the standard classes. Once again and in opposite to the original code of
% the standard classes, this style supports an entry indent. But an additional
% number width is not supported. Instead the entries will be printed hanging.
% \begin{macro}{\scr@dte@def@l@tocline}
% \changes{v3.20}{2015/11/22}{ToC style \texttt{tocline} added}
% |tocline| is a very flexible style. It is intended to be used for entries with
% one or more line. It is used for all the ToC entries of the \KOMAScript{}
% classes. The classes also clone this style several times.
% \begin{macro}{\scr@dte@def@l@toctext}
% \changes{3.27}{2019/07/08}{ToC style \texttt{toctext} added}
% So far all mentioned styles are intended to generate one paragraph per
% entry. Style |toctext| generated only one paragraph for all consecutive
% entries. So it prints \emph{text inside} a paragraph.
%    \begin{macrocode}
%<*dottedtocline|undottedtocline|largetocline|tocline|toctext>
%<*dottedtocline>
%%%            (run: style,dottedtocline)
\DeclareTOCEntryStyle{dottedtocline}[{%
%</dottedtocline>
%<*undottedtocline>
%%%            (run: style,undottedtocline)
\DeclareTOCEntryStyle{undottedtocline}[{%
%</undottedtocline>
%<*largetocline>
%%%            (run: style, largetocline)
\DeclareTOCEntryStyle{largetocline}[{%
%</largetocline>
%<*toctext>
%%%            (run: style,toctext)
\DeclareTOCEntryStyle{toctext}[{%
%</toctext>
%<*tocline>
%%%            (run: style,tocline)
\DeclareTOCEntryStyle{tocline}[{%
%</tocline>
%    \end{macrocode}
% \changes{v3.31}{2020/06/09}{style \texttt{toctext} also provides option
%   \opt{beforeskip}}
%    \begin{macrocode}
%<*tocline|toctext>
  \DefineTOCEntryLengthOption{beforeskip}%
    {scr@tso@}{@beforeskip}{vertical skip before the entry}%
%</tocline|toctext>
%<*tocline>
  \DefineTOCEntryIfOption{breakafternumber}%
    {scr@tso@}{@breakafternumber}{line break after number flag}%
  \DefineTOCEntryIfOption{dynnumwidth}%
    {scr@tso@}{@dynnumwidth}{dynamic number width flag}%
%    \end{macrocode}
% \changes{v3.31}{2020/06/08}{option for indent follows list}
%    \begin{macrocode}
  \DefineTOCEntryListOption{indentfollows}%
    {scr@tso@}{@indentfollows}{list of levels that define the indent}%
  \DefineTOCEntryIfOption{dynindent}%
    {scr@tso@}{@dynindent}{dynamic indent width flag}%
%</tocline>
%<*tocline|toctext>
  \DefineTOCEntryCommandOption{entryformat}%
    {scr@tso@}{@entryformat}[1]{entry format}%
  \DefineTOCEntryCommandOption{entrynumberformat}%
    {scr@tso@}{@numberformat}[1]{entry number format}%
%</tocline|toctext>
%<*tocline>
  \DefineTOCEntryCommandOption{linefill}[\TOCLineLeaderFill]%
    {scr@tso@}{@linefill}{filling between text and page number}%
%</tocline>
%<*toctext>
  \DefineTOCEntryCommandOption{prepagenumber}%
    {scr@tso@}{@prepagenumber}{separator between text and page number}%
%</toctext>
%<*tocline|toctext>
  \DefineTOCEntryLengthOption{numsep}%
    {scr@tso@}{@numsep}{entry number separation}%
%</tocline|toctext>
%<*tocline>
  \DefineTOCEntryCommandOption{onstarthigherlevel}%
    {scr@tso@}{@LastTOCLevelWasLower}{start higher level entry hook}%
  \DefineTOCEntryCommandOption{onstartlowerlevel}%
    {scr@tso@}{@LastTOCLevelWasHigher}{start lower level entry hook}%
  \DefineTOCEntryCommandOption{onstartsamelevel}%
    {scr@tso@}{@LastTOCLevelWasSame}{start same level entry hook}%
%</tocline>
%<*toctext>
  \DefineTOCEntryCommandOption{onstartfirstentry}%
    {scr@tso@}{@onstartfirstentry}{output at start of paragraph}%
  \DefineTOCEntryCommandOption{onstartentry}%
    {scr@tso@}{@onstartentry}{output at start of all entries but the first}%
  \DefineTOCEntryCommandOption{onendlastentry}%
    {scr@tso@}{@onendlastentry}{output at end of paragraph}%
  \DefineTOCEntryCommandOption{afterpar}%
    {scr@tso@}{@afterpar}{settings after end of paragraph}%
  \DefineTOCEntryCommandOption{onendentry}%
    {scr@tso@}{@onendentry}{output at end of all entries but the last}%
%</toctext>
%<*tocline>
  \DefineTOCEntryCommandOption{pagenumberbox}%
    {scr@tso@}{@pagenumberbox}[1]{page number box}%
%</tocline>
%<*tocline|toctext> 
  \DefineTOCEntryCommandOption{pagenumberformat}%
    {scr@tso@}{@pagenumberformat}[1]{page number format}%
%</tocline|toctext>  
%    \end{macrocode}
% \changes{v3.27}{2019/05/24}{new option \opt{pagenumberwidth}}
% \changes{v3.27}{2019/05/24}{new option \opt{rightindent}}
% Die Optionen \opt{pagenumberwidth} und \opt{rightindent} ersetzen
% innerhalb des Stils |tocline| die Makros \cs{@pnumwidth} und
% \cs{@tocrmarg}.
%    \begin{macrocode}
%<*tocline>
  \DefineTOCEntryLengthOption{pagenumberwidth}%
    {scr@tso@}{@pagenumberwidth}{width of page number box}%
%</tocline>
%<*tocline|toctext>
  \DefineTOCEntryLengthOption{rightindent}%
    {scr@tso@}{@rightindent}{entry's text right indent}%
%</tocline|toctext>  
%    \end{macrocode}
% \changes{v3.21}{2016/06/06}{new option \opt{raggedentrytext}}
% Unfortunately definition of option \opt{raggedentrytext} is somehow
% cumbersome, to be more or less compatible with former definition of
% \cs{raggedchapterentry}.
%    \begin{macrocode}
%<*tocline>
  \DefineTOCEntryOption{raggedentrytext}[true]{%
    \FamilySetBool{KOMAarg}{raggedentrytext}{@tempswa}{##1}%
    \ifx\FamilyKeyState\FamilyKeyStateProcessed
      \if@tempswa
        \expandafter\let\csname ragged\scr@dte@current entry\endcsname
        \raggedright
      \else
        \expandafter\let\csname ragged\scr@dte@current entry\endcsname
        \relax
      \fi
    \fi
  }%
  \DefineTOCEntryIfOption{raggedpagenumber}%
    {scr@tso@}{@raggedpage}{page number ragged flag}%
%</tocline>
%<*toctext>
  \DefineTOCEntryIfOption{raggedright}%
    {scr@tso@}{@raggedright}{use raggedright for the whole paragraph}%
%</toctext>
  \DefineTOCEntryLengthOption{indent}%
    {scr@tso@}{@indent}{entry indent}%
%<*dottedtocline|undottedtocline|tocline>
  \DefineTOCEntryLengthOption{numwidth}%
    {scr@tso@}{@numwidth}{entry number width}%
%</dottedtocline|undottedtocline|tocline>
%    \end{macrocode}
% Automatic setting of the numerical level of option \opt{level} resp. command
% \cs{\meta{entry name}tocdepth} can be done either by increasing the parent
% level number of a sub level, if the parent level has already be defined:
% \changes{v3.21}{2016/06/09}{\cs{the} inserted}
% \changes{v3.28}{2019/11/18}{\cs{ifstr} renamed to \cs{Ifstr}}
%    \begin{macrocode}
%<*tocline|toctext>
  \scr@ifundefinedorrelax{#1tocdepth}{%
    \Ifstrstart{#1}{sub}{%
      \scr@ifundefinedorrelax{\scr@dte@nosub{#1}tocdepth}{}{%
        \expandafter\edef\csname #1tocdepth\endcsname{%
          \the\numexpr \noexpand\@nameuse{\scr@dte@nosub{#1}tocdepth}+\@ne\relax
        }%
      }%
    }{}%
  }{}%
%</tocline|toctext>
%    \end{macrocode}
% or, if this cannot be used, by using a standard value analogues to the
% values of the standard classes and the \KOMAScript{} classes.
% \changes{v3.39}{2022/10/24}{default level for \texttt{lstlisting} added}
%    \begin{macrocode}
  \@ifundefined{#1tocdepth}{%
    \Ifstr{#1}{part}{\@namedef{#1tocdepth}{-1}}{%
      \Ifstr{#1}{chapter}{\@namedef{#1tocdepth}{0}}{%
        \Ifstr{#1}{section}{\@namedef{#1tocdepth}{1}}{%
          \Ifstr{#1}{subsection}{\@namedef{#1tocdepth}{2}}{%
            \Ifstr{#1}{subsubsection}{\@namedef{#1tocdepth}{3}}{%
              \Ifstr{#1}{paragraph}{\@namedef{#1tocdepth}{4}}{%
                \Ifstr{#1}{subparagraph}{\@namedef{#1tocdepth}{5}}{%
                  \Ifstr{#1}{figure}{\@namedef{#1tocdepth}{1}}{%
                    \Ifstr{#1}{table}{\@namedef{#1tocdepth}{1}}{%
                      \Ifstr{#1}{lstlisting}{\@namedef{#1tocdepth}{1}}{%
%    \end{macrocode}
% As last chance, we can use the same number already used for a headings level
% with the same name.
%    \begin{macrocode}
                        \expandafter\let\csname #1tocdepth\expandafter\endcsname
                        \csname #1numdepth\endcsname
                      }%
                    }%
                  }%
                }%
              }%
            }%
          }%
        }%
      }%
    }%
  }{}%
%    \end{macrocode}
% \changes{v3.39}{2022/10/24}{try also using \cs{toclevel@\meta{level name}} as
%   default level}
% Last but not least, if \cs{tocdepth@\meta{level name}} has been defined, we
% can use this one.
%    \begin{macrocode}
  \@ifundefined{#1tocdepth}{%
    \expandafter\let\csname #1tocdepth\expandafter\endcsname
    \csname toclevel@#1\endcsname
  }{}%
%    \end{macrocode}
% The indent can also be defined automatically by a parent level.
%    \begin{macrocode}
%<*tocline|toctext>
  \scr@ifundefinedorrelax{scr@tso@#1@indent}{%
    \@ifundefined{scr@#1@tocindent}{%
      \Ifstrstart{#1}{sub}{%
        \scr@ifundefinedorrelax{scr@tso@\scr@dte@nosub{#1}@indent}{%
          \scr@ifundefinedorrelax{scr@tso@\scr@dte@nosub{#1}@numwidth}{}{%
            \expandafter\edef\csname scr@tso@#1@indent\endcsname{%
              \glueexpr \noexpand\@nameuse{scr@tso@\scr@dte@nosub{#1}@numwidth}%
              \relax
            }%
          }%
        }{%
          \scr@ifundefinedorrelax{scr@tso@\scr@dte@nosub{#1}@numwidth}{%
            \expandafter\edef\csname scr@tso@#1@indent\endcsname{%
              \glueexpr \noexpand\@nameuse{scr@tso@\scr@dte@nosub{#1}@indent}%
              \relax
            }%
          }{%
            \expandafter\edef\csname scr@tso@#1@indent\endcsname{%
              \glueexpr \noexpand\@nameuse{scr@tso@\scr@dte@nosub{#1}@indent}%
                       +\noexpand\@nameuse{scr@tso@\scr@dte@nosub{#1}@numwidth}%
              \relax
            }%
          }%
        }%
      }{}%
    }{%
%    \end{macrocode}
% Former \KOMAScript{} versions use another macro name, that is also defined
% for compatibility.
%    \begin{macrocode}
      \@namedef{scr@tso@#1@indent}{\@nameuse{scr@#1@tocindent}}%
    }%
  }{}%
%</tocline|toctext>
%    \end{macrocode}
% The width of the page number box and the right margin can simply be copied
% from a parent level.
%    \begin{macrocode}
%<*tocline>
  \scr@ifundefinedorrelax{scr@tso@#1@pagenumberwidth}{%
    \Ifstrstart{#1}{sub}{%
      \scr@ifundefinedorrelax{scr@tso@\scr@dte@nosub{#1}@pagenumberwidth}{%
        \@namedef{scr@tso@#1@pagenumberwidth}{\@pnumwidth}%
      }{%
        \expandafter\let
        \csname scr@tso@#1@pagenumberwidth\expandafter\endcsname
        \csname scr@tso@\scr@dte@nosub{#1}@pagenumberwidth\endcsname
      }%
    }{%
      \@namedef{scr@tso@#1@pagenumberwidth}{\@pnumwidth}%
    }%
  }{}%
%</tocline>
%<*tocline|toctext>
  \scr@ifundefinedorrelax{scr@tso@#1@rightindent}{%
    \Ifstrstart{#1}{sub}{%
      \scr@ifundefinedorrelax{scr@tso@\scr@dte@nosub{#1}@rightindent}{%
        \@namedef{scr@tso@#1@rightindent}{\@tocrmarg}%
      }{%
        \expandafter\let
        \csname scr@tso@#1@rightindent\expandafter\endcsname
        \csname scr@tso@\scr@dte@nosub{#1}@rightindent\endcsname
      }%
    }{%
      \@namedef{scr@tso@#1@rightindent}{\@tocrmarg}%
    }%
  }{}%
%</tocline|toctext>
%    \end{macrocode}
% If all the automatic setting methods were not successful, we try standard
% values used from the standard classes or older versions of the \KOMAScript{}
% classes.
% \changes{v3.39}{2022/10/24}{default indent for \texttt{lstlisting} added}
%    \begin{macrocode}
  \@ifundefined{scr@tso@#1@indent}{%
%<*dottedtocline|undottedtocline|largetocline>
    \@ifundefined{scr@#1@tocindent}{%
%</dottedtocline|undottedtocline|largetocline>
      \Ifstr{#1}{figure}{\@namedef{scr@tso@#1@indent}{1.5em}}{%
        \Ifstr{#1}{table}{\@namedef{scr@tso@#1@indent}{1.5em}}{%
          \Ifstr{#1}{lstlisting}{\@namedef{scr@tso@#1@indent}{1.5em}}{%
            \Ifstr{#1}{part}{\@namedef{scr@tso@#1@indent}{0em}}{%
              \Ifstr{#1}{chapter}{\@namedef{scr@tso@#1@indent}{0em}}{%
%    \end{macrocode}
% The follow code needs information about the existence of the chapter
% level. So the chapter level should already be defined, before the first
% usage!
%    \begin{macrocode}
                \scr@ifundefinedorrelax{l@chapter}{%
                  \Ifstr{#1}{section}{\@namedef{scr@tso@#1@indent}{0pt}}{%
                    \Ifstr{#1}{subsection}{\@namedef{scr@tso@#1@indent}{1.5em}}{%
                      \Ifstr{#1}{subsubsection}{%
                        \@namedef{scr@tso@#1@indent}{3.8em}%
                      }{%
                        \Ifstr{#1}{paragraph}{%
                          \@namedef{scr@tso@#1@indent}{7em}%
                        }{%
                          \Ifstr{#1}{subparagraph}{%
                            \@namedef{scr@tso@#1@indent}{10em}%
                          }{%
%    \end{macrocode}
% If nothing helps, the user has to define the values.
%    \begin{macrocode}
                          }%
                        }%
                      }%
                    }%
                  }%
                }{%
                  \Ifstr{#1}{section}{\@namedef{scr@tso@#1@indent}{1.5em}}{%
                    \Ifstr{#1}{subsection}{\@namedef{scr@tso@#1@indent}{3.8em}}{%
                      \Ifstr{#1}{subsubsection}{%
                        \@namedef{scr@tso@#1@indent}{7.0em}%
                      }{%
                        \Ifstr{#1}{paragraph}{%
                          \@namedef{scr@tso@#1@indent}{10em}%
                        }{%
                          \Ifstr{#1}{subparagraph}{%
                            \@namedef{scr@tso@#1@indent}{12em}%
                          }{%
%    \end{macrocode}
% Once more: if nothing helps, the user has to define the values.
%    \begin{macrocode}
                          }%
                        }%
                      }%
                    }%
                  }%
                }%
              }%
            }%
          }%
        }%
      }%
%<*dottedtocline|undottedtocline|largetocline>
    }{%
%    \end{macrocode}
% Once again, for compatibility with former versions of \KOMAScript:
%    \begin{macrocode}
      \@namedef{scr@tso@#1@indent}{\@nameuse{scr@#1@tocindent}}%
    }%
%</dottedtocline|undottedtocline|largetocline>
  }{}%
%    \end{macrocode}
% Almost the same for the number width:
% \changes{v3.39}{2022/10/24}{default number width for \texttt{lstlisting} added}
%    \begin{macrocode}
%<*dottedtocline|undottedtocline|tocline>
%<*tocline>
  \scr@ifundefinedorrelax{scr@tso@#1@numwidth}{%
    \scr@ifundefinedorrelax{scr@#1@tocnumwidth}{%
      \Ifstrstart{#1}{sub}{%
        \scr@ifundefinedorrelax{scr@tso@\scr@dte@nosub{#1}@numwidth}{}{%
          \expandafter\edef\csname scr@tso@#1@numwidth\endcsname{%
            \glueexpr \noexpand\@nameuse{scr@tso@\scr@dte@nosub{#1}@numwidth}%
                     +.9em%
            \relax
          }%
        }%
      }{}%
    }{%
      \@namedef{scr@tso@#1@numwidth}{\@nameuse{scr@#1@tocnumwidth}}%
    }%
  }{}%
%</tocline>
  \@ifundefined{scr@tso@#1@numwidth}{%
%<*dottedtocline|undottedtocline>
    \@ifundefined{scr@#1@tocnumwidth}{%
%</dottedtocline|undottedtocline>
      \Ifstr{#1}{figure}{\@namedef{scr@tso@#1@numwidth}{2.3em}}{%
        \Ifstr{#1}{table}{\@namedef{scr@tso@#1@numwidth}{2.3em}}{%
          \Ifstr{#1}{lstlisting}{\@namedef{scr@tso@#1@numwidth}{2.3em}}{%
            \Ifstr{#1}{chapter}{\@namedef{scr@tso@#1@numwidth}{1.5em}}{%
%    \end{macrocode}
% Depending on existence of the chapter level:
%    \begin{macrocode}
              \scr@ifundefinedorrelax{chapter}{%
                \Ifstr{#1}{section}{\@namedef{scr@tso@#1@numwidth}{1.5em}}{%
                  \Ifstr{#1}{subsection}{\@namedef{scr@tso@#1@numwidth}{2.3em}}{%
                    \Ifstr{#1}{subsubsection}{%
                      \@namedef{scr@tso@#1@numwidth}{3.2em}%
                    }{%
                      \Ifstr{#1}{paragraph}{%
                        \@namedef{scr@tso@#1@numwidth}{4.1em}%
                      }{%
                        \Ifstr{#1}{subparagraph}{%
                          \@namedef{scr@tso@#1@numwidth}{5m}%
                        }{%
%    \end{macrocode}
% Need option to be set.
%    \begin{macrocode}
                        }%
                      }%
                    }%
                  }%
                }%
              }{%
                \Ifstr{#1}{section}{\@namedef{scr@tso@#1@numwidth}{2.3em}}{%
                  \Ifstr{#1}{subsection}{\@namedef{scr@tso@#1@numwidth}{3.2em}}{%
                    \Ifstr{#1}{subsubsection}{%
                      \@namedef{scr@tso@#1@numwidth}{3.1em}%
                    }{%
                      \Ifstr{#1}{paragraph}{%
                        \@namedef{scr@tso@#1@numwidth}{5em}%
                      }{%
                        \Ifstr{#1}{subparagraph}{%
                          \@namedef{scr@tso@#1@numwidth}{6em}%
                        }{%
%    \end{macrocode}
% Need option to be set.
%    \begin{macrocode}
                        }%
                      }%
                    }%
                  }%
                }%
              }%
            }%
          }%
        }%
      }%
%<*dottedtocline|undottedtocline>
    }{%
%    \end{macrocode}
% Compatibility with old \KOMAScript{} versions.
%    \begin{macrocode}
      \@namedef{scr@tso@#1@numwidth}{\@nameuse{scr@#1@tocnumwidth}}%
    }%
%</dottedtocline|undottedtocline>
  }{}%
%</dottedtocline|undottedtocline|tocline>
%<*tocline>
%    \end{macrocode}
% The three penalty hooks. Here simply the default commands are used by
% default.
%    \begin{macrocode}
  \expandafter\providecommand%
  \csname scr@tso@#1@LastTOCLevelWasLower\endcsname{\LastTOCLevelWasLower}%
  \expandafter\providecommand%
  \csname scr@tso@#1@LastTOCLevelWasSame\endcsname{\LastTOCLevelWasSame}%
  \expandafter\providecommand%
  \csname scr@tso@#1@LastTOCLevelWasHigher\endcsname{\LastTOCLevelWasHigher}%
%    \end{macrocode}
% The default of the vertical distance of entries is 0 plus some glue. But
% this is enough only for at least one line, if needed for vertical
% justification. For the higher levels (part and chapter resp. section) the
% defaults of the standard classes are used. These have some more glue.
%    \begin{macrocode}
  \@ifundefined{scr@tso@#1@beforeskip}{%
    \Ifstr{#1}{part}{%
      \@namedef{scr@tso@#1@beforeskip}{\glueexpr 2.25em \@plus\p@\relax}%
    }{%
      \Ifstr{#1}{chapter}{%
        \@namedef{scr@tso@#1@beforeskip}{\glueexpr 1.0em \@plus\p@\relax}%
      }{%
        \Ifstr{#1}{section}{%
          \scr@ifundefinedorrelax{l@chapter}{%
            \@namedef{scr@tso@#1@beforeskip}{\glueexpr 1.0em \@plus\p@\relax}%
          }{}%
        }{}%
      }%
    }%
    \expandafter\providecommand\expandafter*%
    \csname scr@tso@#1@beforeskip\endcsname{\glueexpr \z@ plus .2\p@\relax}%
  }{}%
%</tocline>
%    \end{macrocode}
% \changes{v3.31}{2020/06/09}{\opt{beforeskip} default also for style \texttt{toctext}}
% For style |toctext| a default without glue is used to stay compatible.
%    \begin{macrocode}
%<*toctext>
  \expandafter\providecommand\expandafter*%
  \csname scr@tso@#1@beforeskip\endcsname{\z@}%
%</toctext>
%<*tocline>
%    \end{macrocode}
% It would be good to know the width of the widest number. We will use this to
% test several conditions.
%    \begin{macrocode}
  \@ifundefined{scr@dte@#1@maxnumwidth}{%
    \expandafter\newlength\csname scr@dte@#1@maxnumwidth\endcsname
    \setlength{\@nameuse{scr@dte@#1@maxnumwidth}}{\z@}%
  }{}%
  \providecommand*{\scr@dte@donumwidth}{}%
  \g@addto@macro{\scr@dte@donumwidth}{\do{#1}}%
%</tocline>
%    \end{macrocode}
% One condition is a minimum distance between number and text.
%    \begin{macrocode}
%<*tocline|toctext>
  \expandafter\providecommand\expandafter*%
  \csname scr@tso@#1@numsep\endcsname{.4em}%
%</tocline|toctext>
%    \end{macrocode}
% The |toctext| style support the output of some text before the first entry
% of a paragraph, between the entries and after the last entry of a paragraph.
%    \begin{macrocode}
%<*toctext>
  \expandafter\providecommand%
  \csname scr@tso@#1@onstartfirstentry\endcsname{}%
  \expandafter\providecommand%
  \csname scr@tso@#1@onstartentry\endcsname{}%
  \expandafter\providecommand%
  \csname scr@tso@#1@onendlastentry\endcsname{}%
  \expandafter\providecommand%
  \csname scr@tso@#1@onendentry\endcsname{\quad}%
  \expandafter\providecommand%
  \csname scr@tso@#1@afterpar\endcsname{}%
%</toctext>
%    \end{macrocode}
% Formatting for only the number and formatting for number and text are
% provided. For part we use the formatting of the standard classes as default.
%    \begin{macrocode}
%<*tocline|toctext>
  \expandafter\providecommand%
  \csname scr@tso@#1@numberformat\endcsname[1]{##1}%
%<*tocline>
  \Ifstr{#1}{part}{%
    \expandafter\providecommand%
    \csname scr@tso@#1@entryformat\endcsname[1]{\large\bfseries ##1}%
  }{%
    \Ifstr{#1}{chapter}{%
      \expandafter\providecommand%
      \csname scr@tso@#1@entryformat\endcsname[1]{\bfseries ##1}%
    }{%
      \scr@ifundefinedorrelax{l@chapter}{%
        \Ifstr{#1}{section}{%
          \expandafter\providecommand%
          \csname scr@tso@#1@entryformat\endcsname[1]{\bfseries ##1}%
        }{}%
      }{}%
%</tocline>
      \expandafter\providecommand%
      \csname scr@tso@#1@entryformat\endcsname[1]{##1}%
%<*tocline>      
    }%
  }%
%</tocline>
%</tocline|toctext>
%    \end{macrocode}
% After the number a line break is optional. In this case the text starts
% again at the horizontal position of the number and not behind it. The
% default is, not to break after the number.
%    \begin{macrocode}
%<*tocline>
  \expandafter\providecommand
  \csname Ifscr@tso@#1@breakafternumber\endcsname[2]{##2}%
%    \end{macrocode}
% The default of the connection between the end of the text and the page
% number column is a simple \cs{hfill}. Here you can optionally use dots as usual.
%    \begin{macrocode}
  \@ifundefined{scr@tso@#1@linefill}{%
    \Ifstr{#1}{part}{%
      \@namedef{scr@tso@#1@linefill}{\hfill}%
    }{%
      \Ifstr{#1}{chapter}{%
        \@namedef{scr@tso@#1@linefill}{\hfill}%
      }{%
        \scr@ifundefinedorrelax{l@chapter}{%
          \Ifstr{#1}{section}{%
            \@namedef{scr@tso@#1@linefill}{\hfill}%
          }{}%
        }{}%
        \expandafter\providecommand%
        \csname scr@tso@#1@linefill\endcsname{\TOCLineLeaderFill\relax}%
      }%
    }%
  }{}%
%    \end{macrocode}
% If you don't want a connection, this does not automatically mean, that the
% page number moves forwards to the end of the text. This only happens, if the
% entry is set ragged.
%    \begin{macrocode}
  \expandafter\providecommand\csname Ifscr@tso@#1@raggedpage\endcsname[2]{##2}%
%    \end{macrocode}
% Optionally you can use a formatting for the page number.
%    \begin{macrocode}
  \Ifstr{#1}{part}{%
%    \end{macrocode}
% With parts this is usually large and bold.
%    \begin{macrocode}
    \expandafter\providecommand%
    \csname scr@tso@#1@pagenumberformat\endcsname[1]{\large\bfseries ##1}%
  }{%
%    \end{macrocode}
% \changes{v3.25}{2017/11/23}{default of page numbers of chapter entries is bold}
% With chapters it is bold.
%    \begin{macrocode}
    \Ifstr{#1}{chapter}{%
      \expandafter\providecommand%
      \csname scr@tso@#1@pagenumberformat\endcsname[1]{\bfseries ##1}%
    }{%
      \scr@ifundefinedorrelax{l@chapter}{%
        \Ifstr{#1}{section}{%
%    \end{macrocode}
% \changes{v3.25}{2017/11/23}{default of page numbers of section entries maybe
%   bold}
% With sections sometimes bold.
%    \begin{macrocode}
          \expandafter\providecommand%
          \csname scr@tso@#1@pagenumberformat\endcsname[1]{\bfseries ##1}%
        }{}%
      }{}%
%    \end{macrocode}
% All others in normal font and normal color.
%    \begin{macrocode}
      \expandafter\providecommand%
      \csname scr@tso@#1@pagenumberformat\endcsname[1]{%
        \normalfont\normalcolor ##1}%
    }%
  }%
%    \end{macrocode}
% Sometimes the page number has a box with defined width.
% \changes{v3.27}{2019/10/02}{consequent use of width of page number box}
%    \begin{macrocode}
  \expandafter\providecommand%
  \csname scr@tso@#1@pagenumberbox\endcsname[1]{%
    \hb@xt@\@nameuse{scr@dte@pagenumberwidth}{\hfil ##1}}%
  \expandafter\providecommand\csname Ifscr@tso@#1@dynnumwidth\endcsname[2]{##2}%
%    \end{macrocode}
% \changes{v3.31}{2020/06/08}{init indent follows list}
% This command defines a list of levels that specify the indent (if not empty).
%    \begin{macrocode}
  \expandafter\providecommand\csname Ifscr@tso@#1@dynindent\endcsname[2]{##2}%
  \scr@ifundefinedorrelax{scr@tso@#1@indentfollows}{%
    \Ifstrstart{#1}{sub}{%
      \expandafter\edef\csname scr@tso@#1@indentfollows\endcsname{%
        \scr@dte@nosub{#1}%
      }%
    }{%
      \expandafter\let\csname scr@tso@#1@indentfollows\endcsname\@empty
    }%
  }{}%
%</tocline>
%    \end{macrocode}
% \changes{v3.27}{2019/07/08}{initialization of \opt{raggedentry}}
% \changes{v3.27}{2019/07/08}{initialization of \opt{prepagenumber}}
% With style |toctext| we have to initialize ragged or justified text and what
% to print immediately before the page number (\opt{linefill} wouldn't have
% been a suitable term).
%    \begin{macrocode}
%<*toctext>
  \expandafter\providecommand%
  \csname Ifscr@tso@#1@raggedright\endcsname[2]{##2}%
  \expandafter\providecommand%
  \csname scr@tso@#1@prepagenumber\endcsname{\nobreakspace}%
%</toctext>
}]{%
%    \end{macrocode}
% \changes{v3.27}{2019/05/12}{support for \opt{noindent}}
% \changes{v3.28}{2019/11/19}{\cs{iftocfeature} replaced by
%   \cs{Iftocfeature}}
% Initialization complete. Next we have the output code or macro.
%    \begin{macrocode}
%<*dottedtocline>
  \Iftocfeature{\@currext}{noindent}{%
    \@dottedtocline{\@nameuse{#1tocdepth}}{\z@}%
                   {\@nameuse{scr@tso@#1@numwidth}}{##1}{##2}%
  }{%
    \@dottedtocline{\@nameuse{#1tocdepth}}{\@nameuse{scr@tso@#1@indent}}%
                   {\@nameuse{scr@tso@#1@numwidth}}{##1}{##2}%
  }%
%</dottedtocline> 
%<*undottedtocline|largetocline>
  \ifnum \c@tocdepth >\numexpr \@nameuse{#1tocdepth}-\@ne\relax
%    \end{macrocode}
% Here we have a little difference between chapters and the sections of
% \cls*{article}. We do this by the level. So if you change the levels, the
% result would change too.
%    \begin{macrocode}
    \ifnum \@nameuse{#1tocdepth}<\@ne
      \scr@ifundefinedorrelax{chapter}{%
        \addpenalty\@secpenalty
%<undottedtocline>        \addvspace{1.0em \@plus\p@}%
%<largetocline>        \addvspace{2.25em \@plus\p@}%
      }{%
        \addpenalty{-\@highpenalty}%
%<undottedtocline>        \vskip 1.0em \@plus\p@
%<largetocline>        \addvspace{2.25em \@plus\p@}%
      }%
    \else
      \addpenalty\@secpenalty
%<undottedtocline>      \addvspace{1.0em \@plus\p@}%
%<largetocline>      \addvspace{2.25em \@plus\p@}%
    \fi
%<undottedtocline>    \setlength\@tempdima{\@nameuse{scr@tso@#1@numwidth}}%
%<largetocline>    \setlength\@tempdima{3em}%
    \begingroup
%    \end{macrocode}
% Note: Here we should use two \cs{@tocrmarg} correctly. I've reported this
% bug in the standard classes years ago without any change. So for
% compatibility I've decided to accept it as feature and two times
% \cs{@pnumwith} like the standard classes.
%    \begin{macrocode}
      \parindent \z@ \rightskip \@pnumwidth
      \parfillskip -\@pnumwidth
%    \end{macrocode}
% The standard classes use a group at this point. This group ends before the
% final \cs{par}. This can result in wrong baseline skip for multi line
% entries. It was a hard decision, but I've decided to avoid this bug, because
% it was much too strange. Moreover, with the bug, the setting of
% \len{leftskip} would have to be changed, because here also the value at the
% end of the paragraph is used.
%    \begin{macrocode}
      \leavevmode
%<largetocline>      \large
      \bfseries
%    \end{macrocode}
% Note, here we also should use \cs{@tempdima} with style |largetocline|. But
% we cannot do so, only because the standard classes do not use
% \cs{numberline} for parts. Because of this, multi line entries are not
% correctly indented. To do this same is also because of compatibility.
% \changes{v3.28}{2019/11/19}{\cs{iftocfeature} replaced by \cs{Iftocfeature}}
%    \begin{macrocode}
%<undottedtocline>      \advance\leftskip\@tempdima
      \Iftocfeature{\@currext}{noindent}{%
%<undottedtocline>        \hskip -\leftskip
      }{%
        \advance\leftskip\@nameuse{scr@tso@#1@indent}%
%<*undottedtocline>
        \hskip -\dimexpr \leftskip-\@nameuse{scr@tso@#1@indent}\relax
%</undottedtocline>
      }%
      ##1%
%<undottedtocline>      \nobreak
%    \end{macrocode}
% Here \cs{@pnumwidth} is not the same absolute value for entries with
% \cs{large} as for entries without \cs{large}. So correctly, e.g., the value
% should be transferred via \len{@temdimb}. But because of compatibility this
% bug hat also been interpreted as feature.
%    \begin{macrocode}
      \hfil \nobreak\hb@xt@\@pnumwidth{\hss ##2}%
      \par
%<undottedtocline>      \penalty\@highpenalty
%<*largetocline>
      \nobreak
      \ifnum 0=
        \scr@ifundefinedorrelax{chapter}{\if@compatibility 1\else 0\fi}{1}\relax
        \global\@nobreaktrue
        \everypar{\global\@nobreakfalse\everypar{}}%
      \fi
%</largetocline>
    \endgroup
  \fi
%</undottedtocline|largetocline>
%<*tocline>
  \scr@dte@tocline{#1}{##1}{##2}%
%</tocline>
%<*toctext>
  \scr@dte@toctext{#1}{##1}{##2}%
%</toctext>
}
%</dottedtocline|undottedtocline|largetocline|tocline|toctext>
%    \end{macrocode}
% \end{macro}^^A \scr@dte@def@l@toctext
% \end{macro}^^A \scr@dte@def@l@tocline
% \end{macro}^^A \scr@dte@def@l@largetocline
% \end{macro}^^A \scr@dte@def@l@undottedtocline
% \end{macro}^^A \scr@dte@def@l@dottedtocline
%
% Style |tocline| needs several additional settings and macros:
%    \begin{macrocode}
%<*tocline>
\AtBeginDocument{%
  \BeforeClosingMainAux{%
    \begingroup
      \def\do#1{%
        \relax
        \scr@ifundefinedorrelax{scr@dte@#1@maxnumwidth}{}{%
          \ifdim \@nameuse{scr@dte@#1@maxnumwidth}>\z@
            \if@filesw
              \protected@write\@mainaux{}{%
                \string\global\string\@namedef{scr@dte@#1@lastmaxnumwidth}%
                {\the\@nameuse{scr@dte@#1@maxnumwidth}}%
              }%
            \fi
            \@nameuse{scr@dte@#1@maxnumwidth}\z@
          \fi
        }%
      }%
      \@nameuse{scr@dte@donumwidth}%
    \endgroup
  }%
}
%    \end{macrocode}
% \begin{macro}{\scr@dte@nosub,\@scr@dte@nosub}
% \changes{v3.20}{2015/11/23}{added}
% These helper macros are used to recognize the |sub| prefix at the start of
% an argument and remove it. If there isn't a |sub| at the very beginning, we
% report an error, because of wrong usage of \cs{@scr@de@nusub}.
%    \begin{macrocode}
\newcommand*{\scr@dte@nosub}[1]{\@scr@dte@nosub #1\relax}
\newcommand*{\@scr@dte@nosub}{}
\def\@scr@dte@nosub sub#1\relax{#1}
%    \end{macrocode}
% \end{macro}^^A \scr@dte@nosub,\@scr@dte@nosub
% \begin{macro}{\scr@dte@tocline}
% \changes{v3.20}{2015/11/22}{added}
% \changes{v3.27}{2019/05/12}{support for \opt{noindent}}
% \changes{v3.28}{2019/11/19}{\cs{iftocfeature} replaced by \cs{Iftocfeature}}
% This is somehow like the \LaTeX{} kernel macro \cs{@dottedtocline}. But it
% supports a lot of more attributes, not only the level, the numberwidth, the
% indent and the text. The attributes are handled by options. So we need only
% three arguments:
% \begin{description}
% \item[\marg{level name}:] the name of the ToC entry level;
% \item[\marg{entry}:] the ToC entry;
% \item[\marg{page number}:] the page number of the ToC entry.
% \end{description}
% \begin{length}{\scr@dte@tocline@numberwidth}
% \changes{v3.20}{2016/01/15}{added}
% Sometimes the real width of a formatted number is of interest. So we store
% it in \len{scr@dte@tocline@numberwidth}.
%    \begin{macrocode}
\newlength\scr@dte@tocline@numberwidth
\newcommand*{\scr@dte@tocline}[3]{%
  \ifnum \@nameuse{#1tocdepth}>\c@tocdepth
  \else
    \tocbasic@DependOnPenaltyAndTOCLevel{#1}%
    \addvspace{\@nameuse{scr@tso@#1@beforeskip}}\relax
%    \end{macrocode}
% \changes{v3.31}{2020/06/08}{code for indent following list processing}
% If a indent following list exists and the depth of an entry is lower than
% the depth of the current entry, use the maximum of the ident + number width
% for the indent of this entry.
%    \begin{macrocode}
    \@nameuse{Ifscr@tso@#1@dynindent}{%
      \expandafter\ifx\csname scr@tso@#1@indentfollows\endcsname\@empty
        \PackageWarning{tocbasic}{`dynindent' for `#1' not available}%
      \else
        \edef\reserved@a{\@nameuse{scr@tso@#1@indentfollows}}%    
        \@for \reserved@a:=\reserved@a\do {%
          \scr@trim@spaces\reserved@a
          \ifx\reserved@a\@empty\else
            \scr@ifundefinedorrelax{\reserved@a tocdepth}{%
            }{%
              \ifnum \@nameuse{\reserved@a tocdepth}<\@nameuse{#1tocdepth}%
                \@tempdima\@nameuse{scr@tso@\reserved@a @indent}\relax
                \@nameuse{Ifscr@tso@\reserved@a @dynnumwidth}{%
                  \scr@ifundefinedorrelax
                  {scr@dte@\reserved@a @lastmaxnumwidth}{%
                    \advance\@tempdima
                    \@nameuse{scr@tso@\reserved@a @numwidth}\relax
                  }{%
                    \advance\@tempdima
                    \@nameuse{scr@dte@\reserved@a @lastmaxnumwidth}\relax
                  }%
                }{%
                  \advance\@tempdima
                  \@nameuse{scr@tso@\reserved@a @numwidth}\relax
                }%
                \ifdim \@tempdima>\@nameuse{scr@tso@#1@indent}\relax
                  \expandafter\edef\csname scr@tso@#1@indent\endcsname
                  {\the\@tempdima}%
                \fi
              \fi
            }%
          \fi
        }%
      \fi
    }{}%  
    {%
      \Iftocfeature{\@currext}{noindent}{%
        \leftskip \z@
      }{%
        \leftskip \@nameuse{scr@tso@#1@indent}\relax
      }%
      \rightskip \@nameuse{scr@tso@#1@rightindent}\relax
      \parfillskip -\rightskip
      \@nameuse{Ifscr@tso@#1@raggedpage}{%
        \addtolength{\parfillskip}{\z@ \@plus 1fil}%
      }{}%
      \Iftocfeature{\@currext}{noindent}{%
        \parindent \z@
      }{%
        \parindent \@nameuse{scr@tso@#1@indent}\relax
      }%
      \@afterindenttrue
      \interlinepenalty\@M
%    \end{macrocode}
% \changes{v3.21}{2016/06/06}{\cs{ragged\dots entry} is supported (again)}
%    \begin{macrocode}
      \expandafter\ifx\csname ragged#1entry\endcsname\raggedright
        \addtolength\rightskip\@flushglue
      \else
        \def\reserved@a{\raggedright}%
        \expandafter\ifx\csname ragged#1entry\endcsname\reserved@a
          \addtolength\rightskip\@flushglue
        \else
          \renewcommand\reserved@a{\raggedright}%
          \expandafter\ifx\csname ragged#1entry\endcsname\reserved@a
            \addtolength\rightskip\@flushglue
          \fi
        \fi
      \fi
      \leavevmode
      \@tempdima \@nameuse{scr@tso@#1@numwidth}\relax
      \@nameuse{Ifscr@tso@#1@dynnumwidth}{%
        \scr@ifundefinedorrelax{scr@dte@#1@lastmaxnumwidth}{}{%
          \ifdim \@nameuse{scr@dte@#1@lastmaxnumwidth}>\@tempdima
            \@tempdima\@nameuse{scr@dte@#1@lastmaxnumwidth}\relax
          \fi
        }%
      }{}%
      \advance\leftskip \@tempdima 
      \null\nobreak\hskip -\leftskip
      {%
%    \end{macrocode}
% Here we use a trick to detect the width of an eventually existing number
% while printing it. For this it is a must to use the internal definition of
% \cs{numberline}.
%    \begin{macrocode}
        \usetocbasicnumberline
        \let\scr@dte@numberline@box\numberline@box
        \def\numberline@box##1{%
          \sbox\scr@dte@tocline@numbox{\@nameuse{scr@tso@#1@numberformat}{##1}}%
%    \end{macrocode}
% We are inside a group, so we have to set the length globally.
%    \begin{macrocode}
          \global\scr@dte@tocline@numberwidth
          \dimexpr\wd\scr@dte@tocline@numbox+\@nameuse{scr@tso@#1@numsep}\relax
%    \end{macrocode}
% \changes{v3.22}{2016/12/02}{missing second \cs{relax} added}
% Attention: We need two \cs{relax}, because the first one is eaten by
% \cs{dimexpr}.
%    \begin{macrocode}
          \relax
          \ifdim \scr@dte@tocline@numberwidth
                >\@nameuse{scr@dte@#1@maxnumwidth}\relax
            \global\@nameuse{scr@dte@#1@maxnumwidth}\scr@dte@tocline@numberwidth
          \fi
          \@nameuse{Ifscr@tso@#1@dynnumwidth}{}{%
            \ifdim \scr@dte@tocline@numberwidth
                  >\dimexpr \@nameuse{scr@tso@#1@numwidth}%
                           +\@nameuse{scr@tso@#1@numsep}\relax\relax
              \PackageWarning{tocbasic}{%
                number width of #1 toc entries should be
                increased!\MessageBreak
                Currently used number width =
                \the\wd\scr@dte@tocline@numbox,\MessageBreak
                Wanted number separation
                \space\space\space =
                \the\dimexpr\@nameuse{scr@tso@#1@numsep}\relax,\MessageBreak
                Reserved number width \space\space\space\space\space\space =
                \the\dimexpr\@nameuse{scr@tso@#1@numwidth}\relax%
              }%
            \fi
          }%
          \scr@dte@numberline@box{\@nameuse{scr@tso@#1@numberformat}{##1}}%
          \@nameuse{Ifscr@tso@#1@breakafternumber}{%
            {\parfillskip\@flushglue\par}\nobreak\hskip-\leftskip
          }{}%
        }%
        \@nameuse{scr@tso@#1@entryformat}{%
          #2%
          \nobreak
          {%
            \normalfont\normalsize\@nameuse{scr@tso@#1@linefill}%
            \nobreak
%    \end{macrocode}
% \changes{v3.27}{2019/10/02}{\cs{scr@dte@pagenumberwidth} is defined}
% We don't want a dependency of entry variable from entry variables. So
% locally \cs{scr@dte@pagenumberwidth} will become
% \cs{scr@tso@\meta{Eintragsname}@pagenumberwidth} and in the definition of
% \cs{scr@tso@\meta{Eintragsname}@pagenumberbox} we use this local macro.
%    \begin{macrocode}
            \expandafter\let\expandafter\scr@dte@pagenumberwidth
            \csname scr@tso@#1@pagenumberwidth\endcsname
            \@nameuse{scr@tso@#1@pagenumberbox}{%
              \@nameuse{scr@tso@#1@pagenumberformat}{#3}%
            }%
          }%
          \@par
        }%
      }%
    }%
    \tocbasic@SetPenaltyByTOCLevel{#1}%
  \fi
}
%    \end{macrocode}
% \end{length}^^A \scr@dte@tocline@numberwidth
% \begin{macro}{\scr@dte@tocline@numbox}
% \changes{v3.20}{2015/11/25}{new (\emph{box})}
% Needed to measure the width of the number and use the number later.
%    \begin{macrocode}
\newsavebox\scr@dte@tocline@numbox
%    \end{macrocode}
% \end{macro}^^A \scr@dte@tocline@numbox
% \begin{macro}{\tocbasic@DependOnPenaltyAndTOCLevel,
%               \tocbasic@SetPenaltyByTOCLevel}
% \changes{v3.20}{2015/11/23}{added}
% \changes{v3.20}{2016/03/12}{changed for \pkg*{tocbasic} syntax of package
%   author macros}
% \cs{tocbasic@DepenedOnPenaltyAndTOCLevel} executes a saved action depending
% on whether the current penalty value stands for an entry with higher, same,
% or lower entry level.
% \cs{tocbasic@SetPenaltyByTOCLevel} sets the penalty for the page break
% depending on the current entry level.
% \begin{command}{\LastTOCLevelWasHigher,\LastTOCLevelWasSame,
%                 \LastTOCLevelWasLower}
% \changes{v3.20}{2015/11/23}{added}
% Standard action, if the previous entry level was higher (allow page break),
% same (allow page break), or lower (keep penalty and therefore prevent page
% break).
%    \begin{macrocode}
\newcommand*{\tocbasic@DependOnPenaltyAndTOCLevel}[1]{%
  \ifnum \lastpenalty<\numexpr 20009-\@nameuse{#1tocdepth}\relax
    \@nameuse{scr@tso@#1@LastTOCLevelWasHigher}%
  \else\ifnum \lastpenalty=\numexpr 20009-\@nameuse{#1tocdepth}\relax
      \@nameuse{scr@tso@#1@LastTOCLevelWasSame}%
    \else
      \@nameuse{scr@tso@#1@LastTOCLevelWasLower}%
    \fi
  \fi
}
\newcommand*{\tocbasic@SetPenaltyByTOCLevel}[1]{%
  \penalty \numexpr 20009-\@nameuse{#1tocdepth}\relax
}
\newcommand*{\LastTOCLevelWasHigher}{\ifvmode\addpenalty{\@lowpenalty}\fi}
\newcommand*{\LastTOCLevelWasSame}{\ifvmode\addpenalty{\@lowpenalty}\fi}
\newcommand*{\LastTOCLevelWasLower}{}
%    \end{macrocode}
% \end{command}^^A \LastTOCLevelWasHigher … \LastTOCLevelWasLower
% \end{macro}^^A \tocbasic@SetPenaltyByTOCLevel,\tocbasic@DependOnPenaltyAndTOCLevel
% \begin{command}{\TOCLineLeaderFill}
% \changes{v3.20}{2015/11/14}{added}
% Filler between the last text line and the page number. The optional argument
% \texttt{\#1} is the character used for filling.
%    \begin{macrocode}
\newcommand*{\TOCLineLeaderFill}[1][.]{%
  \leaders\hbox{$\m@th
    \mkern \@dotsep mu\hbox{#1}\mkern \@dotsep
    mu$}\hfill
}
%</tocline>
%    \end{macrocode}
% \end{command}^^A \TOCLineLeaderFill
% \end{macro}^^A \scr@dte@tocline
%
% \begin{macro}{\scr@dte@toctext}
% \changes{v3.27}{2019/07/08}{added}
% \changes{v3.28}{2019/11/19}{\cs{iftocfeature} replaced by
%   \cs{Iftocfeature}}
% This is the command to format entries that will be accumalted into a single
% paragraph. This is somehow special, because the settings of one entrie can
% influence another one. The three arguments are:
% \begin{description}
% \item[\marg{level}:] The name \meta{string} of the entry level.
% \item[\marg{entry}:] The ToC entry \meta{string}.
% \item[\marg{pagenumber}:] The page number \meta{string} of the ToC entry.
% \end{description}
%    \begin{macrocode}
%<*toctext>
\newcommand*{\scr@dte@toctext}[3]{%
  \ifnum \@nameuse{#1tocdepth}>\c@tocdepth
  \else
    \ifhmode
%    \end{macrocode}
% In h-mode their is already output of a previous text entry. So the end code
% of that previous text entry has to be output before the initial output of
% the new text entry has to be done.
%    \begin{macrocode}
      \scr@dte@toctext@lastend
      \@nameuse{scr@tso@#1@onstartentry}%
    \else
%    \end{macrocode}
% \changes{v3.31}{2020/06/09}{use of option \opt{beforeskip}}
% In v-mode it is a new text entry. Before leaving v-mode the vertical space
% is added.
%    \begin{macrocode}
      \addvspace{\@nameuse{scr@tso@#1@beforeskip}}%
      \leavevmode
%    \end{macrocode}
% The paragraph end has to be prepared to eventually change the right
% skip, to do the final output, and after all destroy these commands.
%    \begin{macrocode}
      \def\par{%
        \scr@dte@toctext@raggedright
        \scr@dte@toctext@parend
        \@par
        \scr@dte@toctext@afterpar
        \global\let\scr@dte@toctext@afterpar\relax
        \global\let\scr@dte@toctext@parend\relax
        \global\let\scr@dte@toctext@raggedright\relax
      }%
      \global\let\scr@dte@toctext@afterpar\@empty
%    \end{macrocode}
% Also the left skip and the right skip has to be setup (these are the
% margins) and if any of the text entries has to be printed ragged right, all
% of them should be ragged right.
%    \begin{macrocode}
      \Iftocfeature{\@currext}{noindent}{%
        \leftskip \z@
      }{%
        \leftskip \@nameuse{scr@tso@#1@indent}\relax
      }%
      \rightskip \@nameuse{scr@tso@#1@rightindent}\relax
      \parfillskip \z@ \@plus 1fill\relax
%    \end{macrocode}
% \changes{v3.31}{2020/06/09}{redefinition of \cs{addvspace}}
% \changes{v3.31}{2020/06/09}{redefinition of \cs{addpenalty}}
% Now, make sure, that the first non-|toctext| entry does do a \cs{par}
% before it uses \cs{addpenalty} or \cs{addvspace}. Before version~3.31 this
% has been done by redefining \cs{@noitemerr} but this does not work, because
% it ignores the argument of \cs{addpenalty} or \cs{addvspace}. So, this more
% dangerous solution has been made, that redefines \cs{addvspace} and
% \cs{addpenalty} locally.
%    \begin{macrocode}
      \ifx\addvspace\scr@dte@xaddvspace\else
        \let\scr@dte@saddvspace\addvspace
        \def\scr@dte@xaddvspace{%
          \let\addvspace\scr@dte@saddvspace\par\addvspace}%
        \let\addvspace\scr@dte@xaddvspace
      \fi
      \ifx\addpenalty\scr@dte@xaddpenalty\else
        \let\scr@dte@saddpenalty\addpenalty
        \def\scr@dte@xaddpenalty{%
          \let\addpenalty\scr@dte@saddpenalty\par\addpenalty}%
      \fi
%    \end{macrocode}
% Finally the init code of the first entry has to be used.
%    \begin{macrocode}
      \@nameuse{scr@tso@#1@onstartfirstentry}%
    \fi
%    \end{macrocode}
% Also some settings are independend from beeing the first entry in the
% paragraph or not.
%    \begin{macrocode}
    \@nameuse{Ifscr@tso@#1@raggedright}{%
      \let\\\@centercr
      \gdef\scr@dte@toctext@raggedright{%
        \@rightskip\@flushglue
        \addtolength\rightskip\@rightskip
      }%
    }{}%
    \l@addto@macro\scr@dte@toctext@afterpar{\@nameuse{scr@tso@#1@afterpar}}%
%    \end{macrocode}
% The end codes have to be changed. These are used either at the start of the
% next entry with this style or at the end of the paragraph.
%    \begin{macrocode}
    \expandafter\global\expandafter\let\expandafter\scr@dte@toctext@lastend
    \csname scr@tso@#1@onendentry\endcsname
    \expandafter\global\expandafter\let\expandafter\scr@dte@toctext@parend
    \csname scr@tso@#1@onendlastentry\endcsname
%    \end{macrocode}
% Last but not least, the output has to be done.
%    \begin{macrocode}
    {%
      \usetocbasicnumberline
      \def\numberline@box##1{%
        \mbox{%
          \@nameuse{scr@tso@#1@numberformat}{\ignorespaces ##1\unskip}%
          \hskip\@nameuse{scr@tso@#1@numsep}\relax
        }%
      }%
      \@nameuse{scr@tso@#1@entryformat}{%
        \ignorespaces#2\unskip
        \@nameuse{scr@tso@#1@prepagenumber}%
        \@nameuse{scr@tso@#1@pagenumberformat}{\ignorespaces #3\unskip}%
      }%
    }%
  \fi
}
%    \end{macrocode}
% \begin{macro}{\scr@dte@toctext@raggedright,\scr@dte@toctext@parend,
%               \scr@dte@toctext@lastend}
% Helper macros to store some information for later usage.
%    \begin{macrocode}
\newcommand*{\scr@dte@toctext@raggedright}{}
\newcommand*{\scr@dte@toctext@parend}{}
\newcommand*{\scr@dte@toctext@lastend}{}
%</toctext>
%    \end{macrocode}
% \end{macro}^^A \scr@dte@toctext@raggedright … \scr@dte@toctext@lastend
% \end{macro}^^A \scr@dte@toctext
%
%
% \begin{macro}{\scr@dte@def@l@default}
% \changes{v3.20}{2015/12/16}{new for the package}
% The package \pkg*{tocbasic} already has a standard style. Other packages
% should not change the standard style. But classes are allowed to clone (or
% define) another standard style for documents made with that class.
%    \begin{macrocode}
%<*default>
%%%            (run: style,dottedtocline)
\CloneTOCEntryStyle{dottedtocline}{default}
%</default>
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
%</style>
%</package>
%    \end{macrocode}
%
%
% \subsubsection{The styles used by the \KOMAScript{} classes}
%
%    \begin{macrocode}
%<*class>
%<*style>
%    \end{macrocode}
%
% Some styles are defined by the classes only. They are only defined for the
% classes, that use them. So not all styles are available by all classes and
% even not all styles are the same with every class.
%
% \begin{macro}{\scr@dte@def@l@part}
% \changes{v3.20}{2015/12/07}{ToC entry style \texttt{part} added}
% This style exists with \cls*{scrbook}, \cls*{scrreprt} and
% \cls*{scrartcl}. The formatting of the entry and the page number is defined
% by the font elements \fnt{partentry} and \fnt{partentrypagenumber}.
%    \begin{macrocode}
%<*part>
%%%            (run: class,style,part)
\CloneTOCEntryStyle{tocline}{part}
\TOCEntryStyleStartInitCode{part}{%
  \expandafter\providecommand%
  \csname scr@tso@#1@linefill\endcsname{\hfill}%
  \expandafter\providecommand%
  \csname scr@tso@#1@entryformat\endcsname[1]{\usekomafont{partentry}{##1}}%
  \expandafter\providecommand%
  \csname scr@tso@#1@pagenumberformat\endcsname[1]{%
    \usekomafont{partentry}{\usekomafont{partentrypagenumber}{##1}}}%
  \expandafter\providecommand\expandafter*%
  \csname scr@tso@#1@beforeskip\endcsname{2.25em \@plus\p@}%
}
%</part>
%    \end{macrocode}
% \end{macro}^^A \scr@dte@def@l@part
%
% \begin{macro}{\scr@dte@def@l@chapter}
% \changes{v3.20}{2015/12/07}{ToC entry style \texttt{chapter} added}
% \changes{v3.27}{2019/10/28}{using font element \fnt{chapterentrydots}}
% This style exists with \cls*{scrbook} and \cls*{scrreprt} only.
%    \begin{macrocode}
%<*chapter>
%%%            (run: class,style,chapter)
\CloneTOCEntryStyle{tocline}{chapter}
\TOCEntryStyleStartInitCode{chapter}{%
  \expandafter\providecommand%
  \csname scr@tso@#1@linefill\endcsname{%
    \if@chapterentrywithdots
      {\usekomafont{chapterentrydots}{\TOCLineLeaderFill}}\relax
    \else
      \hfill
    \fi
  }%
  \expandafter\providecommand%
  \csname scr@tso@#1@entryformat\endcsname{\usekomafont{chapterentry}}%
  \expandafter\providecommand%
  \csname scr@tso@#1@pagenumberformat\endcsname[1]{%
    \usekomafont{chapterentry}{\usekomafont{chapterentrypagenumber}{##1}}}%
  \expandafter\providecommand\expandafter*%
  \csname scr@tso@#1@beforeskip\endcsname{1.0em \@plus\p@}%
}
%</chapter>
%    \end{macrocode}
% \end{macro}^^A \scr@dte@def@l@chapter
%
% \begin{macro}{\scr@dte@def@l@section}
% \changes{v3.20}{2015/12/07}{ToC entry style \texttt{section} added}
% \changes{v3.27}{2019/10/28}{using font element \fnt{sectionentrydots}}
% With classes \cls*{scrbook} and \cls*{scrreprt} this is the style of the
% \emph{minor} entry level. With \cls*{scrartcl} this is the style of the top
% entry level (below the part level). So with \cls*{scrartcl} it is similar
% to the chapter style of \cls*{scrbook} or \cls*{scrreprt}.
%    \begin{macrocode}
%<*section>
%%%            (run: class,style,section)
\CloneTOCEntryStyle{tocline}{section}
%<*book|report>
\TOCEntryStyleStartInitCode{section}{%
  \expandafter\providecommand%
  \csname scr@tso@#1@linefill\endcsname{\TOCLineLeaderFill\relax}%
}
%</book|report>
%<*article>
\TOCEntryStyleStartInitCode{section}{%
  \expandafter\providecommand%
  \csname scr@tso@#1@linefill\endcsname{%
    \if@sectionentrywithdots
      {\usekomafont{sectionentrydots}{\TOCLineLeaderFill}}\relax
    \else
      \hfill
    \fi
  }%
%    \end{macrocode}
% Für die Einträge die Schrift von Element sectionentry verwenden.
%    \begin{macrocode}
  \expandafter\providecommand%
  \csname scr@tso@#1@entryformat\endcsname{\usekomafont{sectionentry}}%
  \expandafter\providecommand%
  \csname scr@tso@#1@pagenumberformat\endcsname[1]{\usekomafont{sectionentry}{\usekomafont{sectionentrypagenumber}{##1}}}%
  \expandafter\providecommand\expandafter*%
  \csname scr@tso@#1@beforeskip\endcsname{1.0em \@plus\p@}%
}
%</article>
%</section>
%    \end{macrocode}
% \end{macro}^^A \scr@dte@def@l@section
%
% \begin{macro}{\scr@dte@def@l@subsection}
% \changes{v3.20}{2015/12/07}{ToC entry style \texttt{subsection} added}
% This style exists with \cls*{scrartcl} only. It is the minor level style
% similar to the section style with \cls*{scrbook} and \cls*{scrreprt}.
%    \begin{macrocode}
%<*subsection&article>
%%%            (run: class,style,subsection)
\CloneTOCEntryStyle{tocline}{subsection}
\TOCEntryStyleStartInitCode{subsection}{%
  \expandafter\providecommand%
  \csname scr@tso@#1@linefill\endcsname{\TOCLineLeaderFill\relax}%
}
%</subsection&article>
%    \end{macrocode}
% \end{macro}^^A \scr@dte@def@l@subsection
%
% \begin{macro}{\scr@dte@def@l@default}
% \changes{v3.20}{2015/12/07}{ToC entry style \texttt{default} added}
% With classes \cls*{scrbook} and \cls*{scrreprt} this is a clone of the
% section style. With \cls*{scrartcl} this is a clone of the subsection style.
%    \begin{macrocode}
%<*default>
%%%            (run: class,style,default)
%<book|report>\CloneTOCEntryStyle{section}{default}
%<article>\CloneTOCEntryStyle{subsection}{default}
%</default>
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
%</style>
%</class>
%    \end{macrocode}
%
% \Finale
% \PrintChanges
% 
\endinput
% Local Variables:
% mode: doctex
% ispell-local-dictionary: "en_US"
% eval: (flyspell-mode 1)
% TeX-master: t
% TeX-engine: luatex-dev
% eval: (setcar (or (cl-member "Index" (setq-local TeX-command-list (copy-alist TeX-command-list)) :key #'car :test #'string-equal) (setq-local TeX-command-list (cons nil TeX-command-list))) '("Index" "mkindex %s" TeX-run-index nil t :help "makeindex for dtx"))
% End:

