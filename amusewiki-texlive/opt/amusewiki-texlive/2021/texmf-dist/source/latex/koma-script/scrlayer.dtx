% \iffalse^^A meta-comment
% ======================================================================
% scrlayer.dtx
% Copyright (c) Markus Kohm, 2012-2021
%
% This file is part of the LaTeX2e KOMA-Script bundle.
%
% This work may be distributed and/or modified under the conditions of
% the LaTeX Project Public License, version 1.3c of the license.
% The latest version of this license is in
%   http://www.latex-project.org/lppl.txt
% and version 1.3c or later is part of all distributions of LaTeX
% version 2005/12/01 and of this work.
%
% This work has the LPPL maintenance status "author-maintained".
%
% The Current Maintainer and author of this work is Markus Kohm.
%
% This work consists of all files listed in manifest.txt.
% ----------------------------------------------------------------------
% scrlayer.dtx
% Copyright (c) Markus Kohm, 2012-2021
%
% Diese Datei ist Teil der LaTeX2e KOMA-Script-Sammlung.
%
% Dieses Werk darf nach den Bedingungen der LaTeX Project Public Lizenz,
% Version 1.3c.
% Die neuste Version dieser Lizenz ist
%   http://www.latex-project.org/lppl.txt
% und Version 1.3c ist Teil aller Verteilungen von LaTeX
% Version 2005/12/01 und dieses Werks.
%
% Dieses Werk hat den LPPL-Verwaltungs-Status "author-maintained"
% (allein durch den Autor verwaltet).
%
% Der Aktuelle Verwalter und Autor dieses Werkes ist Markus Kohm.
%
% Dieses Werk besteht aus den in manifest.txt aufgefuehrten Dateien.
% ======================================================================
%
%%% From File: $Id: scrlayer.dtx 3560 2021-02-15 13:20:12Z kohm $
%<identify>%%%            (run: identify)
%<init>%%%            (run: init)
%<options>%%%            (run: options)
%<body>%%%            (run: body)
%<final>%%%            (run: final)
%<*dtx>
\ifx\ProvidesFile\undefined\def\ProvidesFile#1[#2]{}\fi
\begingroup
  \def\filedate$#1: #2-#3-#4 #5${\gdef\filedate{#2/#3/#4}}
  \filedate$Date: 2021-02-15 14:20:12 +0100 (Mon, 15 Feb 2021) $
  \def\filerevision$#1: #2 ${\gdef\filerevision{r#2}}
  \filerevision$Revision: 3560 $
  \edef\reserved@a{%
    \noexpand\endgroup
    \noexpand\ProvidesFile{scrlayer.dtx}%
                          [\filedate\space\filerevision\space
                           KOMA-Script package source
  }%
\reserved@a
%</dtx>
%<*identify|doc>
%<package>\NeedsTeXFormat{LaTeX2e}[1995/12/01]
%<package>\ProvidesPackage{scrlayer}[%
%<doc>\ProvidesFile{scrlayer.tex}[%
%!KOMAScriptVersion
%<package>  package
%</identify|doc>
%<*dtx|identify|doc>
  (defining layers and page styles)]
%</dtx|identify|doc>
%<*dtx>
\ifx\documentclass\undefined
  \input scrdocstrip.tex
  \@@input scrkernel-version.dtx
  \@@input scrstrip.inc
  \KOMAdefVariable{COPYRIGHTFROM}{2012}
  \generate{\usepreamble\defaultpreamble
    \file{scrlayer.sty}{%
      \from{scrlayer.dtx}{package,trace,scrlayer,identify}%
      \from{scrlayer.dtx}{package,trace,scrlayer,init}%
      \from{scrlayer.dtx}{package,trace,scrlayer,options}%
      \from{scrlayer.dtx}{package,trace,scrlayer,body}%
      \from{scrlayer.dtx}{package,trace,scrlayer,final}%
      \from{scrlogo.dtx}{logo}%
    }%
  }

  \batchinput{scrlayer-scrpage.dtx}
  \batchinput{scrlayer-notecolumn.dtx}
  \@@input scrstrop.inc
\else
  \let\endbatchfile\relax
\fi
\endbatchfile
  \documentclass{scrdoc}
  \addtolength{\textwidth}{-1em}
  \addtolength{\marginparwidth}{2em}
  \addtolength{\oddsidemargin}{2em}
  \usepackage[ngerman,english]{babel}
  \usepackage{url,babelbib}\bibliographystyle{babalpha-fl}
  \usepackage{listings}
  \usepackage{scrhack}
  \usepackage{etoolbox}
  \pretocmd\DescribeMacro{\ifhmode\else\bigskip\noindent\fi}{}{}
  \pretocmd\DescribeEnv{\ifhmode\else\bigskip\noindent\fi}{}{}
  \pretocmd\DescribeOption{\ifhmode\else\bigskip\noindent\fi}{}{}

  \CodelineIndex
  \RecordChanges
  \GetFileInfo{scrlayer.dtx}
  \title{The \KOMAScript{} package \texttt{scrlayer}%
    \footnote{This is version \fileversion\ of file \texttt{\filename}.}}
  \date{\filedate}
  \author{Markus Kohm}
  
  \newenvironment{Explain}{\par}{\par}
  \newcommand*{\length}{}
  \let\length\Length
  \let\endlength\endLength
  \let\Macro\cs
  \let\Length\Macro
  \let\Package\textsf
  \let\Class\Package
  \let\File\texttt
  \let\Option\texttt
  \newcommand*{\KOption}[1]{\Option{#1}\texttt{=}}
  \newcommand*{\OptionValue}[2]{\Option{#1}\texttt{=}\PValue{#2}}
  \let\Counter\texttt
  \let\Environment\texttt
  \let\ShowOutput\quote
  \let\endShowOutput\endquote
  \let\Pagestyle\texttt
  \newcommand*{\Parameter}[1]{\texttt{\marg{#1}}\linebreak[1]}
  \newcommand*{\OParameter}[1]{\texttt{\oarg{#1}}\linebreak[1]}
  \newcommand*{\MParameter}[2]{\texttt{(\meta{#1},\meta{#2})}\linebreak[1]}
  \providecommand\PParameter[1]{\mbox{\texttt{\{#1\}}}\linebreak[1]}
  \let\PName\meta
  \let\PValue\texttt
  \providecommand*{\autoref}[1]{\expandafter\AUTOREF#1:}
  \providecommand*{\AUTOREF}{}
  \makeatletter
  \def\AUTOREF#1:#2:{%
    \edef\@tempa{#1}%
    \edef\@tempb{tab}\ifx\@tempa\@tempb table~\fi
    \edef\@tempb{sec}\ifx\@tempa\@tempb section~\fi
    \ref{#1:#2}%
  }
  \providecommand*{\IndexCmd}[2][]{}
  \providecommand*{\textnote}[2][]{}
  \providecommand*\eTeX{\leavevmode\hbox{$\varepsilon$}-\TeX}
  \providecommand*\NTS{%
    \leavevmode\hbox{$\cal N\kern-0.35em\lower0.5ex\hbox{$\cal T$}%
      \kern-0.2emS$}}

  \lstnewenvironment{lstcode}{\lstset{language=[LaTeX]TeX}}{}
  \makeatother
  \sloppy% YOU SHOULD NOT DO THIS!!!

  \begin{document}
  \maketitle
  \DocInput{\filename}
  \DocInput{scrlayer-scrpage.dtx}
  \DocInput{scrlayer-notecolumn.dtx}
  \bibliography{guide}
  \PrintChanges
  \PrintIndex
  \end{document}
%</dtx>
% \fi^^A meta-comment
%
% \selectlanguage{english}
%
% \changes{v0.0}{2012/01/01}{Start of new package}%^^A
% \changes{v0.9}{2014/07/25}{User documentation removed}%^^A
%
% \StopEventually{}
%
%
% \section{Implementation of \Package{scrlayer}}
%
% This section if for developers only.
%
% \iffalse
%<*package>
%<*identify>
% \fi
%
%\iffalse^^A meta-comment
%</identify>
%</package>
%<*package|interface|class>
%\fi^^A meta-comment
%
% \subsection{Initialising some Values before the Options}
%
% \iffalse^^A meta-comment
%<*init>
% \fi^^A meta-comment
%
% Initialisation before all options.
%
% \begin{macro}{\scrlayer@@inherited@options@cslist}
% \changes{v3.33}{2021/02/15}{new (internal)}
% \begin{macro}{\scrlayer@@add@inherited@option}
% \changes{v3.33}{2021/02/15}{new (internal)}
% \begin{macro}{\scrlayer@do@inherited@options}
% \changes{v3.33}{2021/02/15}{new (interface command)}
% \begin{macro}{\scrlayer@inherit@option}
% \changes{v3.33}{2021/02/15}{new (interface command)}
% The options of \textsf{scrlayer} should be passed to \textsf{scrlayer} while
% loading an interface package. We use the comma-separated-list
% \cs{scrlayer@@inherited@options@cslist} to store all of them, so the
% interface packages are able to process them via
% \cs{scrlayer@do@inherited@options} which has an optional command, the
% \texttt{KOMA} member defined by the interface package. The default of the
% optional argument is (as usual)
% ``\texttt{.}\cs{@currname}\texttt{.}\cs{currext}''. This option is passed to
% the command, that is used a second argument, which is the first mandatory
% argument.
% Last but not least \cs{scrlayer@inherit@option} is the usual inheritance
% function. It adds a new \texttt{KOMA} option and also removes it at the end
% of the package. It should be used \emph{before} \cs{KOMAProcessOptions}. It
% has three arguments: the \texttt{KOMA} member and the option name.
%
% With this the usual execution order of an interface package would be:
% \begin{verbatim}
% \RequirePackage{scrlayer}[2021/02/15]
% \scrlayer@do@inherited@options{\scrlayer@inherit@option}
% \end{verbatim}
%    \begin{macrocode}
%<*package>
\newcommand*{\scrlayer@@inherited@options@cslist}{}
\newcommand*{\scrlayer@@add@inherited@option}[1]{%
  \ifx\scrlayer@@inherited@options@cslist\@empty
    \g@addto@macro\scrlayer@@inherited@options@cslist{#1}%
  \else
    \g@addto@macro\scrlayer@@inherited@options@cslist{,#1}%
  \fi
}  
\newcommand*{\scrlayer@do@inherited@options}[2][.\@currname.\@currext]{%
  \@for \reserved@a:=\scrlayer@@inherited@options@cslist \do {%
    \edef\reserved@a{\unexpanded{#2}{#1}{\reserved@a}}%
    \reserved@a
  }%
}
\newcommand*{\scrlayer@inherit@option}[2]{%
%<trace>  \typeout{TRACE: Define key `#2' of member `#1'}%
  \DefineFamilyMember[#1]{KOMA}%
  \expandafter\let\csname KV@KOMA#1@#2\expandafter\endcsname
                  \csname KV@KOMA.scrlayer.sty@#2\endcsname
  \expandafter\let\csname KV@KOMA#1@#2@default\expandafter\endcsname
                  \csname KV@KOMA.scrlayer.sty@#2@default\expandafter\endcsname
  \AtEndOfPackage{%
    \RelaxFamilyKey[{#1}]{KOMA}{#2}%
  }%
}
\@onlypreamble\scr@do@inherited@options
\@onlypreamble\scr@inherit@option
%</package>
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% While there are \KOMAScript{} options, we need \Package{scrkbase} to declare
% them, but the interfaces also needs \Package{scrlayer} which already
% includes \Package{scrkbase}.
%    \begin{macrocode}
%<package>\RequirePackage{scrkbase}[2013/03/05]
%<interface>\RequirePackage{scrlayer}
%    \end{macrocode}
%
%
% \begin{macro}{\scrlayer@AtEndOfPackage}
% Initial \Macro{AtEndOfPackage}, but after end of package
% \Macro{@firstofone}.
%    \begin{macrocode}
\scr@ifundefinedorrelax{scrlayer@AtEndOfPackage}{%
  \AtEndOfPackage{\let\scrlayer@AtEndOfPackage\@firstofone}%
}{%
  \ifx\scrlayer@AtEndOfPackage\@firstofone
    \AtEndOfPackage{\let\scrlayer@AtEndOfPackage\@firstofone}%
  \fi
}
\let\scrlayer@AtEndOfPackage\AtEndOfPackage
%    \end{macrocode}
% \end{macro}%^^A \sls@AtEndOfPackage
%
% \begin{macro}{\scrlayer@testunexpectedarg}
% We'll have several \KOMAScript{} options, that didn't expect an
% value. So we use this general helper to test the value and report an error
% if it is not empty (or \Macro{relax}).
%    \begin{macrocode}
%<*package>
\newcommand*{\scrlayer@testunexpectedarg}[2]{%
  \ifx\relax#2\relax\else
    \PackageError{scrlayer}{unexpected value to `#1'}{%
      Option `#1' doesn't expect any value.\MessageBreak
      If you'll continue, the value `#2' will be ignored.%
    }%
  \fi
}
%</package>
%    \end{macrocode}
% \end{macro}%^^A \scrlayer@testunexpectedarg
%
% \begin{macro}{\if@chapter}
% We need this later. But it is something general. So we initialise it as
% early as possible.
%    \begin{macrocode}
%<*package>
\scr@ifundefinedorrelax{if@chapter}{%
  \newif\if@chapter
  \scr@ifundefinedorrelax{chapter}{\@chapterfalse}{\@chaptertrue}%
}{}
%    \end{macrocode}
% \end{macro}%^^A \if@chapter
%
% \begin{macro}{\if@mainmatter}
% Some classes define \Macro{frontmatter} or \Macro{mainmatter}, but do not
% define \Macro{if@mainmatter}. But we nee some information about the matter,
% so in that case, we add it.
%    \begin{macrocode}
\scr@ifundefinedorrelax{if@mainmatter}{%
  \scr@ifundefinedorrelax{mainmatter}{%
    \newif\if@mainmatter\@mainmattertrue
  }{%
    \PackageWarningNoLine{scrlayer}{%
      \string\mainmatter\space defined without
      \string\if@mainmatter!\MessageBreak
      Note, that several packages need
      \string\if@mainmatter\space\MessageBreak
      to detect whether or no the main matter has been\MessageBreak
      entered.  So does scrlayer. Because of this\MessageBreak
      it will extend \string\mainmatter, now%
    }%
    \newif\if@mainmatter\@mainmattertrue
    \expandafter\def\expandafter\mainmatter\expandafter{%
      \expandafter\@mainmattertrue\mainmatter}%
    \scr@ifundefinedorrelax{frontmatter}{}{%
      \expandafter\def\expandafter\frontmatter\expandafter{%
        \expandafter\@mainmatterfalse\frontmatter}
    }%
    \scr@ifundefinedorrelax{backmatter}{}{%
      \expandafter\def\expandafter\backmatter{%
        \expandafter\@mainmatterfalse\backmattter}%
    }%
  }%
}{}
%</package>
%    \end{macrocode}
% \end{macro}%^^A \if@mainmatter
%
% \iffalse^^A meta-comment
%</init>
% \fi^^A meta-comment
%
%
% \subsection{Process Options}
%
% \iffalse^^A meta-comment
%<*body>
% \fi^^A meta-comment
%
% The very first thing at  the body is processing the options:
%    \begin{macrocode}
%<*package|interface>
\KOMAProcessOptions\relax
%</package|interface>
%    \end{macrocode}
%
% \subsection{Body Initialisation}
%
% Currently not needed.
%
% \iffalse
%</body>
% \fi
%
%
% \subsection{Extended Running Heads}
%
% Package \Package{scrpage2} changes and extends the running head mechanisms
% of \LaTeX{} and the classes. Most of this are basic features an therefore
% done already by \Package{scrlayer}. But not the deprecated options.
%
% \begin{option}{markcase}
% \begin{description}
% \item[\texttt{=\meta{setting}}] one of: \texttt{upper}, \texttt{lower},
% \texttt{used}, or \texttt{ignoreuppercase}.
% \end{description}\noindent
% The two options \Option{markuppercase} and \Option{markusedcase} become
% deprecated and are replace be the single option \Option{markcase}. Note,
% that interface \Package{scrlayer-scrpage} has to delay this option to
% overload case setting of option \Option{pagestyleset}.
%    \begin{macrocode}
%<*options>
\KOMA@key{markcase}{%
%<interface&scrpage>\scrlayer@AtEndOfPackage{%
  \begingroup
    \KOMA@set@ncmdkey{markcase}{reserved@a}{%
      {upper}{0},{lower}{1},{used}{2},%
      {ignoreuppercase}{3},{nouppercase}{3},%
      {ignoreupper}{3},{noupper}{3}%
    }{#1}%
    \ifx\FamilyKeyState\FamilyKeyStateProcessed
      \aftergroup\FamilyKeyStateProcessed
      \ifnum \reserved@a>\m@ne
        \aftergroup\let\aftergroup\MakeMarkcase
        \ifcase \reserved@a
          \aftergroup\MakeUppercase
          \aftergroup\scrlayer@forceignoreuppercasefalse
        \or
          \aftergroup\MakeLowercase
          \aftergroup\scrlayer@forceignoreuppercasefalse
        \or
          \aftergroup\@firstofone
          \aftergroup\scrlayer@forceignoreuppercasefalse
        \else
          \aftergroup\scrlayer@ignoreuppercase
          \aftergroup\scrlayer@forceignoreuppercasetrue
        \fi
      \fi
    \else
      \aftergroup\FamilyKeyStateUnknownValue
    \fi
  \endgroup
  \ifx\FamilyKeyState\FamilyKeyStateProcessed
    \KOMA@kav@removekey{.scrlayer.sty}{markcase}%
    \KOMA@kav@xadd{.scrlayer.sty}{markcase}{#1}%
  \fi
%<interface&scrpage>}%
}
%<package>\scrlayer@@add@inherited@option{markcase}
%</options>
%<*interface&body>
\expandafter\let
  \csname KV@KOMA.\@currname.\@currext @markcase\endcsname\relax
%</interface&body>
%    \end{macrocode}
% \begin{macro}{\MakeMarkcase}
% We use this instead of, e.g., \Macro{MakeUppercase} for every layer! So the
% name seams to be wrong, but it is common, so we use it here.
%    \begin{macrocode}
%<*package&options>
\@ifundefined{MakeMarkcase}{\let\MakeMarkcase\@firstofone}{}
\ifx\MakeMarkcase\@firstofone
  \KOMA@kav@replacevalue{.scrlayer.sty}{markcase}{used}%
\else\ifx\MakeMarkcase\MakeUppercase
    \KOMA@kav@replacevalue{.scrlayer.sty}{markcase}{upper}%
  \else\ifx\MakeMarkcase\MakeLowercase
      \KOMA@kav@replacevalue{.scrlayer.sty}{markcase}{lower}%
    \else\ifx\MakeMarkcase\scr@ignoreuppercase
        \KOMA@kav@replacevalue{.scrlayer.sty}{markcase}{ignoreuppercase}%
\fi\fi\fi\fi
%    \end{macrocode}
% \begin{macro}{\scrlayer@ignoreuppercase}
% We span a group and set \Macro{uppercase} and \Macro{MakeUppercase} to
% \Macro{@firstofone}.
%    \begin{macrocode}
\DeclareRobustCommand*{\scrlayer@ignoreuppercase}[1]{%
  \begingroup
    \let\uppercase\@firstofone
    \let\MakeUppercase\@firstofone
    \expandafter\let\csname MakeUppercase \endcsname\@firstofone
    #1%
  \endgroup
}
%    \end{macrocode}
% This is almost enough, but standard classes still would show upper-case
% letters at table of contents, list of figures, list of tables, index and
% bibliography. So we need an additional workaround.
% \begin{macro}{\ifscrlayer@forceignoreuppercase}
%    \begin{macrocode}
\newif\ifscrlayer@forceignoreuppercase
%</package&options>
%    \end{macrocode}
% \end{macro}%^^A \ifscrlayer@forceignoreuppercase
% \end{macro}%^^A \scrlayer@ignoreuppercase
% \end{macro}%^^A \MakeMarkcase
% \end{option}%^^A markcase
%
% \begin{macro}{\rightfirstmark}
% \changes{v3.16}{2015/01/14}{new}%^^A
% \begin{macro}{\rightbotmark}
% \changes{v3.16}{2015/01/14}{new}%^^A
% \begin{macro}{\righttopmark}
% \changes{v3.16}{2015/01/14}{new}%^^A
% \Macro{rightfirstmark} is simply the same like the \Macro{rightmark} of the
% \LaTeX{} kernel. \Macro{rightbotmark} uses \Macro{botmark} instead of
% \Macro{firstmark} and \Macro{righttopmark} uses \Macro{topmark}.
%    \begin{macrocode}
%<*package&body>
\newcommand*{\rightfirstmark}{\expandafter\@rightmark\firstmark\@empty\@empty}
\newcommand*{\rightbotmark}{\expandafter\@rightmark\botmark\@empty\@empty}
\newcommand*{\righttopmark}{\expandafter\@rightmark\topmark\@empty\@empty}
%    \end{macrocode}
% \end{macro}%^^A \righttopmark
% \end{macro}%^^A \rightbotmark
% \end{macro}%^^A \rightfirstmark
%
% \begin{macro}{\leftfirstmark}
% \changes{v3.16}{2015/01/14}{new}%^^A
% \begin{macro}{\leftbotmark}
% \changes{v3.16}{2015/01/14}{new}%^^A
% \begin{macro}{\lefttopmark}
% \changes{v3.16}{2015/01/14}{new}%^^A
% \Macro{leftbotmark} is simply the same like the \Macro{leftmark} of the
% \LaTeX{} kernel. \Macro{leftfirstmark} uses \Macro{firstmark} instead of
% \Macro{botmark} and \Macro{lefttopmark} uses \Macro{topmark}.
%    \begin{macrocode}
\newcommand*{\leftfirstmark}{\expandafter\@leftmark\firstmark\@empty\@empty}
\newcommand*{\leftbotmark}{\expandafter\@leftmark\botmark\@empty\@empty}
\newcommand*{\lefttopmark}{\expandafter\@leftmark\topmark\@empty\@empty}
%</package&body>
%    \end{macrocode}
% \end{macro}%^^A \lefttopmark
% \end{macro}%^^A \leftbotmark
% \end{macro}%^^A \leftfirstmark
%
% \begin{macro}{\headmark}
% Inside a page style, this macro is either \Macro{rightmark} or
% \Macro{leftmark}. Outside its \LaTeX-undefined and therefore it's not an
% interface command, but has to be undefined:
%    \begin{macrocode}
%<*package&body>
\@ifundefined{headmark}{}{%
  \PackageWarningNoLine{scrlayer}{%
    \string\headmark\space detected!\MessageBreak
    \string\headmark\space will either be set to
    \string\rightmark\MessageBreak
    or \string\leftmark inside of page styles.\MessageBreak
    This means, that \string\headmark\space will be overwritten\MessageBreak
    at every page layer usage!\MessageBreak
    Nevertheless it will stay unchanged outside\MessageBreak
    of page layers.\MessageBreak
    I hope, this won't break your document%
  }%
}
%</package&body>
%    \end{macrocode}
% \end{macro}%^^A \headmark
%
% \begin{macro}{\pagemark}
% The page number together with its font setting. It's robust and will never
% be part of the interface.
%    \begin{macrocode}
%<*package&body>
\@ifundefined{pagemark}{%
  \DeclareRobustCommand\pagemark{{\pnumfont{\thepage}}}%
}{}%
%    \end{macrocode}
% \begin{macro}{\pnumfont}
% \begin{macro}{\scr@fnt@pagenumber}
% The low-level page number font command. It is deprecated to redefine or use
% this and it may already be defined. These commands will not become part of
% the interface!
%    \begin{macrocode}
\@ifundefined{pnumfont}{%
  \newcommand{\pnumfont}{\normalfont}%
}{}
\@ifundefined{scr@fnt@pagenumber}{%
  \newcommand{\scr@fnt@pagenumber}{\pnumfont}%
}{}
%</package&body>
%    \end{macrocode}
% \end{macro}%^^A \scr@fnt@pagenumber
% \end{macro}%^^A \pnumfont
% \end{macro}%^^A \pagemark
%
% \begin{macro}{\partmarkformat}
% \begin{macro}{\chaptermarkformat}
% \begin{macro}{\sectionmarkformat}
% \begin{macro}{\GenericMarkFormat}
% All the \Macro{\dots markformat} macros of \KOMAScript{} are also
% supported by \Package{scrlayer} and it uses them actively. The generic
% definition has been moved from \Macro{@seccntmarkformat} to
% \Macro{GenericMarkFormat}. This is one more difference to
% \Package{scrpage2}. The defaults are compatible to the standard
% classes. These commands will not become part of the interface and other
% interfaces should redefine them only, if they are not already defined.
%    \begin{macrocode}
%<*package&body>
\providecommand*{\partmarkformat}{\partname\ \thepart. \ }%
\if@chapter
  \providecommand*{\@chapapp}{\chaptername}%
  \providecommand*{\chaptermarkformat}{\@chapapp\ \thechapter. \ }%
  \providecommand*{\sectionmarkformat}{\thesection. \ }%
\else
  \providecommand*{\sectionmarkformat}{\GenericMarkFormat{section}}%
\fi
\scr@ifundefinedorrelax{@seccntmarkformat}{%
  \providecommand*{\GenericMarkFormat}{\@seccntformat}%
}{%
  \providecommand*{\GenericMarkFormat}[1]{\@seccntmarkformat{#1}}%
}
%</package&body>
%    \end{macrocode}
% Note, that the other \Macro{\dots markformat} will be defined by
% \Macro{scrlayer@level@init}.
% \end{macro}%^^A \GenericMarkFormat
% \end{macro}%^^A \sectionmarkformat
% \end{macro}%^^A \chaptermarkformat
% \end{macro}%^^A \partmarkformat
%
% \begin{macro}{\@mkleft}
% \changes{v3.25}{2017/10/13}{added to the \KOMAScript{} classes}%^^A
% \begin{macro}{\@mkright}
% \changes{v3.25}{2017/10/13}{added to the \KOMAScript{} classes}%^^A
% \begin{macro}{\@mkdouble}
% \changes{v3.25}{2017/10/13}{added to the \KOMAScript{} classes}%^^A
% \changes{v3.27a}{2019/10/17}{long definition}%^^A
% These are new in \Package{scrlayer}. They may be updated, whenever
% \Macro{@mkboth} will be updated. Otherwise they get a working default
% definition. These commands will not become part of the interface and other
% interfaces should redefine them only, if they are not already defined.
%    \begin{macrocode}
%<*(package|class)&body>
\providecommand*{\@mkleft}{%
  \IfActiveMkBoth{\markleft}{\@gobble}%
}%
\providecommand*{\@mkright}{%
  \IfActiveMkBoth{\markright}{\@gobble}%
}%
\providecommand{\@mkdouble}[1]{%
  \@mkboth{#1}{#1}%
}
%</(package|class)&body>
%    \end{macrocode}
% \end{macro}%^^A \@mkdouble
% \end{macro}%^^A \@mkright
% \end{macro}%^^A \@mkleft
%
% \begin{macro}{\markleft}
% \changes{v3.27a}{2019/10/17}{robust and long definition}%^^A
% \begin{macro}{\@markleft}
% \LaTeX{} itself provides \Macro{markboth} and \Macro{markright} but not
% \Macro{markleft}. So we add it.
%    \begin{macrocode}
%<*package&body>
\@ifundefined{markleft}{%
  \DeclareRobustCommand{\markleft}[1]{%
    \begingroup
      \let\label\relax \let\index\relax \let\glossary\relax
      \expandafter\@markleft\@themark {#1}%
      \@temptokena \expandafter{\@themark}%
      \mark{\the\@temptokena}%
    \endgroup
    \if@nobreak\ifvmode\nobreak\fi\fi
  }%
  \providecommand{\@markleft}[3]{%
    \@temptokena {#2}%
    \unrestored@protected@xdef\@themark{{#3}{\the\@temptokena}}%
  }%
}{}
%</package&body>
%    \end{macrocode}
% \end{macro}%^^A \@markleft
% \end{macro}%^^A \markleft
%
% \begin{macro}{\markdouble}
% \changes{v3.28}{2019/10/17}{new}%^^A
% This is easier, because it uses \cs{markboth}. So we do not need to declare
% it robust and we can use \cs{providecommand}.
%    \begin{macrocode}
%<*package&body>
\providecommand{\markdouble}[1]{\markboth{#1}{#1}}
%</package&body>
%    \end{macrocode}
% \end{macro}%^^A \markdouble
%
% \begin{option}{autooneside}
% \begin{macro}{\ifscrlayer@autooneside}
% Decide whether or not use the optional argument of \Macro{automark} in
% single-side layout.
%    \begin{macrocode}
%<*options>
%<*package>
\KOMA@ifkey{autooneside}{scrlayer@autooneside}\scrlayer@autoonesidetrue
\scrlayer@@add@inherited@option{autooneside}
\KOMA@kav@replacebool{.scrlayer.sty}{autooneside}{scrlayer@autooneside}
%</package>
%<*interface>
\KOMA@key{autooneside}[true]{%
  \KOMA@set@ifkey{autooneside}{scrlayer@autooneside}{#1}%
  \KOMA@kav@replacebool{.scrlayer.sty}{autooneside}{scrlayer@autooneside}%
}
%</interface>
%</options>
%<*interface&body>
\expandafter\let
  \csname KV@KOMA.\@currname.\@currext @autooneside\endcsname\relax
%</interface&body>
%    \end{macrocode}
% \end{macro}%^^A \ifscrlayer@autooneside
% \end{option}%^^A autooneside
%
%
% \begin{option}{automark}
% \begin{option}{manualmark}
% Maybe we will extend these options later. Currently they do almost the
% same they do at \Package{scrpage2}. The difference is, that single-side or
% two-side doesn't matter here (but it does inside of the definitions of the
% marks itself).
%
% ToDo: Maybe \Option{manualmark} should become deprecated and
% \Option{automark} should have simple values or a new option, that also
% handles \Option{autooneside}?
% \changes{v3.22}{2016/12/07}{prepared for classes without \cs{section} or
%     \cs{subsection}}%^^A
%    \begin{macrocode}
%<*options>
\KOMA@key{automark}[]{%
  \scrlayer@testunexpectedarg{automark}{#1}%
  \scrlayer@AtEndOfPackage{%
    \if@chapter
      \scr@ifundefinedorrelax{section}{%
        \automark{chapter}%
      }{%
        \automark[section]{chapter}%
      }%
    \else
      \scr@ifundefinedorrelax{section}{%
        \automark{}%
      }{%
        \scr@ifundefinedorrelax{subsection}{%
          \automark{section}%
        }{%
          \automark[subsection]{section}%
        }
      }%
    \fi
  }%
  \FamilyKeyStateProcessed
  \KOMA@kav@removekey{.scrlayer.sty}{automark}%
  \KOMA@kav@removekey{.scrlayer.sty}{manualmark}%
  \KOMA@kav@add{.scrlayer.sty}{automark}{}%
}
%<package>\scrlayer@@add@inherited@option{automark}
%</options>
%<*interface&body>
\expandafter\let\csname KV@KOMA.\@currname.\@currext @automark\endcsname\relax
\expandafter\let
  \csname KV@KOMA.\@currname.\@currext @automark@default\endcsname\relax
%</interface&body>
%<*options>
\KOMA@key{manualmark}[]{%
  \scrlayer@testunexpectedarg{manualmark}{#1}%
  \scrlayer@AtEndOfPackage{\manualmark}%
  \FamilyKeyStateProcessed
  \KOMA@kav@removekey{.scrlayer.sty}{automark}%
  \KOMA@kav@removekey{.scrlayer.sty}{manualmark}%
  \KOMA@kav@add{.scrlayer.sty}{manualmark}{}%
}
%<package>\scrlayer@@add@inherited@option{manualmark}
%</options>
%<*interface&body>
\expandafter\let\csname KV@KOMA.\@currname.\@currext @manualmark\endcsname\relax
\expandafter\let
  \csname KV@KOMA.\@currname.\@currext @manualmark@default\endcsname\relax
%</interface&body>
%    \end{macrocode}
% \end{option}%^^A manualmark
% \end{option}%^^A automark
%
% \begin{macro}{\manualmark}
% Switch to manual marks. This resets \Macro{@mkleft}, \Macro{@mkright},
% \Macro{@mkdouble}, \Macro{@mkboth} and the \Macro{\dots mark} of all known
% levels.
%    \begin{macrocode}
%<*package&body>
\newcommand*{\manualmark}{%
  \begingroup
    \def\@elt##1{%
      \aftergroup\let\expandafter\aftergroup\csname ##1mark\endcsname
      \aftergroup\@gobble
    }%
    \scrlayer@level@list
  \endgroup
  \let\@mkleft\@gobble
  \let\@mkright\@gobble
  \let\@mkdouble\@gobble
  \let\@mkboth\@gobbletwo
}
%</package&body>
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\automark}
% \changes{v3.20}{2016/04/12}{\cs{@ifstar} durch \cs{kernel@ifstar}
%   ersetzt}%^^A
% \begin{macro}{\@automark}
% \changes{v3.28}{2019/11/18}{\cs{ifstr} umbenannt in \cs{Ifstr}}%^^A
% This is the brain knot of the game! I'll try to explain, what I'm doing:
% First of all the new starred version of \Macro{automark} doesn't reset the
% mark commands. So it works cumulatively. This may be useful e.g. to have
% chapter marks as long as no section marks have been made etc.
%    \begin{macrocode}
%<*package&body>
\newcommand*{\automark}{%
  \kernel@ifstar{\@automark}{\manualmark\@automark}%
}
\newcommand*{\@automark}[2][]{%
  \Ifstr{#2}{}{%
    \Ifstr{#1}{}{%
%    \end{macrocode}
% \Macro{automark[]{}} or \Macro{automark{}} has been used. This will activate
% the low level mark commands, but doesn't change the high level commands. It
% may be useful or may not, the user should know what he does:
%    \begin{macrocode}
      \automark@basics
    }{%
%    \end{macrocode}
% \Macro{automark[\dots]{}} has been used. This will activate the higher level
% mark commands and also set up the right mark
%    \begin{macrocode}
      \automark@basics
      \automark@righthigh{#1}%
    }%
  }{%
    \Ifstr{#1}{}{%
%    \end{macrocode}
% \Macro{automark[]{\dots}} or \Macro{automark{\dots}} has been used. This
% will activate the low level mark commands and also set up either the left or
% both marks.
%    \begin{macrocode}
      \automark@basics
      \automark@leftlow{#2}%
    }{%
%    \end{macrocode}
% \Macro{automark[\dots]{\dots}} has been used. This will activate the low
% level mark commands and also both high level marks.
%    \begin{macrocode}
      \automark@basics
      \automark@both{#1}{#2}%
    }%
  }%
}
%    \end{macrocode}
% \begin{macro}{\automark@basics}
% Activate all low level \Macro{@mk\dots} commands:
%    \begin{macrocode}
\newcommand*{\automark@basics}{%
  \let\@mkleft\markleft
  \let\@mkright\markright
  \let\@mkboth\markboth
  \def\@mkdouble##1{\@mkboth{##1}{##1}}%
}
%    \end{macrocode}
% \end{macro}%^^A \automark@basics
% \begin{macro}{\automark@righthigh}
% Set up the right mark of a higher level, but in single-side layout only if
% \Option{autooneside} hasn't been used. Note, that with this definition no
% special handling for \KOMAScript's \Macro{addchap} and \Macro{addsec} is
% needed.
%    \begin{macrocode}
\newcommand*{\automark@righthigh}[1]{%
  \ifscrlayer@level@prepared{#1}{%
    \expandafter\def\csname #1mark\endcsname##1{%
      \begingroup
        \@tempswafalse
        \if@twoside\@tempswatrue
        \else\ifscrlayer@autooneside\else\@tempswatrue\fi\fi
      \expandafter\endgroup
      \if@tempswa
        \@mkright{%
          \MakeMarkcase{%
            \ifnum \c@secnumdepth<\numexpr \csname #1numdepth\endcsname +0\relax
            \else\if@mainmatter \csname #1markformat\endcsname\fi\fi
            ##1%
          }%
        }%
      \fi
    }%
  }{}%
}
%    \end{macrocode}
% \end{macro}%^^A \automark@righthigh
% \begin{macro}{\automark@leftlow}
% Set up the left mark of a low level, but in single-side layout the right
% mark has to be used.
%    \begin{macrocode}
\newcommand*{\automark@leftlow}[1]{%
  \ifscrlayer@level@prepared{#1}{%
    \expandafter\def\csname #1mark\endcsname ##1{%
      \if@twoside
%    \end{macrocode}
% In two-side mode the left high mark has also to clear the right low
% mark. This would be unwanted, if the left mark is a low mark and the right
% mark is a high mark. But we cannot detect this if no right mark level has
% been given. So we simply use:
%    \begin{macrocode}
        \expandafter\@mkboth
      \else
%    \end{macrocode}
% In single-side mode there's no left high mark without a right low mark. So
% instead of only a left high mark, we set up both marks.
% \changes{v3.27}{2019/07/25}{replaced \cs{@empty} by \texttt{\{\}} to avoid
%   \textsf{babel} issue}%^^A
%    \begin{macrocode}
        \expandafter\@mkdouble
      \fi
      {%
        \MakeMarkcase{%
          \ifnum \c@secnumdepth<\numexpr \csname #1numdepth\endcsname +0\relax
          \else\if@mainmatter \csname #1markformat\endcsname\fi\fi
          ##1%
        }%
      }{}%
    }%
  }{}%
}
%    \end{macrocode}
% \end{macro}%^^A \automark@leftlow
% \begin{macro}{\automark@both}
% Set up both marks, but in single-side layout depending on
% \Option{autooneside}.
%    \begin{macrocode}
\newcommand*{\automark@both}[2]{%
  \ifscrlayer@level@prepared{#1}{%
    \ifscrlayer@level@prepared{#2}{%
      \ifnum \numexpr \csname #1numdepth\endcsname +0\relax
           > \numexpr \csname #2numdepth\endcsname +0\relax
%    \end{macrocode}
% Level of left mark is greater than level of right mark. e.g., section >
% chapter. This is unusual. Nevertheless we'll handle it.
%    \begin{macrocode}
          \automark@leftlow{#2}%
          \automark@righthigh{#1}%
      \else \ifnum \numexpr \csname #1numdepth\endcsname +0\relax
                 = \numexpr \csname #2numdepth\endcsname +0\relax
%    \end{macrocode}
% Level of left mark is equal to level of right mark. This is
% nice and very easy to handle.
%    \begin{macrocode}
          \expandafter\def\csname #2mark\endcsname##1{%
            \@mkdouble{%
              \MakeMarkcase{%
                \ifnum \c@secnumdepth<\numexpr 
                  \csname #2numdepth\endcsname +0\relax
                \else
                  \if@mainmatter \csname #2markformat\endcsname\fi
                \fi
                ##1%
              }%
            }%
          }%
        \else
%    \end{macrocode}
% Level of left mark is less than level of right mark. This is
% usual.
%    \begin{macrocode}
          \expandafter\def\csname #1mark\endcsname##1{%
            \begingroup
              \@tempswafalse
              \if@twoside\@tempswatrue
              \else\ifscrlayer@autooneside\else\@tempswatrue\fi\fi
            \expandafter\endgroup
            \if@tempswa
              \@mkleft{%
                \MakeMarkcase{%
                  \ifnum \c@secnumdepth
                       < \numexpr\csname #1numdepth\endcsname +0\relax
                  \else
                    \if@mainmatter \csname #1markformat\endcsname\fi
                  \fi
                  ##1%
                }%
              }%
            \fi
          }%
          \expandafter\def\csname #2mark\endcsname##1{%
            \@mkboth{}{%
              \MakeMarkcase{%
                \ifnum \c@secnumdepth
                     < \numexpr \csname #2numdepth\endcsname +0\relax
                \else\if@mainmatter \csname #2markformat\endcsname\fi\fi
                ##1%
              }%
            }%
          }%
        \fi
      \fi
    }{}%
  }{}%
}
%    \end{macrocode}
% \begin{macro}{\ifscrlayer@level@prepared}
% Test, whether or not this level has been prepared.
%    \begin{macrocode}
\newcommand*{\ifscrlayer@level@prepared}[1]{%
  \typeout{1: \detokenize{#1}}%
  \scr@ifundefinedorrelax{#1numdepth}{%
    \PackageError{scrlayer}{numbering depth of `#1' unknown}{%
      Someone told me to use a section mark for level `#1',\MessageBreak
      but the numbering depth hasn't been declared before. You may solve this
      using\MessageBreak
      \string\DeclareSectionNumberDepth{#1}{NUMBER}.%
    }%
    \@secondoftwo
  }{%
    \@firstoftwo
  }%
}
%</package&body>
%    \end{macrocode}
% \end{macro}%^^A \ifscrlayer@level@prepared
% \end{macro}%^^A \automark@both
% \end{macro}%^^A \@automark
% \end{macro}%^^A \automark
%
% \begin{macro}{\DeclareSectionNumberDepth}
% \changes{v3.28}{2019/11/18}{\cs{ifstr} umbenannt in \cs{Ifstr}}%^^A
%   \begin{description}
%   \item[\Parameter{string}:] the name of the section level, e.g.,
%     part, chapter, section etc. (must be fully
%     expandable and expand to a string).
%   \item[\Parameter{numeric expression}:] the section number depth of the
%   level, e.g., -1 for part, 0 for chapter etc.
%   \end{description}
% Note that levels part, chapter, section, subsection, sub\dots subsection,
% paragraph, subparagraph, sub\dots subparagraph, minisec, subminisec,
% sub\dots subminisec will be recognised either at load time or at
% \Macro{begin}\PParameter{document} automatically if they have the usual
% levels.
%    \begin{macrocode}
%<*package&body>
\newcommand*{\DeclareSectionNumberDepth}[2]{%
  \expandafter\edef\csname #1numdepth\endcsname{\the\numexpr #2\relax}%
  \@ifundefined{#1mark}{%
    \expandafter\let\csname #1mark\endcsname\@gobble
  }{}%
  \@ifundefined{#1markformat}{%
    \@namedef{#1markformat}{\GenericMarkFormat{#1}}%
  }{}%
  \begingroup
    \@tempswatrue
    \def\@elt##1{\Ifstr{#1}{##1}{\@tempswafalse}{}}%
    \scrlayer@level@list
    \if@tempswa
      \aftergroup\@firstofone
    \else
      \aftergroup\@gobble
    \fi
  \endgroup
  {%
    \l@addto@macro\scrlayer@level@list{\@elt{#1}}%
  }%
}
%    \end{macrocode}
% \begin{macro}{\scrlayer@level@list}
% \begin{macro}{\scrlayer@level@init}
% Stores all the existing levels.
%    \begin{macrocode}
\newcommand*{\scrlayer@level@list}{}
%    \end{macrocode}
% Usually all levels are known on loading this package, but if a package
% defines additional levels later we'll do an additional test at
% \Macro{begin}\PParameter{document}. But we do not redo the part and the
% chapter test.
%    \begin{macrocode}
\scr@ifundefinedorrelax{part}{}{%
  \DeclareSectionNumberDepth{part}{-1}%
}
\if@chapter
  \DeclareSectionNumberDepth{chapter}{0}%
\fi
\newcommand*{\scrlayer@level@init}{%
  \@tempcnta=1
  \def\reserved@b##1{%
    \@tempswatrue
    \def\reserved@a{##1}%
    \@whilesw \if@tempswa \fi {%
      \scr@ifundefinedorrelax{\reserved@a}{%
        \@tempswafalse
      }{%
        \@ifundefined{\reserved@a numdepth}{%
          \expandafter\DeclareSectionNumberDepth
          \expandafter{\reserved@a}{\@tempcnta}%
        }{%
          \expandafter\DeclareSectionNumberDepth
          \expandafter{\reserved@a}{\csname \reserved@a numdepth\endcsname}%
        }%
        \advance \@tempcnta by \@ne
        \edef\reserved@a{sub\reserved@a}%
      }%
    }%
  }%
  \reserved@b{section}%
  \reserved@b{paragraph}%
  \reserved@b{minisec}%
}
\scrlayer@level@init
\AtBeginDocument{%
  \scrlayer@level@init
}
%</package&body>
%    \end{macrocode}
% \end{macro}%^^A \scrlayer@level@init
% \end{macro}%^^A \scrlayer@level@list
% \end{macro}%^^A DeclareSectionNumberDepth
%
%
% \subsection{Providing Layers}
%
% A layer is a virtual sheet of paper stacked behind or above the real sheet
% of paper. All the virtual and real sheets of one page may been seen
% simultanous, but material o one sheet may overlap material on sheets below.
% Layers provided by \Package{scrlayer} will not be stacked below or above
% real sheets unless they are used by a page style.
%
% While we use \meta{key}\texttt{=}\meta{value} arguments for several of the
% layer commands we define a new family with a new member:
%    \begin{macrocode}
%<*package&body>
\DefineFamily{KOMAarg}
\DefineFamilyMember[.definelayer]{KOMAarg}
%</package&body>
%    \end{macrocode}
%
% \begin{macro}{\DeclareLayer}
%   \begin{description}
%   \item[\OParameter{option list}:] a comma separated list of
%     \texttt{\meta{key}=\meta{value}} pairs.
%   \item[\Parameter{string}:] the name of the layer (must be fully expandable
%     and expand to a string only).
%   \end{description}
% Layers are the basic elements of page styles. A layer has a name and several
% attributes. The attributes may be set as comma separated list at the first,
% optional argument of \cs{DeclareLayer}. The name must be set by the second,
% mandatory argument.
% \begin{macro}{\def@scr@l@pos}
% And a second helper macro to easily define $x, y, w, h$ of a layer.
%    \begin{macrocode}
%<*package&body>
\newcommand*{\def@scr@l@pos}[4]{%
  \@namedef{scr@l@\scr@current@layer @x}{#1}%
  \@namedef{scr@l@\scr@current@layer @y}{#2}%
  \@namedef{scr@l@\scr@current@layer @w}{#3}%
  \@namedef{scr@l@\scr@current@layer @h}{#4}%
}
%    \end{macrocode}
% \end{macro}%^^A \def@scr@l@pos
%
% There are basic, primitive attributes and compounding attributes. The basic
% attributes are:
% \begin{description}
% \item[\texttt{mode=\meta{command sequence}}:] the mode that should be used
%   to output the \texttt{contents}. A command \cs{layer\meta{command
%   sequence}mode} with one argument need to be defined.
% \changes{v3.19}{2015/07/30}{new layer attribute \texttt{mode}}%^^A
%    \begin{macrocode}
\DefineFamilyKey[.definelayer]{KOMAarg}{mode}{%
  \scr@ifundefinedorrelax{layer#1mode}{\FamilyKeyStateUnknownValue}{%
    \@namedef{scr@l@\scr@current@layer @mode}{#1}%
    \FamilyKeyStateProcessed
  }%
}
%    \end{macrocode}
% \item[\texttt{hoffset=\meta{dimension expression}}:] offset from the left
%   edge of the paper.
%    \begin{macrocode}
\DefineFamilyKey[.definelayer]{KOMAarg}{hoffset}{%
  \@namedef{scr@l@\scr@current@layer @x}{\dimexpr #1\relax}%
  \FamilyKeyStateProcessed
}
%    \end{macrocode}
% \item[\texttt{voffset=\meta{dimension expression}}:] offset from the top
%   edge of the paper.
%    \begin{macrocode}
\DefineFamilyKey[.definelayer]{KOMAarg}{voffset}{%
  \@namedef{scr@l@\scr@current@layer @y}{\dimexpr #1\relax}%
  \FamilyKeyStateProcessed
}
%    \end{macrocode}
% \item[\texttt{width=\meta{dimension expression}}:] width of the layer.
%    \begin{macrocode}
\DefineFamilyKey[.definelayer]{KOMAarg}{width}{%
  \@namedef{scr@l@\scr@current@layer @w}{\dimexpr #1\relax}%
  \FamilyKeyStateProcessed
}
%    \end{macrocode}
% \item[\texttt{height=\meta{dimension expression}}:] height of the layer.
%    \begin{macrocode}
\DefineFamilyKey[.definelayer]{KOMAarg}{height}{%
  \@namedef{scr@l@\scr@current@layer @h}{\dimexpr #1\relax}%
  \FamilyKeyStateProcessed
}
%    \end{macrocode}
% \item[\texttt{align=\meta{specification}}:] horizontal and vertical
%   alignment of the layer. The \meta{specification} will interpreted
%   character by character with the following valid characters:
%   \begin{itemize}
%   \item[l] -- align the layer with its left edge to the given horizontal
%     offset. This means, that the layer's width will span right from the
%     given horizontal offset.
%   \item[r] -- align the layer with its right edge to the given horizontal
%     offset. This means, that the layer's width will span left from the given
%     horizontal offset.
%   \item[c] -- align the layer centered to the given horizontal and vertical
%     offset. This means, that the given offsets are at the middle of the
%     layer width and total height.
%   \item[t] -- align the layer with its top edge to the given vertical
%     offset. This means that the layer's contents will span below the given
%     vertical offset.
%   \item[b] -- align the layer with its bottom edge to the given vertical
%     offset. This means, that the layer's contents will span above the given
%     vertical offset.
%   \end{itemize}
%    \begin{macrocode}
\DefineFamilyKey[.definelayer]{KOMAarg}{align}{%
  \@namedef{scr@l@\scr@current@layer @align}{#1}%
  \FamilyKeyStateProcessed
}
%    \end{macrocode}
% \item[\texttt{contents=\meta{output}}:] whatever should be printed by the
%   layer.
% \changes{v3.14}{2014/10/20}{\texttt{contents} is \cs{long}}%^^A
%    \begin{macrocode}
\DefineFamilyKey[.definelayer]{KOMAarg}{contents}{%
  \long\@namedef{scr@l@\scr@current@layer @contents}{#1}%
  \FamilyKeyStateProcessed
}
%    \end{macrocode}
% \item[\texttt{background}:] restrict the layer to the page
%   background. This means, that the main contents of the page may overprint
%   the contents of the layer. Note, that this attribute has no value!
%    \begin{macrocode}
\DefineFamilyKey[.definelayer]{KOMAarg}{background}[\relax]{%
  \FamilyKeyStateProcessed
  \scrlayer@testunexpectedarg{background}{#1}%
  \csname @scr@l@\scr@current@layer @backgroundtrue\endcsname
  \csname @scr@l@\scr@current@layer @foregroundfalse\endcsname
}
%    \end{macrocode}
% \item[\texttt{foreground}:] restrict the layer to the page
%   foreground. This means, that the layer's contents may overprint the main
%   contents of the page. Note, that this attribute has no value!
%    \begin{macrocode}
\DefineFamilyKey[.definelayer]{KOMAarg}{foreground}[\relax]{%
  \FamilyKeyStateProcessed
  \scrlayer@testunexpectedarg{foreground}{#1}%
  \csname @scr@l@\scr@current@layer @backgroundfalse\endcsname
  \csname @scr@l@\scr@current@layer @foregroundtrue\endcsname
}
%    \end{macrocode}
% \item[\texttt{backandforeground}:] not really useful, but the counterpart of
%   the restrictions above.
% \changes{v3.18}{2015/05/14}{new layer feature \texttt{backandforeground}}%^^A
%    \begin{macrocode}
\DefineFamilyKey[.definelayer]{KOMAarg}{backandforeground}[\relax]{%
  \FamilyKeyStateProcessed
  \scrlayer@testunexpectedarg{backandforeground}{#1}%
  \csname @scr@l@\scr@current@layer @backgroundtrue\endcsname
  \csname @scr@l@\scr@current@layer @foregroundtrue\endcsname
}
%    \end{macrocode}
% \item[\texttt{oddpage}:] restrict the layer to odd pages only. At
%   two-sided layout only pages with odd page numbers are odd pages. At
%   single-sided layout all pages are odd pages. Note, that this attribute has
%   no value!
%    \begin{macrocode}
\DefineFamilyKey[.definelayer]{KOMAarg}{oddpage}[\relax]{%
  \FamilyKeyStateProcessed
  \scrlayer@testunexpectedarg{oddpage}{#1}%
  \csname @scr@l@\scr@current@layer @oddtrue\endcsname
  \csname @scr@l@\scr@current@layer @evenfalse\endcsname
}
%    \end{macrocode}
% \item[\texttt{evenpage}:] restrict the layer to even pages only. At
%   two-sided layout only pages with even page numbers are even pages. At
%   single-sided layout there aren't even pages. Note, that this attribute has
%   no value!
%    \begin{macrocode}
\DefineFamilyKey[.definelayer]{KOMAarg}{evenpage}[\relax]{%
  \FamilyKeyStateProcessed
  \scrlayer@testunexpectedarg{evenpage}{#1}%
  \csname @scr@l@\scr@current@layer @oddfalse\endcsname
  \csname @scr@l@\scr@current@layer @eventrue\endcsname
}
%    \end{macrocode}
% \item[\texttt{oddorevenpage}:] do not restrict the layer to odd or even
% pages.
% \changes{v3.18}{2015/05/14}{new layer feature \texttt{oddorevenpage}}
%    \begin{macrocode}
\DefineFamilyKey[.definelayer]{KOMAarg}{oddorevenpage}[\relax]{%
  \FamilyKeyStateProcessed
  \scrlayer@testunexpectedarg{oddorevenpage}{#1}%
  \csname @scr@l@\scr@current@layer @oddtrue\endcsname
  \csname @scr@l@\scr@current@layer @eventrue\endcsname
}
%    \end{macrocode}
% \item[\texttt{evenoroddpage}:] same as \texttt{oddorevenpage}
%    \begin{macrocode}
\DefineFamilyKey[.definelayer]{KOMAarg}{evenoroddpage}[\relax]{%
  \PackageWarning{scrlayer}{Option `evenoroddpage' unknown.\MessageBreak
    Using `oddorevenpage' instead}%
  \ExecuteFamilyOptions[.definelayer]{KOMAarg}{oddorevenpage=#1}
}
%    \end{macrocode}
% \item[\texttt{oddandevenpages}:] same as \texttt{oddorevenpage}
%    \begin{macrocode}
\DefineFamilyKey[.definelayer]{KOMAarg}{oddandevenpages}[\relax]{%
  \PackageWarning{scrlayer}{Option `oddandevenpages' unknown.\MessageBreak
    Using `oddorevenpage' instead}%
  \ExecuteFamilyOptions[.definelayer]{KOMAarg}{oddorevenpage=#1}
}
%    \end{macrocode}
% \item[\texttt{evenandoddpages}:] same as \texttt{oddorevenpage}
%    \begin{macrocode}
\DefineFamilyKey[.definelayer]{KOMAarg}{evenandoddpages}[\relax]{%
  \PackageWarning{scrlayer}{Option `evenandoddpages' unknown.\MessageBreak
    Using `oddorevenpage' instead}%
  \ExecuteFamilyOptions[.definelayer]{KOMAarg}{oddorevenpage=#1}
}
%    \end{macrocode}
% \item[\Option{floatpage}:] restrict the layer to float pages.
%    \begin{macrocode}
\DefineFamilyKey[.definelayer]{KOMAarg}{floatpage}[\relax]{%
  \FamilyKeyStateProcessed
  \scrlayer@testunexpectedarg{floatpage}{#1}%
  \csname @scr@l@\scr@current@layer @nonfloatpagefalse\endcsname
  \csname @scr@l@\scr@current@layer @floatpagetrue\endcsname
}
%    \end{macrocode}
% \item[\Option{nonfloatpage}:] restrict the layer to pages, which aren't
%   float pages.
%    \begin{macrocode}
\DefineFamilyKey[.definelayer]{KOMAarg}{nonfloatpage}[\relax]{%
  \FamilyKeyStateProcessed
  \scrlayer@testunexpectedarg{nonfloatpage}{#1}%
  \csname @scr@l@\scr@current@layer @nonfloatpagetrue\endcsname
  \csname @scr@l@\scr@current@layer @floatpagefalse\endcsname
}
%    \end{macrocode}
% \item[\Option{floatornonfloatpage}:] don't restrict the layer to float or
% non-float pages.
% \changes{v3.18}{2015/05/14}{new layer feature \texttt{floatornonfloatpage}}
%    \begin{macrocode}
\DefineFamilyKey[.definelayer]{KOMAarg}{floatornonfloatpage}[\relax]{%
  \FamilyKeyStateProcessed
  \scrlayer@testunexpectedarg{floatornonfloatpage}{#1}%
  \csname @scr@l@\scr@current@layer @nonfloatpagetrue\endcsname
  \csname @scr@l@\scr@current@layer @floatpagetrue\endcsname
}
%    \end{macrocode}
% \item[\Option{nonfloatorfloatpage}:] same as \Option{floatornonfloatpage}
%    \begin{macrocode}
\DefineFamilyKey[.definelayer]{KOMAarg}{nonfloatorfloatpage}[\relax]{%
  \PackageWarning{scrlayer}{Option `nonfloatorfloatpage' unknown.\MessageBreak
    Using `floatornonfloatpage' instead}%
  \FamilyExecuteOptions[.definelayer]{KOMAarg}{floatornonfloatpage=#1}%
}
%    \end{macrocode}
% \item[\Option{floatandnonfloatpages}:] same as \Option{floatornonfloatpage}
%    \begin{macrocode}
\DefineFamilyKey[.definelayer]{KOMAarg}{floatandnonfloatpages}[\relax]{%
  \PackageWarning{scrlayer}{Option `floatandnonfloatpages' unknown.\MessageBreak
    Using `floatornonfloatpage' instead}%
  \FamilyExecuteOptions[.definelayer]{KOMAarg}{floatornonfloatpage=#1}%
}
%    \end{macrocode}
% \item[\Option{nonfloatandfloatpages}:] same as \Option{floatornonfloatpage}
%    \begin{macrocode}
\DefineFamilyKey[.definelayer]{KOMAarg}{nonfloatandfloatpages}[\relax]{%
  \PackageWarning{scrlayer}{Option `nonfloatandfloatpages' unknown.\MessageBreak
    Using `floatornonfloatpage' instead}%
  \FamilyExecuteOptions[.definelayer]{KOMAarg}{floatornonfloatpage=#1}%
}
%    \end{macrocode}
% \item[\Option{everypage}:] remove all odd-, even-, float-, and
%   nonfloat-restrictions.
% \changes{v3.18}{2015/05/14}{new layer feature \texttt{everypage}}%^^A
% \changes{v3.22}{2016/09/24}{foreground and background condition
%   removed}%^^A
%    \begin{macrocode}
\DefineFamilyKey[.definelayer]{KOMAarg}{everypage}[\relax]{%
  \FamilyKeyStateProcessed
  \scrlayer@testunexpectedarg{everypage}{#1}%
  \csname @scr@l@\scr@current@layer @oddtrue\endcsname
  \csname @scr@l@\scr@current@layer @eventrue\endcsname
  \csname @scr@l@\scr@current@layer @nonfloatpagetrue\endcsname
  \csname @scr@l@\scr@current@layer @floatpagetrue\endcsname
}
%    \end{macrocode}
% \item[\Option{oneside}:] restrict the layer to pages on single-sided
%   layouts.
%    \begin{macrocode}
\DefineFamilyKey[.definelayer]{KOMAarg}{oneside}[\relax]{%
  \FamilyKeyStateProcessed
  \scrlayer@testunexpectedarg{oneside}{#1}%
  \csname @scr@l@\scr@current@layer @twosidefalse\endcsname
  \csname @scr@l@\scr@current@layer @onesidetrue\endcsname
}
%    \end{macrocode}
% \item[\Option{twoside}:] restrict the layer to pages on two-sided
%   layouts.
%    \begin{macrocode}
\DefineFamilyKey[.definelayer]{KOMAarg}{twoside}[\relax]{%
  \FamilyKeyStateProcessed
  \scrlayer@testunexpectedarg{twoside}{#1}%
  \csname @scr@l@\scr@current@layer @twosidetrue\endcsname
  \csname @scr@l@\scr@current@layer @onesidefalse\endcsname
}
%    \end{macrocode}
% \item[\Option{everyside}:] remove all one- or two-side restrictions.
% \changes{v3.18}{2015/05/14}{new layer feature \texttt{everyside}}
%    \begin{macrocode}
\DefineFamilyKey[.definelayer]{KOMAarg}{everyside}[\relax]{%
  \FamilyKeyStateProcessed
  \scrlayer@testunexpectedarg{everyside}{#1}%
  \csname @scr@l@\scr@current@layer @twosidetrue\endcsname
  \csname @scr@l@\scr@current@layer @onesidetrue\endcsname
}
%    \end{macrocode}
% \item[\Option{unrestricted}:] remove all restrictions
% \changes{v3.18}{2015/05/14}{new layer feature \texttt{unrestricted}}%^^A
% \changes{v3.22}{2016/09/24}{missing background and foreground
%   condition}%^^A
% \changes{v3.22}{2016/09/24}{nonfloatpage condition fixed}%^^A
%    \begin{macrocode}
\DefineFamilyKey[.definelayer]{KOMAarg}{unrestricted}[\relax]{%
  \FamilyKeyStateProcessed
  \scrlayer@testunexpectedarg{unrestricted}{#1}%
  \csname @scr@l@\scr@current@layer @oddtrue\endcsname
  \csname @scr@l@\scr@current@layer @eventrue\endcsname
  \csname @scr@l@\scr@current@layer @backgroundtrue\endcsname
  \csname @scr@l@\scr@current@layer @foregroundtrue\endcsname
  \csname @scr@l@\scr@current@layer @nonfloatpagetrue\endcsname
  \csname @scr@l@\scr@current@layer @floatpagetrue\endcsname
  \csname @scr@l@\scr@current@layer @twosidetrue\endcsname
  \csname @scr@l@\scr@current@layer @onesidetrue\endcsname
}
%    \end{macrocode}
% \changes{v3.26}{2018/07/14}{new attribute \texttt{beforecontents}}%^^A
% \item[\Option{beforecontents}:] code to be executed immediately before
%   setting the contents. See also modification attribute
%   \texttt{addbeforecontents}.
%    \begin{macrocode}
\FamilyCSKey[.definelayer]{KOMAarg}{beforecontents}
            {scr@l@\scr@current@layer @precontents@hook}
%    \end{macrocode}
% \changes{v3.26}{2018/07/14}{new attribute \texttt{aftercontents}}%^^A
% \item[\Option{aftercontents}:] code to be executed immediately before
%   setting the contents. See also modification attribute
%   \texttt{addaftercontents}.
%    \begin{macrocode}
\FamilyCSKey[.definelayer]{KOMAarg}{aftercontents}
            {scr@l@\scr@current@layer @postcontents@hook}
%    \end{macrocode}
% \changes{v3.26}{2018/07/14}{new attribute \texttt{artifact}}%^^A
% \item[\Option{artifact}:] reserved for tagging packages. The artifact can
%   either be a boolean or a general value. Boolean false will unset the
%   attribute. Boolean true is the same like empty. All other values will be
%   stored.
%    \begin{macrocode}
\DefineFamilyKey[.definelayer]{KOMAarg}{artifact}[true]{%
  \FamilySetBool{KOMAarg}{artifact}{@tempswa}{#1}%
  \ifx\FamilyKeyState\FamilyKeyStateProcessed
    \if@tempswa
      \expandafter\let\csname scr@l@\scr@current@layer @artifact\endcsname
      \@empty
    \else
      \expandafter\let\csname scr@l@\scr@current@layer @artifact\endcsname
      \relax
    \fi
  \else
    \FamilyKeyStateProcessed
    \@namedef{scr@l@\scr@current@layer @artifact}{#1}%
  \fi
}
%    \end{macrocode}
% \end{description}
%
% Attribute modifications are attributes, that modify existing basic
% attributes:
% \begin{description}
% \changes{v3.16}{2015/01/26}{new layer attribute \texttt{addhoffset}}%^^A
% \item[\texttt{addhoffset=\meta{dimension expression}}:] add to offset from
%   the left edge of the paper.
%    \begin{macrocode}
\DefineFamilyKey[.definelayer]{KOMAarg}{addhoffset}{%
  \expandafter\edef\csname scr@l@\scr@current@layer @x\endcsname{%
    \noexpand\dimexpr \unexpanded\expandafter\expandafter\expandafter{%
      \csname scr@l@\scr@current@layer @x\endcsname + (#1)\relax}}%
  \FamilyKeyStateProcessed
}
%    \end{macrocode}
% \changes{v3.16}{2015/01/26}{new layer attribute \texttt{addvoffset}}%^^A
% \item[\texttt{addvoffset=\meta{dimension expression}}:] add to offset from
%   the top edge of the paper.
%    \begin{macrocode}
\DefineFamilyKey[.definelayer]{KOMAarg}{addvoffset}{%
  \expandafter\edef\csname scr@l@\scr@current@layer @y\endcsname{%
    \noexpand\dimexpr \unexpanded\expandafter\expandafter\expandafter{%
      \csname scr@l@\scr@current@layer @y\endcsname + (#1)\relax}}%
  \FamilyKeyStateProcessed
}
%    \end{macrocode}
% \changes{v3.16}{2015/01/26}{new layer attribute \texttt{addwidth}}%^^A
% \item[\texttt{addwidth=\meta{dimension expression}}:] add to width of the
%   layer.
%    \begin{macrocode}
\DefineFamilyKey[.definelayer]{KOMAarg}{addwidth}{%
  \expandafter\edef\csname scr@l@\scr@current@layer @w\endcsname{%
    \noexpand\dimexpr \unexpanded\expandafter\expandafter\expandafter{%
      \csname scr@l@\scr@current@layer @w\endcsname + (#1)\relax}}%
  \FamilyKeyStateProcessed
}
%    \end{macrocode}
% \changes{v3.16}{2015/01/26}{new layer attribute \texttt{addheight}}%^^A
% \item[\texttt{addheight=\meta{dimension expression}}:] add to height of the
%   layer.
%    \begin{macrocode}
\DefineFamilyKey[.definelayer]{KOMAarg}{addheight}{%
  \expandafter\edef\csname scr@l@\scr@current@layer @h\endcsname{%
    \noexpand\dimexpr \unexpanded\expandafter\expandafter\expandafter{%
      \csname scr@l@\scr@current@layer @h\endcsname + (#1)\relax}}%
  \FamilyKeyStateProcessed
}
%    \end{macrocode}
% \changes{v3.16}{2015/01/26}{new layer attribute \texttt{addcontents}}%^^A
% \item[\texttt{addcontents=\meta{output}}:] append to whatever should be
%   printed by the layer.
% \changes{v3.14}{2014/10/20}{\texttt{contents} is \cs{long}}%^^A
%    \begin{macrocode}
\DefineFamilyKey[.definelayer]{KOMAarg}{addcontents}{%
  \expandafter\edef\csname scr@l@\scr@current@layer @contents\endcsname{%
    \unexpanded\expandafter\expandafter\expandafter{%
      \csname scr@l@\scr@current@layer @contents\endcsname #1}}%
  \FamilyKeyStateProcessed
}
%    \end{macrocode}
% \changes{v3.16}{2015/01/26}{new layer attribute \texttt{pretocontents}}%^^A
% \item[\texttt{pretocontents=\meta{output}}:] prefix whatever should be
%   printed by the layer.
% \changes{v3.14}{2014/10/20}{\texttt{contents} is \cs{long}}%^^A
%    \begin{macrocode}
\DefineFamilyKey[.definelayer]{KOMAarg}{pretocontents}{%
  \expandafter\edef\csname scr@l@\scr@current@layer @contents\endcsname{%
    \unexpanded{#1}\unexpanded\expandafter\expandafter\expandafter{%
      \csname scr@l@\scr@current@layer @contents\endcsname}}%
  \FamilyKeyStateProcessed
}
%    \end{macrocode}
% \changes{v3.26}{2018/07/14}{new attribute \texttt{addbeforecontents}}%^^A
% \item[\Option{addbeforecontents}:] code to be executed immediately before
%   setting the contents. The new code will be added before the old code.
%    \begin{macrocode}
\DefineFamilyKey[.definelayer]{KOMAarg}{addbeforecontents}{%
  \scr@ifundefinedorrelax{scr@l@\scr@current@layer @precontents@hook}{%
    \expandafter\def
    \csname scr@l@\scr@current@layer @precontents@hook\endcsname{#1}%
  }{%
    \expandafter\edef
    \csname scr@l@\scr@current@layer @precontents@hook\endcsname{%
      \unexpanded\expandafter\expandafter\expandafter{%
        \csname scr@l@\scr@current@layer @precontents@hook\endcsname}%
      \unexpanded{#1}
    }%
  }%
  \FamilyKeyStateProcessed
}
%    \end{macrocode}
% \changes{v3.26}{2018/07/14}{new attribute \texttt{addaftercontents}}%^^A
% \item[\Option{addaftercontents}:] code to be executed immediately before
%   setting the contents. The new code will be added after the old code.
%    \begin{macrocode}
\DefineFamilyKey[.definelayer]{KOMAarg}{addaftercontents}{%
  \scr@ifundefinedorrelax{scr@l@\scr@current@layer @postcontents@hook}{%
    \expandafter\def
    \csname scr@l@\scr@current@layer @postcontents@hook\endcsname{#1}%
  }{%
    \expandafter\edef
    \csname scr@l@\scr@current@layer @postcontents@hook\endcsname{%
      \unexpanded{#1}%
      \unexpanded\expandafter\expandafter\expandafter{%
        \csname scr@l@\scr@current@layer @postcontents@hook\endcsname}%
    }%
  }%
  \FamilyKeyStateProcessed
}
%    \end{macrocode}
% \end{description}
%
% Compounding attributes are attributes, that set up several basic attributes
% with a single compounding attribute:
% \begin{description}
% \item[\texttt{page}:] set up \texttt{hoffset}, \texttt{voffset},
%   \texttt{width}, and \texttt{height} to values spanning the whole
%   page aligned by the default alignment \texttt{tl}. Note, that this
%   attribute has no value!
%    \begin{macrocode}
\DefineFamilyKey[.definelayer]{KOMAarg}{page}[\relax]{%
  \FamilyKeyStateProcessed
  \scrlayer@testunexpectedarg{page}{#1}%
  \def@scr@l@pos{\z@}{\z@}{\paperwidth}{\paperheight}%
  \@namedef{scr@l@\scr@current@layer @align}{tl}%
}
%    \end{macrocode}
% \item[\texttt{topmargin}:] set up \texttt{hoffset}, \texttt{voffset},
%   \texttt{width}, and \texttt{height} to values vertically spanning the top
%   margin of the page and horizontally spanning the whole page aligned by the
%   default alignment \texttt{tl}. Note, that this attribute has no value!
%    \begin{macrocode}
\DefineFamilyKey[.definelayer]{KOMAarg}{topmargin}[\relax]{%
  \FamilyKeyStateProcessed
  \scrlayer@testunexpectedarg{topmargin}{#1}%
  \def@scr@l@pos{\z@}{\z@}{\paperwidth}{\dimexpr \topmargin+1in\relax}%
  \@namedef{scr@l@\scr@current@layer @align}{tl}%
}
%    \end{macrocode}
% \item[\texttt{head}:] set up \texttt{hoffset}, \texttt{voffset},
%   \texttt{width}, and \texttt{height} to values vertically spanning the page
%   head and horizontally spanning the text area aligned by usual head
%   alignment \texttt{bl}. Note, that this attribute has no value!
%    \begin{macrocode}
\DefineFamilyKey[.definelayer]{KOMAarg}{head}[\relax]{%
  \FamilyKeyStateProcessed
  \scrlayer@testunexpectedarg{head}{#1}%
  \def@scr@l@pos{%
    \dimexpr
      \if@twoside\ifodd\value{page}\oddsidemargin\else\evensidemargin\fi
      \else\oddsidemargin\fi
      +1in
    \relax
  }{%
    \dimexpr \topmargin+1in+\headheight\relax
  }{\textwidth}{\headheight}%
  \@namedef{scr@l@\scr@current@layer @align}{bl}%
}
%    \end{macrocode}
% \item[\texttt{headsep}:] set up \texttt{hoffset}, \texttt{voffset},
%   \texttt{width}, and \texttt{height} to values vertically spanning the area
%     between page head and text area and horizontally spanning the text area
%     aligned by the default alignment \texttt{t}. Note, that this attribute
%     has no value!
%    \begin{macrocode}
\DefineFamilyKey[.definelayer]{KOMAarg}{headsep}[\relax]{%
  \FamilyKeyStateProcessed
  \scrlayer@testunexpectedarg{head}{#1}%
  \def@scr@l@pos{%
    \dimexpr
      \if@twoside\ifodd\value{page}\oddsidemargin\else\evensidemargin\fi
      \else\oddsidemargin\fi
      +1in
    \relax
  }{%
    \dimexpr \topmargin+1in+\headheight\relax
  }{\textwidth}{\headsep}%
  \@namedef{scr@l@\scr@current@layer @align}{tl}%
}
%    \end{macrocode}
% \item[\texttt{textarea}:] set up \texttt{hoffset}, \texttt{voffset},
%   \texttt{width}, and \texttt{height} to values spanning the text area of
%   the page aligned by the default alignment \texttt{t}. Note, that this
%   attribute has no value!
%    \begin{macrocode}
\DefineFamilyKey[.definelayer]{KOMAarg}{textarea}[\relax]{%
  \FamilyKeyStateProcessed
  \scrlayer@testunexpectedarg{textarea}{#1}%
  \def@scr@l@pos{%
    \dimexpr
      \if@twoside\ifodd\value{page}\oddsidemargin\else\evensidemargin\fi
      \else\oddsidemargin\fi
      +1in
    \relax
  }{%
    \dimexpr \topmargin+1in+\headheight+\headsep\relax
  }{\textwidth}{\textheight}%
  \@namedef{scr@l@\scr@current@layer @align}{tl}%
}
%    \end{macrocode}
% \item[\texttt{foot}:] set up \texttt{hoffset}, \texttt{voffset},
%   \texttt{width}, and \texttt{height} to values vertically spanning the page
%   footer and horizontally spanning the text area aligned by the usual footer
%   alignment \texttt{t}. Note, that this attribute has no value!
%    \begin{macrocode}
\DefineFamilyKey[.definelayer]{KOMAarg}{foot}[\relax]{%
  \FamilyKeyStateProcessed
  \scrlayer@testunexpectedarg{foot}{#1}%
  \def@scr@l@pos{%
    \dimexpr
      \if@twoside\ifodd\value{page}\oddsidemargin\else\evensidemargin\fi
      \else\oddsidemargin\fi
      +1in
    \relax
  }{%
    \dimexpr \topmargin+1in+\headheight+\headsep+\textheight
    +\footskip+\dp\strutbox-\footheight\relax
  }{\textwidth}{\footheight}%
  \@namedef{scr@l@\scr@current@layer @align}{tl}%
}
%    \end{macrocode}
% \item[\texttt{footskip}:] set up \texttt{hoffset}, \texttt{voffset},
%   \texttt{width}, and \texttt{height} to values vertically spanning the
%   distance from the text area to the page
%   footer and horizontally spanning the text area aligned by the usual footer
%   alignment \texttt{t}. Note, that this attribute has no value!
%    \begin{macrocode}
\DefineFamilyKey[.definelayer]{KOMAarg}{footskip}[\relax]{%
  \FamilyKeyStateProcessed
  \scrlayer@testunexpectedarg{foot}{#1}%
  \def@scr@l@pos{%
    \dimexpr
      \if@twoside\ifodd\value{page}\oddsidemargin\else\evensidemargin\fi
      \else\oddsidemargin\fi
      +1in
    \relax
  }{%
    \dimexpr \topmargin+1in+\headheight+\headsep+\textheight\relax
  }{\textwidth}{\dimexpr\footskip+\dp\strutbox-\footheight\relax}%
  \@namedef{scr@l@\scr@current@layer @align}{tl}%
}
%    \end{macrocode}
% \item[\texttt{bottommargin}:] set up \texttt{hoffset}, \texttt{voffset},
%   \texttt{width}, and \texttt{height} to values vertically spanning the
%   page's bottom margin below the footer and horizontally spanning the page
%   by the default alignment \texttt{t}. Note, that this attribute has no
%   value!
%    \begin{macrocode}
\DefineFamilyKey[.definelayer]{KOMAarg}{bottommargin}[\relax]{%
  \FamilyKeyStateProcessed
  \scrlayer@testunexpectedarg{bottommargin}{#1}%
  \def@scr@l@pos{\z@}{%
    \dimexpr \topmargin+1in+\headheight+\headsep
            +\textheight
            +\footskip+\dp\strutbox\relax
  }{\paperwidth}{\dimexpr\paperheight-\layeryoffset\relax}%
  \@namedef{scr@l@\scr@current@layer @align}{tl}%
}
%    \end{macrocode}
% \item[\texttt{leftmargin}:] set up \texttt{hoffset}, \texttt{voffset},
%   \texttt{width}, and \texttt{height} to values vertically spanning the page
%   and horizontally spanning the left margin of the page by the default
%   alignment \texttt{t}. Note, that this attribute has no value!
%    \begin{macrocode}
\DefineFamilyKey[.definelayer]{KOMAarg}{leftmargin}[\relax]{%
  \FamilyKeyStateProcessed
  \scrlayer@testunexpectedarg{leftmargin}{#1}%
  \def@scr@l@pos{\z@}{\z@}{%
    \dimexpr
      \if@twoside\ifodd\value{page}\oddsidemargin\else\evensidemargin\fi
      \else\oddsidemargin\fi
      +1in
    \relax
  }{\paperheight}%
  \@namedef{scr@l@\scr@current@layer @align}{tl}%
}
%    \end{macrocode}
% \item[\texttt{rightmargin}:] set up \texttt{hoffset}, \texttt{voffset},
%   \texttt{width}, and \texttt{height} to values vertically spanning the page
%   and horizontally spanning the right margin of the page by the default
%   alignment \texttt{t}. Note, that this attribute has no value!
%    \begin{macrocode}
\DefineFamilyKey[.definelayer]{KOMAarg}{rightmargin}[\relax]{%
  \FamilyKeyStateProcessed
  \scrlayer@testunexpectedarg{rightmargin}{#1}%
  \def@scr@l@pos{\paperwidth}{\z@}{%
    \dimexpr \paperwidth-1in-\textwidth
      -\if@twoside\ifodd\value{page}\oddsidemargin\else\evensidemargin\fi
       \else\oddsidemargin\fi\relax
  }{\paperheight}%
  \@namedef{scr@l@\scr@current@layer @align}{tr}%
}
%    \end{macrocode}
% \item[\texttt{innermargin}:] set up \texttt{hoffset}, \texttt{voffset},
%   \texttt{width}, and \texttt{height} to values vertically spanning the page
%   and horizontally spanning the right margin of even pages and the left
%   margin of odd pages by the default alignment \texttt{t}. See attributes
%   \texttt{oddpage} and \texttt{evenpage} for more information about odd and
%   even pages. Note, that this attribute has no value!
%    \begin{macrocode}
\DefineFamilyKey[.definelayer]{KOMAarg}{innermargin}[\relax]{%
  \FamilyKeyStateProcessed
  \scrlayer@testunexpectedarg{innermargin}{#1}%
  \def@scr@l@pos{%
    \if@twoside
      \ifodd\value{page} \z@
      \else \dimexpr \evensidemargin+1in+\textwidth\relax
      \fi
    \else \z@\fi
  }{\z@}{%
    \dimexpr
      \if@twoside\ifodd\value{page} \oddsidemargin+1in
        \else \paperwidth-\layerxoffset\fi
      \else \oddsidemargin+1in\fi
    \relax
  }{\paperheight}%
  \@namedef{scr@l@\scr@current@layer @align}{tl}%
}
%    \end{macrocode}
% \item[\texttt{outermargin}:] set up \texttt{hoffset}, \texttt{voffset},
%   \texttt{width}, and \texttt{height} to values vertically spanning the page
%   and horizontally spanning the left margin of even pages and the right
%   margin of odd pages by the default alignment \texttt{t}. See attributes
%   \texttt{oddpage} and \texttt{evenpage} for more information about odd and
%   even pages. Note, that this attribute has no value!
%    \begin{macrocode}
\DefineFamilyKey[.definelayer]{KOMAarg}{outermargin}[\relax]{%
  \FamilyKeyStateProcessed
  \scrlayer@testunexpectedarg{outermargin}{#1}%
  \def@scr@l@pos{%
    \dimexpr
      \if@twoside\ifodd\value{page} \oddsidemargin+1in+\textwidth
        \else \z@\fi
      \else \oddsidemargin+1in+\textwidth\fi
    \relax
  }{\z@}{%
    \dimexpr
      \if@twoside\ifodd\value{page}\paperwidth-\layerxoffset
        \else \evensidemargin+1in\fi
      \else \paperwidth-\layerxoffset\fi
    \relax
  }{\paperheight}%
  \@namedef{scr@l@\scr@current@layer @align}{tl}%
}
%    \end{macrocode}
% \item[\texttt{area=\{\meta{hoffset}\}\{\meta{voffset}\}%^^A
%                    \{\meta{width}\}\{\meta{height}\}}:] set up
%   \texttt{hoffset}, \texttt{voffset}, \texttt{width}, and \texttt{height} to
%   the given values.
%    \begin{macrocode}
\DefineFamilyKey[.definelayer]{KOMAarg}{area}{%
  \def@scr@l@pos#1
  \FamilyKeyStateProcessed
}
%    \end{macrocode}
% \changes{v3.26}{2018/07/14}{clone code for \texttt{precontents@hook},
%   \texttt{postcontents@hook} and \texttt{artifact} added}%^^A
% \item[\texttt{clone=\meta{layer}}:] set up the new layer by the settings
%   of the given \meta{layer}.
%   \begin{macrocode}
\DefineFamilyKey[.definelayer]{KOMAarg}{clone}{%
  \scr@ifundefinedorrelax{scr@l@#1@x}{%
    \FamilyKeyStateUnknownValue
    \PackageError{scrlayer}{layer `#1' undefined}{%
      You can clone only already defined layers.\MessageBreak
      If you'll continue, `clone=#1' will be ignored.%
    }%
  }{%
    \FamilyKeyStateProcessed
    \scrlayer@clone@attribute{\scr@current@layer}{#1}{mode}%
    \scrlayer@clone@attribute{\scr@current@layer}{#1}{x}%
    \scrlayer@clone@attribute{\scr@current@layer}{#1}{y}%
    \scrlayer@clone@attribute{\scr@current@layer}{#1}{w}%
    \scrlayer@clone@attribute{\scr@current@layer}{#1}{h}%
    \scrlayer@clone@attribute{\scr@current@layer}{#1}{align}%
    \scrlayer@clone@attribute{\scr@current@layer}{#1}{contents}%
    \scrlayer@clone@switch{\scr@current@layer}{#1}{background}%
    \scrlayer@clone@switch{\scr@current@layer}{#1}{foreground}%
    \scrlayer@clone@switch{\scr@current@layer}{#1}{odd}%
    \scrlayer@clone@switch{\scr@current@layer}{#1}{even}%
    \scrlayer@clone@switch{\scr@current@layer}{#1}{oneside}%
    \scrlayer@clone@switch{\scr@current@layer}{#1}{twoside}%
    \scrlayer@clone@switch{\scr@current@layer}{#1}{floatpage}%
    \scrlayer@clone@switch{\scr@current@layer}{#1}{nonfloatpage}%
    \scrlayer@clone@attribute{\scr@current@layer}{#1}{precontents@hook}%
    \scrlayer@clone@attribute{\scr@current@layer}{#1}{postcontents@hook}%
    \scrlayer@clone@attribute{\scr@current@layer}{#1}{artifact}%
  }%
}
%    \end{macrocode}
% \begin{macro}{\scrlayer@clone@attribute}
% \begin{macro}{\scrlayer@clone@switch}
% Two helpers used at option \texttt{clone} to clone either a macro-based
% attribute or a if-based attribute.
%    \begin{macrocode}
\newcommand*{\scrlayer@clone@attribute}[3]{%
  \expandafter\let\csname scr@l@#1@#3\expandafter\endcsname
                  \csname scr@l@#2@#3\expandafter\endcsname
}
\newcommand*{\scrlayer@clone@switch}[3]{%
  \expandafter\let\csname if@scr@l@#1@#3\expandafter\endcsname
                  \csname if@scr@l@#2@#3\expandafter\endcsname
}
%    \end{macrocode}
% \end{macro}%^^A \scrlayer@clone@switch
% \end{macro}%^^A \scrlayer@clone@attribute
% \end{description}
%
% \changes{v0.9}{2014/08/31}{missing reset of \cs{scr@current@layer}
%     added}%^^A
% \changes{v3.14}{2014/10/20}{\cs{long}}%^^A
%    \begin{macrocode}
\newcommand{\DeclareLayer}[2][]{%
  \def\scr@current@layer{#2}%
  \@namedef{scr@l@#2@mode}{text}%
  \@namedef{scr@l@#2@x}{\z@}%
  \@namedef{scr@l@#2@y}{\z@}%
  \@namedef{scr@l@#2@w}{\paperwidth}%
  \@namedef{scr@l@#2@h}{\paperheight}%
  \@namedef{scr@l@#2@align}{tl}%
  \@namedef{scr@l@#2@contents}{}%
  \expandafter\newif\csname if@scr@l@#2@background\endcsname
  \csname @scr@l@#2@backgroundtrue\endcsname
  \expandafter\newif\csname if@scr@l@#2@foreground\endcsname
  \csname @scr@l@#2@foregroundtrue\endcsname
  \expandafter\newif\csname if@scr@l@#2@odd\endcsname
  \csname @scr@l@#2@oddtrue\endcsname
  \expandafter\newif\csname if@scr@l@#2@even\endcsname
  \csname @scr@l@#2@eventrue\endcsname
  \expandafter\newif\csname if@scr@l@#2@oneside\endcsname
  \csname @scr@l@#2@onesidetrue\endcsname
  \expandafter\newif\csname if@scr@l@#2@twoside\endcsname
  \csname @scr@l@#2@twosidetrue\endcsname
  \expandafter\newif\csname if@scr@l@#2@floatpage\endcsname
  \csname @scr@l@#2@floatpagetrue\endcsname
  \expandafter\newif\csname if@scr@l@#2@nonfloatpage\endcsname
  \csname @scr@l@#2@nonfloatpagetrue\endcsname
  \FamilyExecuteOptions[.definelayer]{KOMAarg}{#1}%
  \let\scr@current@layer\@empty
}
%    \end{macrocode}
% \begin{macro}{\scr@current@layer}
% Helper to hold the current layer and only valid in non recursive calls of
% \Macro{DeclareLayer}.
%    \begin{macrocode}
\newcommand*{\scr@current@layer}{}
%</package&body>
%    \end{macrocode}
% \end{macro}%^^A \scr@current@layer
% \end{macro}%^^A \DeclareLayer
%
% \begin{macro}{\IfLayerExists}
% \begin{description}
% \item[\Parameter{string}:] the name of the layer (must be fully expandable
%   and expand to a string only).
% \item[\Parameter{then code}:] will be executed, if the layer exists.
% \item[\Parameter{else code}:] will be executed, if the layer doesn't exist.
% \end{description}
% Note, that we don't known really whether or not a layer exists, but have a
% heuristic.
%    \begin{macrocode}
%<*package&body>
\newcommand*{\IfLayerExists}[1]{%
  \scr@ifundefinedorrelax{scr@l@#1@mode}{%
    \expandafter\@secondoftwo
  }{%
    \expandafter\@firstoftwo
  }%
}
%</package&body>
%    \end{macrocode}
% \end{macro}%^^A \IfLayerExists
%
% \begin{macro}{\DeclareNewLayer}
% \changes{v3.14}{2014/10/20}{\cs{long}}%^^A
% \begin{macro}{\ProvideLayer}
% \changes{v3.14}{2014/10/20}{\cs{long}}%^^A
% \begin{macro}{\RedeclareLayer}
% \changes{v3.14}{2014/10/20}{\cs{long}}%^^A
% \begin{macro}{\ModifyLayer}
% \changes{v3.14}{2014/10/20}{\cs{long}}%^^A
% \changes{v0.9}{2014/08/31}{missing definition and reset of
%   \cs{scr@current@layer} added}%^^A
% \changes{v3.28}{2019/11/18}{\cs{ifstr} umbenannt in \cs{Ifstr}}%^^A
% There are also two commands for declaration of layers, that haven't been
% declared before, with or without error message for already declared layers,
% and two commands for changing already declared layers, first one beginning
% again from scratch, second one for only setting up attributes, that should
% be changed.
%    \begin{macrocode}
%<*package&body>
\newcommand{\DeclareNewLayer}[2][]{%
  \IfLayerExists{#2}{%
    \PackageError{scrlayer}{layer `#2' already defined}{%
      You may declare only layer, that haven't been declared previously
      using\MessageBreak
      \string\DeclareNewLayer. See also the alternatives
      \string\RedeclareLayer,\MessageBreak
      \string\ModifyLayer\space and \string\ProvideLayer.\MessageBreak
      If you'll continue, declaration will be ignored.}%
  }{\DeclareLayer[{#1}]{#2}}%
}
\newcommand{\ProvideLayer}[2][]{%
  \IfLayerExists{#2}{%
%<*trace>
    \PackageInfo{scrlayer}{\string\ProvideLayer{#2} ignored,\MessageBreak
      because of already defined layer}%
%</trace>
  }{\DeclareNewLayer[{#1}]{#2}}%
}
\newcommand{\RedeclareLayer}[2][]{%
  \IfLayerExists{#2}{}{%
    \PackageError{scrlayer}{layer `#2' not yet defined}{%
      You may declare only already declared layers using
      \string\RedeclareLayer.\MessageBreak
      See also the alternatives
      \string\DeclareLayer and \string\ProvideLayer.\MessageBreak
      Nevertheless, if you'll continue, declaration will be done.}%
  }%
  \DeclareLayer[{#1}]{#2}%
}
\newcommand{\ModifyLayer}[2][]{%
  \IfLayerExists{#2}{%
    \def\scr@current@layer{#2}%
    \edef\reserved@a{%
      \unexpanded{%
        \FamilyExecuteOptions[.definelayer]{KOMAarg}{#1}%
        \Ifstr{\csname scr@l@#2@mode\endcsname}%
      }{\csname scr@l@#2@mode\endcsname}%
    }\reserved@a{}{%
      \PackageWarning{scrlayer}{%
        change of layer mode could result in unexpected\MessageBreak
        output and errors%
      }%
    }%
    \let\scr@current@layer\@empty
  }{%
    \PackageError{scrlayer}{layer `#2' not yet defined}{%
      You may modify only already declared layers using
      \string\ModifyLayer.\MessageBreak
      See also the alternatives
      \string\DeclareLayer and \string\ProvideLayer.\MessageBreak
      Nevertheless, if you'll continue, declaration will be done.}%
    \DeclareLayer[{#1}]{#2}%
  }%
}
%</package&body>
%    \end{macrocode}
% \end{macro}%^^A \ModifyLayer
% \end{macro}%^^A \RedeclareLayer
% \end{macro}%^^A \ProvideLayer
% \end{macro}%^^A \DeclareNewLayer
%
% \begin{macro}{\ModifyLayers}
% \changes{v3.26}{2018/07/14}{new}%^^A
% \changes{v3.26}{2018/08/29}{\cs{scr@trim@spaces} added}%^^A
% Like \cs{ModifyLayer} but allows a list of layers instead of only one layer.
% For the commands \cs{DeclareLayer}, \cs{ProvideLayer} and
% \cs{RedeclareLayer} this does not make any sense, so there are not similar
% list commands for these commands.
%    \begin{macrocode}
%<*package&body>
\newcommand{\ModifyLayers}[2][]{%
  \edef\scr@current@layer{#2}%
  \@for\scr@current@layer:=\scr@current@layer\do{%
    \scr@trim@spaces\scr@current@layer
    \ifx\scr@current@layer\@emtpy\else
      \edef\scr@current@layer{%
        \unexpanded{\ModifyLayer[{#1}]}{\scr@current@layer}%
      }%
      \scr@current@layer
    \fi
  }%
  \let\scr@current@layer\@empty
}
%</package&body>
%    \end{macrocode}
% \end{macro}%^^A \ModifyLayers
%
% \begin{macro}{\GetLayerContents}
% \changes{v3.16}{2015/01/26}{new}
%   \begin{description}
%   \item[\Parameter{string}:] the name of the layer
%   \end{description}
% Get the contents of the given layer.
%    \begin{macrocode}
%<*package&body>
\newcommand*{\GetLayerContents}[1]{%
  \IfLayerExists{#1}{\@nameuse{scr@l@#1@contents}}{%
    \PackageError{scrlayer}{unknown layer `#1'}{%
      You can ask only for the contents of an existing layer.}%
  }%
}
%</package&body>
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\DestroyLayer}
% \changes{v3.26}{2018/07/14}{destroy pre-contents hook, post-contents hook
%   and artifact}%^^A
%   \begin{description}
%   \item[\Parameter{string}:] the name of the layer, that should be
%     destroyed
%   \end{description}
% Note: Nothing will be done to remove the layer from a page style, but this
% shouldn't matter, because layers with, e.g.,
% \Macro{if@scr@l@\dots@nonfloatpage}=\Macro{relax} and
% \Macro{if@scr@l@\dots@floatpage}=\Macro{relax} won't be output ever. This
% command could be used by interfaces via
% \Macro{scrlayerOnAutoRemoveInterface} to remove the generated
% layers, if the interface commands wouldn't be depreacted.
% However, it only destroys existing layers and doesn't care for not
% existing.
%    \begin{macrocode}
%<*package&body>
\newcommand*{\DestroyLayer}[1]{%
  \IfLayerExists{#1}{%
    \expandafter\let\csname scr@l@#1@mode\endcsname\relax
    \expandafter\let\csname scr@l@#1@x\endcsname\relax
    \expandafter\let\csname scr@l@#1@y\endcsname\relax
    \expandafter\let\csname scr@l@#1@w\endcsname\relax
    \expandafter\let\csname scr@l@#1@h\endcsname\relax
    \expandafter\let\csname scr@l@#1@align\endcsname\relax
    \expandafter\let\csname scr@l@#1@contents\endcsname\relax
    \expandafter\let\csname if@scr@l@#1@background\endcsname\relax
    \expandafter\let\csname @scr@l@#1@backgroundfalse\endcsname\relax
    \expandafter\let\csname @scr@l@#1@backgroundtrue\endcsname\relax
    \expandafter\let\csname if@scr@l@#1@foreground\endcsname\relax
    \expandafter\let\csname @scr@l@#1@foregroundfalse\endcsname\relax
    \expandafter\let\csname @scr@l@#1@foregroundtrue\endcsname\relax
    \expandafter\let\csname if@scr@l@#1@odd\endcsname\relax
    \expandafter\let\csname @scr@l@#1@oddfalse\endcsname\relax
    \expandafter\let\csname @scr@l@#1@oddtrue\endcsname\relax
    \expandafter\let\csname if@scr@l@#1@even\endcsname\relax
    \expandafter\let\csname @scr@l@#1@evenfalse\endcsname\relax
    \expandafter\let\csname @scr@l@#1@eventrue\endcsname\relax
    \expandafter\let\csname if@scr@l@#1@oneside\endcsname\relax
    \expandafter\let\csname @scr@l@#1@onesidefalse\endcsname\relax
    \expandafter\let\csname @scr@l@#1@onesidetrue\endcsname\relax
    \expandafter\let\csname if@scr@l@#1@twoside\endcsname\relax
    \expandafter\let\csname @scr@l@#1@twosidefalse\endcsname\relax
    \expandafter\let\csname @scr@l@#1@twosidetrue\endcsname\relax
    \expandafter\let\csname if@scr@l@#1@floatpage\endcsname\relax
    \expandafter\let\csname @scr@l@#1@floatpagefalse\endcsname\relax
    \expandafter\let\csname @scr@l@#1@floatpagetrue\endcsname\relax
    \expandafter\let\csname if@scr@l@#1@nonfloatpage\endcsname\relax
    \expandafter\let\csname @scr@l@#1@nonfloatpagefalse\endcsname\relax
    \expandafter\let\csname @scr@l@#1@nonfloatpagetrue\endcsname\relax
    \expandafter\let\csname scr@l@#1@precontents@hook\relax
    \expandafter\let\csname scr@l@#1@postcontents@hook\relax
    \expandafter\let\csname scr@l@#1@artifact\relax
  }{%
%<*trace>    
    \PackageInfo{scrlayer}{\string\DestroyLayer{#1} ignored,\MessageBreak
      because that layer doesn't exist\MessageBreak
      (any longer)%
    }%
%</trace>
  }%
}
%</package&body>
%    \end{macrocode}
% \end{macro}%^^A \DestroyLayer
%
%
% \begin{macro}{\layercontentsmeasure}
% \changes{v3.19}{2015/07/27}{\cs{@gobble} eliminated}%^^A
% This may used by used as the only value of the layer option
% \texttt{contents} to show measure lines around the layer. The left and the
% top measure line will be in centimeter, the right and the bottom measure
% line in inch. With option \texttt{draft=true} this also be used
% automatically and additionally for every layer of a page style.
%    \begin{macrocode}
%<*package&body>
\newcommand*{\layercontentsmeasure}{%
  \smash{\begin{picture}(0,0)
               (0,\LenToUnit{%
                 \if t\layervalign -\ht\strutbox
                 \else
                   \if b\layervalign -\dimexpr\layerheight-\dp\strutbox\relax
                   \else -.5\dimexpr\layerheight+\ht\strutbox-\dp\strutbox\relax
                   \fi
                 \fi})
%    \end{macrocode}
% 1st horizontal cm
%    \begin{macrocode}
    \setlength{\unitlength}{1mm}%
    \put(0,0){\line(1,0){\LenToUnit{\layerwidth}}}%
    \@tempcnta=\numexpr \dimexpr\layerwidth + .5mm\relax/\dimexpr 1mm\relax\relax
    \multiput(0,0)(1,0){\@tempcnta}{%
      \line(0,-1){1}%
    }%
    \@tempcnta=\numexpr \dimexpr\layerwidth + 2.5mm\relax/\dimexpr 5mm\relax\relax
    \multiput(0,0)(5,0){\@tempcnta}{%
      \line(0,-1){2}%
    }%
    \@tempcnta=\numexpr \dimexpr\layerwidth + .5cm\relax/\dimexpr 1cm\relax\relax
    \multiput(0,0)(10,0){\@tempcnta}{%
      \put(0,0){\line(0,-1){3}}%
      \put(0,-3.5){%
        \makebox(0,0)[ct]{\the\numexpr\@tempcnta-\@multicnt\relax}}%
    }%
%    \end{macrocode}
% 2nd horizontal in:
%    \begin{macrocode}
    \put(0,\LenToUnit{-\layerheight}){\line(1,0){\LenToUnit{\layerwidth}}}%
    \@tempcnta=\numexpr \dimexpr\layerwidth + .05in\relax/\dimexpr .1in\relax\relax
    \multiput(0,\LenToUnit{-\layerheight})(2.54,0){\@tempcnta}{%
      \line(0,1){1}%
    }%
    \@tempcnta=\numexpr \dimexpr\layerwidth + .25in\relax/\dimexpr .5in\relax\relax
    \multiput(0,\LenToUnit{-\layerheight})(12.7,0){\@tempcnta}{%
      \line(0,1){2}%
    }%
    \@tempcnta=\numexpr \dimexpr\layerwidth + .5in\relax/\dimexpr 1in\relax\relax
    \multiput(0,\LenToUnit{-\layerheight})(25.4,0){\@tempcnta}{%
      \put(0,0){\line(0,1){3}}%
      \put(0,3.5){%
        \makebox(0,0)[cb]{\the\numexpr\@tempcnta-\@multicnt\relax}}%
    }%
%    \end{macrocode}
% 3rd vertical cm:
%    \begin{macrocode}
    \put(0,0){\line(0,-1){\LenToUnit{\layerheight}}}%
    \@tempcnta\numexpr \dimexpr\layerheight + .5mm\relax/\dimexpr 1mm\relax\relax
    \multiput(0,0)(0,-1){\@tempcnta}{%
      \line(1,0){1}%
    }%
    \@tempcnta\numexpr \dimexpr\layerheight + 2.5mm\relax/\dimexpr 5mm\relax\relax
    \multiput(0,0)(0,-5){\@tempcnta}{%
      \line(1,0){2}%
    }%
    \@tempcnta\numexpr \dimexpr\layerheight + .5cm\relax/\dimexpr 1cm\relax\relax
    \multiput(0,0)(0,-10){\@tempcnta}{%
      \put(0,0){\line(1,0){3}}%
      \put(3.5,0){%
        \makebox(0,0)[cl]{\the\numexpr\@tempcnta-\@multicnt\relax}}%
    }%
%    \end{macrocode}
% 4th vertical in:
%    \begin{macrocode}
    \put(\LenToUnit{\layerwidth},0){\line(0,-1){\LenToUnit{\layerheight}}}%
    \@tempcnta\numexpr \dimexpr\layerheight + .05in\relax/\dimexpr .1in\relax\relax
    \multiput(\LenToUnit{\layerwidth},0)(0,-2.54){\@tempcnta}{%
      \line(-1,0){1}%
    }%
    \@tempcnta\numexpr \dimexpr\layerheight + .25in\relax/\dimexpr .5in\relax\relax
    \multiput(\LenToUnit{\layerwidth},0)(0,-12.7){\@tempcnta}{%
      \line(-1,0){2}%
    }%
    \@tempcnta\numexpr \dimexpr\layerheight + .5in\relax/\dimexpr 1in\relax\relax
    \multiput(\LenToUnit{\layerwidth},0)(0,-25.4){\@tempcnta}{%
      \put(0,0){\line(-1,0){3}}%
      \put(-3.5,0){%
        \makebox(0,0)[cr]{\the\numexpr\@tempcnta-\@multicnt\relax}}%
    }%
  \end{picture}}%
}
%    \end{macrocode}
% \begin{macro}{\LenToUnit}
% \changes{v3.19}{2015/07/27}{new}
% Due to an incompatibility of package \textsf{curve2e} I've eliminated
% \cs{@gobble} in the definition of \cs{layercontentsmeasure} and replaced it
% sometimes by \cs{LenToUnit} with the (not long) definition suggested by
% \textsf{curve2e} itself.
%    \begin{macrocode}
\providecommand*{\LenToUnit}[1]{\strip@pt\dimexpr#1*\p@/\unitlength}
%</package&body>
%    \end{macrocode}
% \end{macro}%^^A \LenToUnit
% \end{macro}%^^A \layercontentsmeasure
%
%
% \subsection{Providing Page Styles}
%
% Page styles in \LaTeX{} consist of the elements:
% \begin{itemize}
% \item a header for odd pages,
% \item a header for even pages,
% \item a footer for odd pages,
% \item a footer for even pages,
% \end{itemize}
% and some optional additional commands, that will be expanded, whenever the
% page style will be activated. Note, that header and footer for even pages
% will be used only at two-sided mode. At one-sided mode the header and footer
% for odd pages will be used for all pages.
%
% With package \Package{scrlayer} layers will be linked to package styles and
% expanded at the four elements above. Background layers will expand only
% at the headers. Foreground layers will expand only at the
% footers. Layers, that haven't been restricted to background or foreground,
% will expand at both, page headers and page footers.
%
% Similar to the expansion of background and foreground layers, odd page
% layers will only expand in the headers or footers of odd pages and even page
% layers will only expand in the headers or footers of even pages. Layers,
% that haven't been restricted to odd or even pages, will expand in the
% headers or footers of odd pages and also in the headers or footers of even
% pages.
%
% One step more: Single-side layers will only expand in the headers or footers
% of pages in single-side layouts and two-side layers only in the headers or
% footers of pages in two-side layout.
%
% One more step: float page layers will only expand in the headers or footers
% of pages, that consists of page floats only, while non-float page layers
% will only expand in the headers of footers of pages, that doesn't have page
% floats.
%
% \begin{length}{\footheight}
% For the header \LaTeX{} already defines a length \Length{headheight} to be
% the maximum height of the header. But for footer it only defines the
% distance of the baseline of the footer from the last baseline of the text
% area. \Package{scrlayer} changes this and also defines a new length
% \Length{footheight}. This length will be initialised with magic value
% -12345\,sp. But if it is still that magic value at
% \Macro{begin}\PParameter{document} it will be reset to the value of
% \Length{baselineskip}.
%    \begin{macrocode}
%<*package&init>
\@ifundefined{footheight}{%
  \newlength{\footheight}%
  \setlength{\footheight}{-12345sp}%
}{%
%<*trace>
  \PackageInfo{scrlayer}{Using already defined \string\footheight\MessageBreak
    hoping, that this is a length and\MessageBreak
    not only a macro}%
%</trace>
}
\AtBeginDocument{%
  \ifdim\footheight=-12345sp
%<*trace>    
    \PackageInfo{scrlayer}{Setting magic \string\footheight\space to
      \string\baselineskip\space while\MessageBreak
      \string\begin{document}}%
%</trace>
    \setlength{\footheight}{\baselineskip}
  \fi
}
%</package&init>
%    \end{macrocode}
% \end{length}%^^A \footheight
%
%
% Several of the following commands use \meta{key}=\meta{value} arguments. So
% we define a family with a new member:
%    \begin{macrocode}
%<*package&body>
\DefineFamily{KOMAarg}
\DefineFamilyMember[.definelayerpagestyle]{KOMAarg}
%</package&body>
%    \end{macrocode}
%
% \begin{macro}{\DeclarePageStyleByLayers}
%   \begin{description}
%   \item[\OParameter{option list}:] comma separated list of named page
%     style options (see below).
%   \item[\Parameter{string}:] the name of the page style to be declared (must
%     be expandable and result in a string).
%   \item[\Parameter{string list}:] comma separated list of layer names (must
%     be expandable and result in strings); first in the list will be added
%     first.
%   \end{description}
% Page styles may be declared using this command. It has one optional and
% two mandatory arguments. The first mandatory one is the name of the page
% style and the second one is a list of layers to be used for this page
% style. The page style itself will expand all background layers for odd
% pages in \cs{@oddhead}, all background layers for even pages on
% \cs{@evenhead}, all foreground layers for odd pages in \cs{@oddfoot}, and
% all foreground layers for even pages in \cs{@evenfoot}. This may be
% restricted by additional attributes, e.g., \Option{oneside} and
% \Option{twoside}.
%
% The optional argument may be used to define hooks. There are six named
% optional arguments to set up six hooks. And there are also \KOMAScript{}
% options for these, to define global pre-definitions. Note, that you may
% remove the global pre-definitions by emptying the local hooks. The local
% argument are named similar, but without ``\texttt{ps}'' after
% ``\texttt{on}''.
% \begin{option}{onselect}
% \changes{v3.28}{2019/11/28}{marker for \cs{ModifyLayerPageStyleOptions}}%^^A
% \begin{option}{onpsselect}
% \begin{macro}{\@ps@initialhook}
% \begin{description}
% \item[\texttt{=\meta{code}}:] executes \meta{code} whenever the
%   page style will be selected, e.g. using \Macro{pagestyle} or
%   \Macro{thispagestyle} or the low level command defining the page
%   style itself.
% \end{description}
%    \begin{macrocode}
%<*options>
\KOMA@key{onpsselect}{%
  \l@addto@macro{\@ps@initialhook}{#1}%
  \FamilyKeyStateProcessed
  \KOMA@kav@add{.scrlayer.sty}{onpsselect}{#1}%
}
%<package>\scrlayer@@add@inherited@option{onpsselect}
%<package>\newcommand*{\@ps@initialhook}{}
%<package>\KOMA@kav@add{.scrlayer.sty}{onpsselect}{}
%</options>
%<*interface&body>
\expandafter\let
  \csname KV@KOMA.\@currname.\@currext @onpsselect\endcsname\relax
\expandafter\let
  \csname KV@KOMA.\@currname.\@currext @onpsselect@default\endcsname\relax
%</interface&body>
%<*package&body>
\DefineFamilyKey[.definelayerpagestyle]{KOMAarg}{onselect}{%
  \expandafter\l@addto@macro
  \csname @ps@\scrlayer@current@pagestyle @initialhook\endcsname
  {#1}%
  \let\scr@opt@marker@initialhook\FamilyKeyStateProcssed
  \FamilyKeyStateProcessed
}
%</package&body>
%    \end{macrocode}
% \end{macro}%^^A \@ps@initialhook
% \end{option}%^^A onpsselect
% \begin{option}{onpsinit}
% \begin{macro}{\@ps@hook}
% \begin{description}
% \item[\texttt{=\meta{code}}:] executes \meta{code} whenever the
%   output of a layer stack is initialised. Note, that \meta{code} must not
%   result in any page output. Otherwise the output of the layer stack will be
%   broken!
% \end{description}
%    \begin{macrocode}
%<*options>
\KOMA@key{onpsinit}{%
  \l@addto@macro{\@ps@hook}{#1}%
  \FamilyKeyStateProcessed
  \KOMA@kav@add{.scrlayer.sty}{onpsinit}{#1}%
}
%<package>\scrlayer@@add@inherited@option{onpsinit}
%<package>\newcommand*{\@ps@hook}{}
%<package>\KOMA@kav@add{.scrlayer.sty}{onpsinit}{}
%</options>
%<*interface&body>
\expandafter\let
  \csname KV@KOMA.\@currname.\@currext @onpsinit\endcsname\relax
\expandafter\let
  \csname KV@KOMA.\@currname.\@currext @onpsinit@default\endcsname\relax
%</interface&body>
%<*package&body>
\DefineFamilyKey[.definelayerpagestyle]{KOMAarg}{oninit}{%
  \expandafter\l@addto@macro
  \csname @ps@\scrlayer@current@pagestyle @hook\endcsname
  {#1}%
  \let\scr@opt@marker@hook\FamilyKeyStateProcssed
  \FamilyKeyStateProcessed
}
%</package&body>
%    \end{macrocode}
% \end{macro}%^^A \@ps@hook
% \end{option}%^^A onpsinit
% \end{option}%^^A oninit
% \begin{option}{ononeside}
% \changes{v3.28}{2019/11/28}{marker for \cs{ModifyLayerPageStyleOptions}}%^^A
% \begin{option}{onpsoneside}
% \begin{macro}{\@ps@onesidehook}
% \begin{description}
% \item[\Option{=\meta{code}}:] executes \meta{code} after
%   \Option{oninit}'s \meta{code} whenever the output of a layer stack of a
%   page in single-side layout is initialised. Note, that \meta{code} must not
%   result in any page output. Otherwise the output of the layer stack will be
%   broken!
% \end{description}
%    \begin{macrocode}
%<*options>
\KOMA@key{onpsoneside}{%
  \l@addto@macro{\@ps@onesidehook}{#1}%
  \FamilyKeyStateProcessed
  \KOMA@kav@add{.scrlayer.sty}{onpsoneside}{#1}%
}
%<package>\scrlayer@@add@inherited@option{onpsoneside}
%<package>\newcommand*{\@ps@onesidehook}{}
%<package>\KOMA@kav@add{.scrlayer.sty}{onpsoneside}{}
%</options>
%<*interface&body>
\expandafter\let
  \csname KV@KOMA.\@currname.\@currext @onpsoneside\endcsname\relax
\expandafter\let
  \csname KV@KOMA.\@currname.\@currext @onpsoneside@default\endcsname\relax
%</interface&body>
%<*package&body>
\DefineFamilyKey[.definelayerpagestyle]{KOMAarg}{ononeside}{%
  \expandafter\l@addto@macro
  \csname @ps@\scrlayer@current@pagestyle @onesidehook\endcsname
  {#1}%
  \let\scr@opt@marker@onesidehook\FamilyKeyStateProcssed
  \FamilyKeyStateProcessed
}
%</package&body>
%    \end{macrocode}
% \end{macro}%^^A \@ps@onesidehook
% \end{option}%^^A onpsoneside
% \end{option}%^^A ononeside
% \begin{option}{ontwoside}
% \changes{v3.28}{2019/11/28}{marker for \cs{ModifyLayerPageStyleOptions}}%^^A
% \begin{option}{onpstwoside}
% \begin{macro}{\@ps@twosidehook}
% \begin{description}
% \item[\Option{=\meta{code}}:] executes \meta{code} after
%   \Option{oninit}'s \meta{code} whenever the output of a layer stack of a
%   page in two-side layout is initialised. Note, that \meta{code} must not
%   result in any page output. Otherwise the output of the layer stack will be
%   broken!
% \end{description}
%    \begin{macrocode}
%<*options>
\KOMA@key{onpstwoside}{%
  \l@addto@macro{\@ps@twosidehook}{#1}%
  \FamilyKeyStateProcessed
  \KOMA@kav@add{.scrlayer.sty}{onpstwoside}{#1}%
}
%<package>\scrlayer@@add@inherited@option{onpstwoside}
%<package>\newcommand*{\@ps@twosidehook}{}
%<package>\KOMA@kav@add{.scrlayer.sty}{onpstwoside}{}
%</options>
%<*interface&body>
\expandafter\let
  \csname KV@KOMA.\@currname.\@currext @onpstwoside\endcsname\relax
\expandafter\let
  \csname KV@KOMA.\@currname.\@currext @onpstwoside@default\endcsname\relax
%</interface&body>
%<*package&body>
\DefineFamilyKey[.definelayerpagestyle]{KOMAarg}{ontwoside}{%
  \expandafter\l@addto@macro
  \csname @ps@\scrlayer@current@pagestyle @twosidehook\endcsname
  {#1}%
  \let\scr@opt@marker@twosidehook\FamilyKeyStateProcssed
  \FamilyKeyStateProcessed
}
%</package&body>
%    \end{macrocode}
% \end{macro}%^^A \@ps@twosidehook
% \end{option}%^^A onpstwoside
% \end{option}%^^A ontwoside
% \begin{option}{onoddpage}
% \changes{v3.28}{2019/11/28}{marker for \cs{ModifyLayerPageStyleOptions}}%^^A
% \begin{option}{onpsoddpage}
% \begin{macro}{\@ps@oddpagehook}
% \begin{description}
% \item[\texttt{=\meta{code}}:] executes \meta{code} after
%   \Option{ononeside}'s or \Option{ontwoside}'s \meta{code} whenever the
%   output of a layer stack of an odd page is initialised. Note, that
%   \meta{code} must not result in any page output. Otherwise the output of
%   the layer stack will be broken!
% \end{description}
%    \begin{macrocode}
%<*options>
\KOMA@key{onpsoddpage}{%
  \l@addto@macro{\@ps@oddpagehook}{#1}%
  \FamilyKeyStateProcessed
  \KOMA@kav@add{.scrlayer.sty}{onpsoddpage}{#1}%
}
%<package>\scrlayer@@add@inherited@option{onpsoddpage}
%<package>\newcommand*{\@ps@oddpagehook}{}
%<package>\KOMA@kav@add{.scrlayer.sty}{onpsoddpage}{}
%</options>
%<*interface&body>
\expandafter\let
  \csname KV@KOMA.\@currname.\@currext @onpsoddpage\endcsname\relax
\expandafter\let
  \csname KV@KOMA.\@currname.\@currext @onpsoddpage@default\endcsname\relax
%</interface&body>
%<*package&body>
\DefineFamilyKey[.definelayerpagestyle]{KOMAarg}{onoddpage}{%
  \expandafter\l@addto@macro
  \csname @ps@\scrlayer@current@pagestyle @oddpagehook\endcsname
  {#1}%
  \let\scr@opt@marker@oddpagehook\FamilyKeyStateProcssed
  \FamilyKeyStateProcessed
}
%</package&body>
%    \end{macrocode}
% \end{macro}%^^A \@ps@oddpagehook
% \end{option}%^^A onpsoddpage
% \end{option}%^^A onoddside
% \begin{option}{onevenpage}
% \changes{v3.28}{2019/11/28}{marker for \cs{ModifyLayerPageStyleOptions}}%^^A
% \begin{option}{onpsevenpage}
% \begin{macro}{\@ps@evenpagehook}
% \begin{description}
% \item[\texttt{=\meta{code}}:] executes \meta{code} after
%   \Option{ononeside}'s or \Option{ontwoside}'s \meta{code} whenever the
%   output of a layer stack of an even page is initialised. Note, that
%   \meta{code} must not result in any page output. Otherwise the output of
%   the layer stack will be broken!
% \end{description}
%    \begin{macrocode}
%<*options>
\KOMA@key{onpsevenpage}{%
  \l@addto@macro{\@ps@evenpagehook}{#1}%
  \FamilyKeyStateProcessed
  \KOMA@kav@add{.scrlayer.sty}{onpsevenpage}{#1}%
}
%<package>\scrlayer@@add@inherited@option{onpsevenpage}
%<package>\newcommand*{\@ps@evenpagehook}{}
%<package>\KOMA@kav@add{.scrlayer.sty}{onpsevenpage}{}
%</options>
%<*interface&body>
\expandafter\let
  \csname KV@KOMA.\@currname.\@currext @onpsevenpage\endcsname\relax
\expandafter\let
  \csname KV@KOMA.\@currname.\@currext @onpsevenpage@default\endcsname\relax
%</interface&body>
%<*package&body>
\DefineFamilyKey[.definelayerpagestyle]{KOMAarg}{onevenpage}{%
  \expandafter\l@addto@macro
  \csname @ps@\scrlayer@current@pagestyle @evenpagehook\endcsname
  {#1}%
  \let\scr@opt@marker@evenpagehook\FamilyKeyStateProcssed
  \FamilyKeyStateProcessed
}
%</package&body>
%    \end{macrocode}
% \end{macro}%^^A \@ps@evenpagehook
% \end{option}%^^A onpsevenpage
% \end{option}%^^A onevenside
% \begin{option}{onfloatpage}
% \changes{v3.28}{2019/11/28}{marker for \cs{ModifyLayerPageStyleOptions}}%^^A
% \begin{option}{onpsfloatpage}
% \begin{macro}{\@ps@floatpagehook}
% \begin{description}
% \item[\Option{=\meta{code}}:] executes \meta{code} after
%   \Option{onoddpage}'s or \Option{onevenpage}'s \meta{code} whenever a float
%   column has been made (usually those pages are float pages).
% \end{description}
%    \begin{macrocode}
%<*options>
\KOMA@key{onpsfloatpage}{%
  \l@addto@macro{\@ps@floatpagehook}{#1}%
  \FamilyKeyStateProcessed
  \KOMA@kav@add{.scrlayer.sty}{onpsfloatpage}{#1}%
}
%<package>\scrlayer@@add@inherited@option{onpsfloatpage}
%<package>\newcommand*{\@ps@floatpagehook}{}
%<package>\KOMA@kav@add{.scrlayer.sty}{onpsfloatpage}{}
%</options>
%<*interface&body>
\expandafter\let
  \csname KV@KOMA.\@currname.\@currext @onpsfloatpage\endcsname\relax
\expandafter\let
  \csname KV@KOMA.\@currname.\@currext @onpsfloatpage@default\endcsname\relax
%</interface&body>
%<*package&body>
\DefineFamilyKey[.definelayerpagestyle]{KOMAarg}{onfloatpage}{%
  \expandafter\l@addto@macro
  \csname @ps@\scrlayer@current@pagestyle @floatpagehook\endcsname
  {#1}%
  \let\scr@opt@marker@floatpagehook\FamilyKeyStateProcssed
  \FamilyKeyStateProcessed
}
%</package&body>
%    \end{macrocode}
% \end{macro}%^^A \@ps@floatpagehook
% \end{option}%^^A onpsfloatpage
% \end{option}%^^A onfloatpage
% \begin{option}{onnonfloatpage}
% \changes{v3.28}{2019/11/28}{marker for \cs{ModifyLayerPageStyleOptions}}%^^A
% \begin{option}{onpsnonfloatpage}
% \begin{macro}{\@ps@nonfloatpagehook}
% \begin{description}
% \item[\Option{=\meta{code}}:] executes \meta{code} after
%   \Option{onoddpage}'s or \Option{onevenpage}'s \meta{code} whenever no
%   float column has been made (usually those pages aren't float pages).
% \end{description}
%    \begin{macrocode}
%<*options>
\KOMA@key{onpsnonfloatpage}{%
  \l@addto@macro{\@ps@nonfloatpagehook}{#1}%
  \FamilyKeyStateProcessed
  \KOMA@kav@add{.scrlayer.sty}{onpsnonfloatpage}{#1}%
}
%<package>\scrlayer@@add@inherited@option{onpsnonfloatpage}
%<package>\newcommand*{\@ps@nonfloatpagehook}{}
%<package>\KOMA@kav@add{.scrlayer.sty}{onpsnonfloatpage}{}
%</options>
%<*interface&body>
\expandafter\let
  \csname KV@KOMA.\@currname.\@currext @onpsnonfloatpage\endcsname\relax
\expandafter\let
  \csname KV@KOMA.\@currname.\@currext @onpsnonfloatpage@default\endcsname\relax
%</interface&body>
%<*package&body>
\DefineFamilyKey[.definelayerpagestyle]{KOMAarg}{onnonfloatpage}{%
  \expandafter\l@addto@macro
  \csname @ps@\scrlayer@current@pagestyle @nonfloatpagehook\endcsname
  {#1}%
  \let\scr@opt@marker@nonfloatpagehook\FamilyKeyStateProcssed
  \FamilyKeyStateProcessed
}
%</package&body>
%    \end{macrocode}
% \end{macro}%^^A \@ps@nonfloatpagehook
% \end{option}%^^A onpsnonfloatpage
% \end{option}%^^A onnonfloatpage
% \begin{option}{onbackground}
% \changes{v3.28}{2019/11/28}{marker for \cs{ModifyLayerPageStyleOptions}}%^^A
% \begin{option}{onpsbackground}
% \begin{macro}{\@ps@backgroundhook}
% \begin{description}
% \item[\texttt{=\meta{code}}:] executes \meta{code} after
%   \Option{onfloatpage}'s or \Option{onnonfloatpage}'s \meta{code} whenever
%   the output of a background layer stack is initialised. Note, that
%   \meta{code} must not result in any page output. Otherwise the output of
%   the layer stack will be broken!
% \end{description}
%    \begin{macrocode}
%<*options>
\KOMA@key{onpsbackground}{%
  \l@addto@macro{\@ps@backgroundhook}{#1}%
  \FamilyKeyStateProcessed
  \KOMA@kav@add{.scrlayer.sty}{onpsbackground}{#1}%
}
%<package>\scrlayer@@add@inherited@option{onpsbackground}
%<package>\newcommand*{\@ps@backgroundhook}{}
%<package>\KOMA@kav@add{.scrlayer.sty}{onpsbackground}{}
%</options>
%<*interface&body>
\expandafter\let
  \csname KV@KOMA.\@currname.\@currext @onpsbackground\endcsname\relax
\expandafter\let
  \csname KV@KOMA.\@currname.\@currext @onpsbackground@default\endcsname\relax
%</interface&body>
%<*package&body>
\DefineFamilyKey[.definelayerpagestyle]{KOMAarg}{onbackground}{%
  \expandafter\l@addto@macro
  \csname @ps@\scrlayer@current@pagestyle @backgroundhook\endcsname
  {#1}%
  \let\scr@opt@marker@backgroundhook\FamilyKeyStateProcssed
  \FamilyKeyStateProcessed
}
%</package&body>
%    \end{macrocode}
% \end{macro}%^^A \@ps@backgroundhook
% \end{option}%^^A onbackground
% \end{option}%^^A onbackground
% \begin{option}{onforeground}
% \changes{v3.28}{2019/11/28}{marker for \cs{ModifyLayerPageStyleOptions}}%^^A
% \begin{option}{onpsforeground}
% \begin{macro}{\@ps@foregroundhook}
% \begin{description}
% \item[\texttt{=\meta{code}}:] executes \meta{code} after
%   \Option{onfloatpage}'s or \Option{onnonfloatpage}'s \meta{code} whenever
%   the output of a foreground layer stack is initialised. Note, that
%   \meta{code} must not result in any page output. Otherwise the output of
%   the layer stack will be broken!
% \end{description}
%    \begin{macrocode}
%<*options>
\KOMA@key{onpsforeground}{%
  \l@addto@macro{\@ps@foregroundhook}{#1}%
  \FamilyKeyStateProcessed
  \KOMA@kav@add{.scrlayer.sty}{onpsforeground}{#1}%
}
%<package>\scrlayer@@add@inherited@option{onpsforeground}
%<package>\newcommand*{\@ps@foregroundhook}{}
%<package>\KOMA@kav@add{.scrlayer.sty}{onpsforeground}{}
%</options>
%<*interface&body>
\expandafter\let
  \csname KV@KOMA.\@currname.\@currext @onpsforeground\endcsname\relax
\expandafter\let
  \csname KV@KOMA.\@currname.\@currext @onpsforeground@default\endcsname\relax
%</interface&body>
%<*package&body>
\DefineFamilyKey[.definelayerpagestyle]{KOMAarg}{onforeground}{%
  \expandafter\l@addto@macro
  \csname @ps@\scrlayer@current@pagestyle @foregroundhook\endcsname
  {#1}%
  \let\scr@opt@marker@foregroundhook\FamilyKeyStateProcssed
  \FamilyKeyStateProcessed
}
%</package&body>
%    \end{macrocode}
% \end{macro}%^^A \@psforegroundhook
% \end{option}%^^A onpsforeground
% \end{option}%^^A onforeground
% \begin{option}{singlespacing}
% \changes{v3.24}{2017/05/22}{new option added}%^^A
% \begin{description}
% \item[\texttt{=\meta{simple switch}}:] if activated, all page styles will be
%   set with line spread 1. This switch is global. If you want it for some
%   styles only, add \Macro{linespread}\PParameter{1}\Macro{selectfont} to
%   option \Option{oninit} of only those styles.
%\end{description}
%    \begin{macrocode}
%<*options>
\KOMA@ifkey{singlespacing}{@ps@singlespacing}
%<package>\scrlayer@@add@inherited@option{singlespacing}
%</options>
%    \end{macrocode}
% \end{option}
%    \begin{macrocode}
%<*package&body>
\newcommand*{\DeclarePageStyleByLayers}[3][]{%
  \edef\scrlayer@current@pagestyle{\GetRealPageStyle{#2}}%
  \expandafter\scrlayer@declare@ps@by@layers\expandafter{%
    \scrlayer@current@pagestyle
  }{#1}{#3}%
}
%    \end{macrocode}
% \begin{macro}{\scrlayer@declare@ps@by@layers}
% \changes{v3.15}{2014/12/28}{fix: \cs{linewidth} replaced by
%   \cs{textwidth}}%^^A
% \changes{v3.18}{2015/06/09}{usage of \cs{parbox[b]} instead of
%   \cs{parbox[t]} because of strange effect with package
%   \textsf{multicol}}%^^A 
% \changes{v3.24}{2017/05/22}{test for \cs{if@ps@singlespacing} added}%^^A
% \changes{v3.26}{2018/08/29}{\cs{scr@trim@spaces} added}%^^A
% \changes{v3.28}{2019/11/18}{\cs{ifstr} umbenannt in \cs{Ifstr}}%^^A
% Needed, because of page style aliases. Same arguments like
% \cs{DeclarePageStyleByLayers} but, \#1 is the name of the page style, \#2 is
% the list of options and \#3 is still the list of layers.
%    \begin{macrocode}
\newcommand*{\scrlayer@declare@ps@by@layers}[3]{%
  \@namedef{@ps@#1@initialhook}{\@ps@initialhook}%
  \@namedef{@ps@#1@hook}{\@ps@hook}%
  \@namedef{@ps@#1@backgroundhook}{\@ps@backgroundhook}%
  \@namedef{@ps@#1@foregroundhook}{\@ps@foregroundhook}%
  \@namedef{@ps@#1@oddpagehook}{\@ps@oddpagehook}%
  \@namedef{@ps@#1@evenpagehook}{\@ps@evenpagehook}%
  \@namedef{@ps@#1@onesidehook}{\@ps@onesidehook}%
  \@namedef{@ps@#1@twosidehook}{\@ps@twosidehook}%
  \@namedef{@ps@#1@floatpagehook}{\@ps@floatpagehook}%
  \@namedef{@ps@#1@nonfloatpagehook}{\@ps@nonfloatpagehook}%
  \FamilyExecuteOptions[.definelayerpagestyle]{KOMAarg}{#2}%
  \@namedef{ps@#1}{%
    \renewcommand*{\currentpagestyle}{#1}%
    \@nameuse{@ps@@everystyle@@initialhook}%
    \@nameuse{@ps@#1@initialhook}%
    \renewcommand*{\currentpagestyle}{#1}%
    \renewcommand*{\@oddhead}{%
      \begingroup
        \let\headmark\rightmark
        \if@ps@singlespacing\linespread{1}\selectfont\fi
        \@nameuse{@ps@@everystyle@@hook}%
        \@nameuse{@ps@#1@hook}%
        \@nameuse{@ps@@everystyle@@\if@twoside two\else one\fi sidehook}%
        \@nameuse{@ps@#1@\if@twoside two\else one\fi sidehook}%
        \@nameuse{@ps@@everystyle@@oddpagehook}%
        \@nameuse{@ps@#1@oddpagehook}%
        \@nameuse{@ps@@everystyle@@\if@fcolmade\else non\fi floatpagehook}%
        \@nameuse{@ps@#1@\if@fcolmade\else non\fi floatpagehook}%
        \@nameuse{@ps@@everystyle@@backgroundhook}%
        \@nameuse{@ps@#1@backgroundhook}%
        \parbox[b][\headheight][t]{\textwidth}{%
          \vskip \dimexpr -\topmargin-1in
                          -\ht\strutbox\relax
          \hskip \dimexpr -\oddsidemargin-1in\relax
          \strut\makebox[\z@][l]{%
            \ForEachLayerOfPageStyle{@everystyle@}{%
              \scrlayer@do@page@style@element@layer{background}{odd}%
                                                   {########1}%
            }%
            \ForEachLayerOfPageStyle{#1}{%
              \scrlayer@do@page@style@element@layer{background}{odd}%
                                                   {########1}%
            }%
          }%
        }%
      \endgroup
    }%
    \renewcommand*{\@evenhead}{%
      \begingroup
        \let\headmark\leftmark
        \if@ps@singlespacing\linespread{1}\selectfont\fi
        \@nameuse{@ps@@everystyle@@hook}%
        \@nameuse{@ps@#1@hook}%
        \@nameuse{@ps@@everystyle@@twosidehook}%
        \@nameuse{@ps@#1@twosidehook}%
        \@nameuse{@ps@@everystyle@@evenpagehook}%
        \@nameuse{@ps@#1@evenpagehook}%
        \@nameuse{@ps@@everystyle@@\if@fcolmade\else non\fi floatpagehook}%
        \@nameuse{@ps@#1@\if@fcolmade\else non\fi floatpagehook}%
        \@nameuse{@ps@@everystyle@@backgroundhook}%
        \@nameuse{@ps@#1@backgroundhook}%
        \parbox[b][\headheight][t]{\textwidth}{%
          \vskip \dimexpr -\topmargin-1in
                          -\ht\strutbox\relax
          \hskip \dimexpr-\evensidemargin-1in\relax
          \strut\makebox[\z@][l]{%
            \ForEachLayerOfPageStyle{@everystyle@}{%
              \scrlayer@do@page@style@element@layer{background}{even}%
                                                   {########1}%
            }%
            \ForEachLayerOfPageStyle{#1}{%
              \scrlayer@do@page@style@element@layer{background}{even}%
                                                   {########1}%
            }%
          }%
        }%
      \endgroup
    }%
    \renewcommand*{\@oddfoot}{%
      \begingroup
        \let\headmark\rightmark
        \if@ps@singlespacing\linespread{1}\selectfont\fi
        \@nameuse{@ps@@everystyle@@hook}%
        \@nameuse{@ps@#1@hook}%
        \@nameuse{@ps@@everystyle@@\if@twoside two\else one\fi sidehook}%
        \@nameuse{@ps@#1@\if@twoside two\else one\fi sidehook}%
        \@nameuse{@ps@@everystyle@@oddpagehook}%
        \@nameuse{@ps@#1@oddpagehook}%
        \@nameuse{@ps@@everystyle@@\if@fcolmade\else non\fi floatpagehook}%
        \@nameuse{@ps@#1@\if@fcolmade\else non\fi floatpagehook}%
        \@nameuse{@ps@@everystyle@@foregroundhook}%
        \@nameuse{@ps@#1@foregroundhook}%
        \parbox[t][\headheight][t]{\textwidth}{%
          \vskip \dimexpr -\topmargin-1in
                          -\headheight
                          -\headsep
                          -\textheight
                          -\footskip
                          -\ht\strutbox\relax
          \hskip \dimexpr -\oddsidemargin-1in\relax
          \strut\makebox[\z@][l]{%
            \ForEachLayerOfPageStyle{@everystyle@}{%
              \scrlayer@do@page@style@element@layer{foreground}{odd}%
                                                   {########1}%
            }%
            \ForEachLayerOfPageStyle{#1}{%
              \scrlayer@do@page@style@element@layer{foreground}{odd}%
                                                   {########1}%
            }%
          }%
        }%
      \endgroup
    }%
    \renewcommand*{\@evenfoot}{%
      \begingroup
        \let\headmark\leftmark
        \if@ps@singlespacing\linespread{1}\selectfont\fi
        \@nameuse{@ps@@everystyle@@hook}%
        \@nameuse{@ps@#1@hook}%
        \@nameuse{@ps@@everystyle@@twosidehook}%
        \@nameuse{@ps@#1@twosidehook}%
        \@nameuse{@ps@@everystyle@@evenpagehook}%
        \@nameuse{@ps@#1@evenpagehook}%
        \@nameuse{@ps@@everystyle@@\if@fcolmade\else non\fi floatpagehook}%
        \@nameuse{@ps@#1@\if@fcolmade\else non\fi floatpagehook}%
        \@nameuse{@ps@@everystyle@@foregroundhook}%
        \@nameuse{@ps@#1@foregroundhook}%
        \parbox[t][\headheight][t]{\textwidth}{%
          \vskip \dimexpr -\topmargin-1in
                          -\headheight
                          -\headsep
                          -\textheight
                          -\footskip
                          -\ht\strutbox\relax
          \hskip \dimexpr-\evensidemargin-1in\relax
          \strut\makebox[\z@][l]{%
            \ForEachLayerOfPageStyle{@everystyle@}{%
              \scrlayer@do@page@style@element@layer{foreground}{even}%
                                                   {########1}%
            }%
            \ForEachLayerOfPageStyle{#1}{%
              \scrlayer@do@page@style@element@layer{foreground}{even}%
                                                   {########1}%
            }%
          }%
        }%
      \endgroup
    }%
  }%
  \@namedef{@ps@#1@layers}{}%
  \@for \reserved@a:=#3\do {%
    \scr@trim@spaces\reserved@a
    \Ifstr\reserved@a\@empty{}{%
      \expandafter\@cons\csname @ps@#1@layers\endcsname{{\reserved@a}}%
    }%
  }%
}
%</package&body>
%    \end{macrocode}
% \end{macro}%^^A \scrlayer@declare@ps@by@layers
%
% \begin{macro}{\ForEachLayerOfPageStyle}
% \changes{v3.18}{2015/05/14}{star version of the command}%^^A
% \changes{v3.20}{2016/04/12}{\cs{@ifstar} durch \cs{kernel@ifstar}
%     ersetzt}%^^A
%   \begin{description}
%   \item[\Parameter{string}:] a valid page style (must be fully expandable
%     and expand to the name of a existing page style); note, that currently
%     no exists test will be done.
%   \item[\Parameter{code}:] any macro definition body with usage of at most
%     one argument (\texttt{\#1}), that will be replaced by the layer's name
%   \end{description}
% Do the given \meta{code} for each layer of the page style
% \meta{string}. Note, that the expansion of \meta{code} will be done inside
% a group. There's also a star version of the command, that delays execution
% of \meta{code} after the end of the group.
%    \begin{macrocode}
%<*package&body>
\newcommand*{\ForEachLayerOfPageStyle}{%
  \kernel@ifstar {\@s@ForEachLayerOfPageStyle}{\@ForEachLayerOfPageStyle}%
}
\newcommand*{\@ForEachLayerOfPageStyle}[2]{%
  \begingroup
    \edef\reserved@a{\GetRealPageStyle{#1}}%
    \def\@elt##1{\ifscrlayer@deactivate@layers\else #2\fi}%
    \@nameuse{@ps@\reserved@a @layers}%
  \endgroup
}
\newcommand*{\@s@ForEachLayerOfPageStyle}[2]{%
  \begingroup
    \edef\reserved@a{\GetRealPageStyle{#1}}%
    \def\reserved@b{\endgroup}%
    \def\@elt##1{%
      \l@addto@macro\reserved@b{%
        \ifscrlayer@deactivate@layers\else #2\fi
      }%
    }%
    \@nameuse{@ps@\reserved@a @layers}%
  \reserved@b
}
%</package&body>
%    \end{macrocode}
% \begin{option}{deactivatepagestylelayers}
% \begin{macro}{\ifscrlayer@deactivate@layers}
%   \begin{description}
%   \item[\Parameter{simple switch}:] whether or not
%     \Macro{ForEachLayerOfPageStyle} should ignore the layers.
%   \end{description}
% This is a global \KOMAScript{} options.  Several other definitions and at
% least the usage of the page style will ignore the layers if
% \Macro{ForEachLayerOfPageStyle} ignores them. So this is something like:
% hide the layers. It may also be useful inside the code for the hooks
% described above, because hooks may used to deactivate the layers with this
% option too.
%    \begin{macrocode}
%<*options>
%<*package>
\KOMA@ifkey{deactivatepagestylelayers}{scrlayer@deactivate@layers}
%<package>\scrlayer@@add@inherited@option{deactivatepagestylelayers}
%</package>
%<*interface>
\KOMA@key{deactivatepagestylelayers}[true]{%
  \KOMA@set@ifkey{deactivatepagestylelayers}{scrlayer@deactivate@layers}{#1}%
  \KOMA@kav@replacebool{.scrlayer.sty}{deactivatepagestylelayers}
                       {scrlayer@deactivate@layers}%
}
%</interface>
%</options>
%<*interface&body>
\expandafter\let
  \csname KV@KOMA.\@currname.\@currext @deactivatepagestylelayers\endcsname
  \relax
\expandafter\let
  \csname KV@KOMA.\@currname.\@currext @deactivatepagestylelayers@default\endcsname
  \relax
%</interface&body>
%    \end{macrocode}
% \end{macro}%^^A \ifscrlayer@deactivate@layers
% \end{option}%^^A deactivatepagestylelayers
% \end{macro}%^^A \ForEachLayerOfPageStyle
%
% \begin{macro}{\scrlayer@do@page@style@element@layer}
% \changes{v3.26}{2018/07/14}{added hooks and artifact code}%^^A
% Helper macro to show one layer. First argument is either ``background'' or
% ``foreground'', second argument is either ``odd'' or ``even'', and third
% argument is the name of the layer. Note, that in draft mode for every layer
% will be shown also a \cs{layercontentsmeasure}.
%    \begin{macrocode}
%<*package&body>
\newcommand*{\scrlayer@do@page@style@element@layer}[3]{%
  \begingroup
    \expandafter\ifx\csname if@scr@l@#3@\if@fcolmade\else non\fi floatpage%
                    \expandafter\endcsname\csname iftrue\endcsname
      \expandafter\ifx\csname if@scr@l@#3@\if@twoside two\else one\fi side%
                      \expandafter\endcsname\csname iftrue\endcsname
        \expandafter
        \ifx\csname if@scr@l@#3@#1\expandafter\endcsname
            \csname iftrue\endcsname
          \expandafter
          \ifx\csname if@scr@l@#3@#2\expandafter\endcsname
              \csname iftrue\endcsname
            \ifscrlayer@draft
              \scr@layerbox(\csname scr@l@#3@x\endcsname,%
                            \csname scr@l@#3@y\endcsname)%
                           (\csname scr@l@#3@w\endcsname,%
                            \csname scr@l@#3@h\endcsname)%
                           [\csname scr@l@#3@align\endcsname]%
                           {%
                             \scrlayer@predraftmeasure@hook
                             \scrlayer@beginartifact{}%
                             \layercontentsmeasure
                             \scrlayer@endartifact{}%
                             \scrlayer@postdraftmeasure@hook
                           }%
            \fi
            \scr@layerbox(\csname scr@l@#3@x\endcsname,%
                          \csname scr@l@#3@y\endcsname)%
                         (\csname scr@l@#3@w\endcsname,%
                          \csname scr@l@#3@h\endcsname)%
                         [\csname scr@l@#3@align\endcsname]%
                         {\csname layer\csname scr@l@#3@mode\endcsname 
                                  mode\expandafter\endcsname{%
                             \csname scr@l@#3@precontents@hook\endcsname
                             \scr@ifundefinedorrelax{scr@l@#3@artifact}{}{%
                               \expandafter\expandafter\expandafter
                               \scrlayer@beginartifact
                               \expandafter\expandafter\expandafter{%
                                 \csname scr@l@#3@artifact\endcsname
                               }%
                               \csname scr@l@#3@contents\endcsname
                               \expandafter\expandafter\expandafter
                               \scrlayer@endartifact
                               \expandafter\expandafter\expandafter{%
                                 \csname scr@l@#3@artifact\endcsname
                               }%
                             }{%
                               \csname scr@l@#3@contents\endcsname
                             }%
                             \csname scr@l@#3@postcontents@hook\endcsname
                           }%
                         }%     
          \fi
        \fi
      \fi
    \fi
  \endgroup
}
%    \end{macrocode}
% \begin{macro}{\scrlayer@predraftmeasure@hook}
% \changes{v3.26}{2018/07/14}{new (internal)}%^^A
% The hooks that will be executed before setting the draft measuring.
%    \begin{macrocode}
\newcommand*{\scrlayer@predraftmeasure@hook}{}
%    \end{macrocode}
% \begin{macro}{\BeforeDraftMeasuringLayer}
% \changes{v3.26}{2018/07/14}{new}%^^A
% New code will be added in front of the hook.
%    \begin{macrocode}
\newcommand*{\BeforeDraftMeasuringLayer}[1]{%
  \edef\scrlayer@predraftmeasure@hook{%
    \unexpanded{#1}\unexpanded\expandafter{\scrlayer@predraftmeasure@hook}%
  }%
}
%    \end{macrocode}
% \end{macro}%^^A \BeforeDraftMeasuringLayer
% \end{macro}%^^A \scrlayer@predraftmeasure@hook
% \begin{macro}{\scrlayer@postdraftmeasure@hook}
% \changes{v3.26}{2018/07/14}{new (internal)}%^^A
% The hook that will be executed after setting the draft measuring.
%    \begin{macrocode}
\newcommand*{\scrlayer@postdraftmeasure@hook}{}
%    \end{macrocode}
% \begin{macro}{\AfterDraftMeasuringLayer}
% \changes{v3.26}{2018/07/14}{new}%^^A
% New code will be added at the end of the hook.
%    \begin{macrocode}
\newcommand*{\AfterDraftMeasuringLayer}[1]{%
  \expandafter\def\expandafter\scrlayer@postdraftmeasure@hook\expandafter{%
    \scrlayer@postdraftmeasure@hook #1%
  }%
}
%    \end{macrocode}
% \end{macro}%^^A \AfterDraftMeasuringLayer
% \end{macro}%^^A \scrlayer@postdraftmeasure@hook
% \begin{macro}{\scr@layerbox}
% \changes{v3.20}{2016/04/12}{\cs{@ifnextchar} replaced by
%     \cs{kernel@ifnextchar}}%^^A
% \begin{macro}{\scr@@layerbox}
% \changes{v3.24}{2017/05/08}{\cs{edef} replaced by \cs{protected@edef}}%^^A
% \changes{v3.24}{2017/05/08}{\cs{dimexpr} added to \cs{layer\dots}}%^^A
% \changes{v3.24}{2017/05/08}{\cs{dimexpr} removed from usage of
%   \cs{layer\dots}}%^^A
% The layer box is used to output a layer in \cs{@oddhead}, \cs{@evenhead},
% \cs{@oddfoot}, or \cs{@evenfoot}. Is has two pairs of arguments: ($x,y$)
% and ($w,h$), where $x$ is the distance from left paper edge, $y$ is the
% distance from the topmost edge of paper, $w$ is the width of the box and $h$
% is the height of the box. The fifth argument is an optional vertical and
% horizontal alignment of the box. It may be a combination of the alignment
% characters described above. The sixth and last argument is the contents of
% the layer, to be placed into the last argument of the innermost
% \cs{parbox}.
%    \begin{macrocode}
\def\scr@layerbox(#1,#2)(#3,#4){%
  \kernel@ifnextchar [%]
  {\scr@@layerbox(#1,#2)(#3,#4)}{\scr@@layerbox(#1,#2)(#3,#4)[]}%
}
\def\scr@@layerbox(#1,#2)(#3,#4)[#5]#6{%
  \begingroup
    \protected@edef\layerxoffset{\noexpand\dimexpr #1\relax}%
    \protected@edef\layeryoffset{\noexpand\dimexpr #2\relax}%
    \protected@edef\layerwidth{\noexpand\dimexpr #3\relax}%
    \protected@edef\layerheight{\noexpand\dimexpr #4\relax}%
    \def\layervalign{t}%
    \def\layerhalign{l}%
    \edef\reserved@b{#5}%
    \expandafter\@tfor\expandafter\reserved@a\expandafter:\expandafter=%
    \reserved@b\do{%
      \if t\reserved@a
        \def\layervalign{t}%
      \else
        \if c\reserved@a
          \def\layervalign{c}%
          \def\layerhalign{c}%
        \else
          \if b\reserved@a
            \def\layervalign{b}%
          \else
            \if l\reserved@a
              \def\layerhalign{l}%
            \else
              \if r\reserved@a
                \def\layerhalign{r}%
              \else
                \PackageWarning{scrlayer}{%
                  Unknown alignment `\reserved@a' ignored}%
              \fi
            \fi
          \fi
        \fi
      \fi
    }%
    \parbox[t][\z@][t]{\z@}{%
      \vskip\layeryoffset
      \if b\layervalign\vskip-\layerheight\fi
      \if c\layervalign\vskip-.5\layerheight\fi
%    \end{macrocode}
% \changes{3.23a}{2017/04/22}{\textsf{bidi} code added}%^^A
% \changes{v3.24}{2017/05/04}{usage of \textsf{scrbase}'s \cs{IfRTL}}%^^A
% If we are in right-to-left mode of package \textsf{bidi} or
% \textsf{xepersian} the horizontal output is in the opposite direction. So we
% need the \cs{makebox} to the right instead of the left and to move the
% contents additionally by its width.
%    \begin{macrocode}
      \makebox[\z@][\IfRTL{r}{l}]{%
        \hskip\layerxoffset
        \IfRTL{\hskip\layerwidth}{}%
        \makebox[\z@][\layerhalign]{%
          \parbox[\layervalign][\layerheight][\layervalign]{\layerwidth}{%
            \vskip\z@\strut{%
              \ifscrlayer@forceignoreuppercase
                \expandafter\let\csname MakeUppercase \endcsname\@firstofone
                \let\MakeUppercase\@firstofone
                \let\uppercase\@firstofone
              \fi
              #6%
            }\strut\vskip\z@
          }%
        }%
      }%
    }%
  \endgroup
}
%</package&body>
%    \end{macrocode}
% \end{macro}%^^A \scr@@layerbox
% \end{macro}%^^A \scr@layerbox
%
% \begin{macro}{\layerrawmode}
% \changes{v3.19}{2015/07/30}{new command}%^^A
% \begin{macro}{\layertextmode}
% \changes{v3.19}{2015/07/30}{new command}%^^A
% This is the command to output layers in raw mode. This is very simple:
%    \begin{macrocode}
%<*package&body>
\newcommand{\layerrawmode}[1]{#1}
\newcommand{\layertextmode}[1]{#1}
%</package&body>
%    \end{macrocode}
% \end{macro}%^^A \layertextmode
% \end{macro}%^^A \layerrawmode
%
% \begin{macro}{\layerpicturemode}
% \changes{v3.19}{2015/07/30}{new command}%^^A
% \changes{v3.24}{2017/05/08}{redundant \cs{dimexpr} removed}%^^A
% This is a bit more complicated. It is the layer output for \texttt{picture}
% layers. In this case we use a picture environment and internally define some
% additional commands.
%    \begin{macrocode}
%<*package&body>
\newcommand{\layerpicturemode}[1]{%
  \begin{picture}(0,0)
             (0,\LenToUnit{%
               \if t\layervalign \dimexpr\layerheight-\ht\strutbox\relax
               \else
                 \if b\layervalign \dp\strutbox
                 \else .5\dimexpr\layerheight-\ht\strutbox+\dp\strutbox\relax
                 \fi
               \fi})
    \long\def\putLL##1{\put(0,0){##1}}%
    \long\def\putUL##1{\put(0,\LenToUnit{\layerheight}){##1}}%
    \long\def\putLR##1{\put(\LenToUnit{\layerwidth},0){##1}}%
    \long\def\putUR##1{\put(\LenToUnit{\layerwidth},%
                                \LenToUnit{\layerheight}){##1}}%
    \long\def\putC##1{\put(\LenToUnit{.5\layerwidth},%
                           \LenToUnit{.5\layerheight}){##1}}%
    #1%
  \end{picture}%
}
%</package&body>
%    \end{macrocode}
% \end{macro}%^^A \layerpicturemode
% 
% \begin{option}{draft}
% \begin{macro}{\ifscrlayer@draft}
%   \begin{description}
%   \item[\Parameter{simple switch}:] whether or not to use the draft mode,
%     that, i.e., activates visualisation of the layers.
%   \end{description}
% When option is set, every layer is shown twice: one time with it's own
% contents and one time with contents \Macro{layercontentsmeasure}.
%    \begin{macrocode}
%<*options>
%<*package>
\KOMA@ifkey{draft}{scrlayer@draft}
%<package>\scrlayer@@add@inherited@option{draft}
%</package>
%<*interface>
\KOMA@key{draft}[true]{%
  \KOMA@set@ifkey{draft}{scrlayer@draft}{#1}%
  \KOMA@kav@replacebool{.scrlayer.sty}{draft}{scrlayer@draft}%
}
%</interface>
%</options>
%<*interface&body>
\expandafter\let
  \csname KV@KOMA.\@currname.\@currext @draft\endcsname\relax
\expandafter\let
  \csname KV@KOMA.\@currname.\@currext @draft@default\endcsname\relax
%</interface&body>
%    \end{macrocode}
% \end{macro}%^^A \ifscrlayer@draft
% \end{option}%^^A draft
% \end{macro}%^^A \scrlayer@do@page@style@element@layer
% \end{macro}%^^A \DeclarePageStyleByLayers
%
%
% \begin{macro}{\DeclareNewPageStyleByLayers}
% Arguments like \Macro{DeclarePageStyleByLayers}; results in error if the page
% style has been defined (or declared) already.
% \begin{macro}{\ProvidePageStyleByLayers}
% Arguments like \Macro{DeclarePageStyleByLayers}; doesn't define anything it
% the page style has been defined (or declared) already.
% \begin{macro}{\RedeclarePageStyleByLayers}
% Arguments like \Macro{DeclarePageStyleByLayers}; results in error if the page
% style hasn't been defined (or declared) already.
%    \begin{macrocode}
%<*package&body>
\newcommand*{\DeclareNewPageStyleByLayers}[2][]{%
  \@ifundefined{ps@#2}{}{%
    \PackageError{scrlayer}{%
      Page style `#2' already defined%
    }{%
      You may use \string\DeclareNewPageStyleByLayers\space to declare a new
      page style only\MessageBreak
      if that page style hasn't been declared or defined before.\MessageBreak
      You may use either \string\ProvidePageStyleByLayers\space to declare the
      page style only\MessageBreak
      if it hasn't been declared or defined before, or
      \string\RedeclarePageStyleByLayers\MessageBreak
      to overwrite the former
      declaration or definition of the page style%
      \@ifundefined{@ps@#2@layers}{}{,\MessageBreak
        or \string\AddLayersToPageStyle\space to add further layers to the
        already declared\MessageBreak
        page style, or \string\RemoveLayersFromPageStyle\space to remove
        layers from the\MessageBreak
        already declared page style}.\MessageBreak
      Nevertheless, if you'll continue, the page style will be
      overwritten\MessageBreak
      by the new declaration.%
    }%
  }%
  \DeclarePageStyleByLayers[{#1}]{#2}%
}
\newcommand*{\ProvidePageStyleByLayers}[3][]{%
  \@ifundefined{ps@#2}{%
    \DeclarePageStyleByLayers[{#1}]{#2}{#3}%
  }{%
%<*trace>
    \PackageInfo{scrlayer}{%
      \string\ProvidePageStyleByLayers{#2}{#3} ignored,\MessageBreak
      because page style `#2'\MessageBreak
      already exists%
    }%
%</trace>
  }%
}
\newcommand*{\RedeclarePageStyleByLayers}[2][]{%
  \@ifundefined{ps@#2}{%
    \PackageError{scrlayer}{%
      Page style `#2' not yet defined%
    }{%
      You may use \string\RedeclarePageStyleByLayers\space to declare a page
      style only\MessageBreak
      if that page style has already been declared or defined.\MessageBreak
      You may use either \string\DeclareNewPageStyleByLayers,
      \string\DeclarePageStyleByLayers,\MessageBreak
      or \string\ProvidePageStyleByLayers\space to declare that not yet
      defined page style.\MessageBreak
      Nevertheless, if you'll continue, the page style will be declared.%
    }%
  }{}%
  \DeclarePageStyleByLayers[{#1}]{#2}%
}
%</package&body>
%    \end{macrocode}
% \end{macro}%^^A \RedeclarePageStyleByLayers
% \end{macro}%^^A \ProvidePageStyleByLayers
% \end{macro}%^^A \DeclareNewPageStyleByLayers
%
% We also declare page style \Pagestyle{@everystyle@} by default. You should
% not use this page style as an real page style (even not as the empty
% one). The layers of this page style will be used by every other layer page
% style. An we re-declare \Pagestyle{empty} to be a layer page style.
%    \begin{macrocode}
%<*package&final>
\DeclareNewPageStyleByLayers{@everystyle@}{}
\RedeclarePageStyleByLayers{empty}{}
%</package&final>
%    \end{macrocode}
%
% \begin{macro}{\AddLayersToPageStyle}
% \changes{v3.26}{2018/08/29}{\cs{scr@trim@spaces} added}%^^A
% \changes{v3.28}{2019/11/18}{\cs{ifstr} umbenannt in \cs{Ifstr}}%^^A
% \begin{macro}{\AddLayersAtBeginOfPageStyle}
% \begin{macro}{\AddLayersAtEndOfPageStyle}
% \begin{macro}{\RemoveLayersFromPageStyle}
% \changes{v3.26}{2018/08/29}{\cs{scr@trim@spaces} added}%^^A
% \changes{v3.28}{2019/11/18}{\cs{ifstr} umbenannt in \cs{Ifstr}}%^^A
%   \begin{description}
%   \item[\Parameter{string}:] the name of the page style to be modified (must
%     be expandable and result in a string).
%   \item[\Parameter{string list}:] comma separated list of layer names (must
%     be expandable and result in strings); first in the list will be added
%     first.
%   \end{description}
% Change the layer list of a given page style. The differences between the
% commands are:
% \begin{description}
% \item[\Macro{AddLayersToPageStyle}:] first in the \meta{string list} will
%   be added first at the end.
% \item[\Macro{AddLayersAtBeginOfPageStyle}:] first in the \meta{string list}
%   will be added first at the start.  Note, that this will result in changing
%   the order of the layers in \meta{string list}.
% \item[\Macro{AddLayerAtEndOfPageStyle}:] same like
%   \Macro{AddLayerToPageStyle}.
% \item[\Macro{RemoveLayersFromPageStyle}:] remove the layers from the page
%   style's layer list.
% \end{description}
%    \begin{macrocode}
%<*package&body>
\newcommand*{\AddLayersToPageStyle}[2]{%
  \edef\reserved@b{\GetRealPageStyle{#1}}%
  \IfLayerPageStyleExists{\reserved@b}{%
    \@for \reserved@a:=#2\do {%
      \scr@trim@spaces\reserved@a
      \Ifstr\reserved@a\@empty{}{%
        \expandafter\@cons\csname @ps@\reserved@b @layers\endcsname
        {{\reserved@a}}%
      }%
    }%
  }{%
    \scrlayer@lpm@error{#1}{adding layers}%
  }%
}
\newcommand*{\AddLayersAtEndOfPageStyle}{%
  \AddLayersToPageStyle
}
\newcommand*{\AddLayersAtBeginOfPageStyle}[2]{%
  \begingroup
    \let\@cons\@snoc
    \AddLayersToPageStyle{#1}{#2}%
  \endgroup
}
%    \end{macrocode}
% \begin{macro}{\@snoc}
% \cs{@snoc} is a helper macro similar to \cs{@cons} from \LaTeX{} kernel, but
% it appends at the front instead of the end.
%    \begin{macrocode}
\newcommand*{\@snoc}[2]{%
  \begingroup\let\@elt\relax\xdef#1{\@elt #2#1}\endgroup
}
%    \end{macrocode}
% \end{macro}%^^A \@snoc
%    \begin{macrocode}
\newcommand*{\RemoveLayersFromPageStyle}[2]{%
  \edef\reserved@b{\GetRealPageStyle{#1}}%
  \IfLayerPageStyleExists{#1}{%
    \@for \reserved@a:=#2\do {%
      \scr@trim@spaces\reserved@a
      \Ifstr\reserved@a\@empty{}{%
        \expandafter\remove@layer@from@page@style\expandafter{\reserved@a}%
        {\reserved@b}%
      }%
    }%
  }{%
    \scrlayer@lpm@error{#1}{removing layers}%
  }%
}
%    \end{macrocode}
% \begin{macro}{\remove@layer@from@page@style}
% \changes{v0.9}{2014/07/25}{cleaning of layer list must be global}
% \changes{v3.28}{2019/11/18}{\cs{ifstr} umbenannt in \cs{Ifstr}}%^^A
% Helper macro to remove exactly one layer (arg 1) from a page style (arg 2).
%    \begin{macrocode}
\newcommand*{\remove@layer@from@page@style}[2]{%
  \begingroup
    \expandafter\let\expandafter\reserved@a\csname @ps@#2@layers\endcsname
    \expandafter\global\expandafter\let\csname @ps@#2@layers\endcsname\@empty
    \def\@elt##1{%
      \Ifstr{#1}{##1}{}{%
        \expandafter\@cons\csname @ps@#2@layers\endcsname{{##1}}%
      }%
    }\reserved@a
  \endgroup
}
%    \end{macrocode}
% \end{macro}%^^A \remoce@layer@from@page@style
% \begin{macro}{\scrlayer@lpm@error}
%   \begin{description}
%   \item[\Parameter{string}:] the name of the page style to be modified (must
%     be expandable and result in a string).
%   \item[\Parameter{string}:] the kind of modification, that isn't allowed
%     (must be expandable and result in a string).
%   \end{description}
% Show an error because of page style it either not a defined or not a layer
% page style.
%    \begin{macrocode}
\newcommand*{\scrlayer@lpm@error}[2]{%
  \PackageError{scrlayer}{`#1' is not a layer page style}{%
    \scr@ifundefinedorrelax{ps@#1}{%
      Page style `#1' is not defined,
    }{%
      Page style `#1' is not a layer page style,
    }%
    but #2\MessageBreak
    may be used only for layer page styles declared using\MessageBreak
    \string\DeclarePageStyleByLayers,
    \string\DeclareNewPageStyleByLayers,\MessageBreak
    of \string\ProvidePageStyleByLayers.\MessageBreak
    If you'll continue, your operation will be ignored.%
  }%
}
%</package&body>
%    \end{macrocode}
% \end{macro}%^^A \scrlayer@lpm@error
% \end{macro}%^^A \RemoveLayersFromPageStyle
% \end{macro}%^^A \AddLayersAtEndOfPageStyle
% \end{macro}%^^A \AddLayersAtBeginOfPageStyle
% \end{macro}%^^A \AddLayersToPageStyle
%
% \begin{macro}{\AddLayersToPageStyleBeforeLayer}
% \changes{v3.26}{2018/08/29}{\cs{scr@trim@spaces} added}%^^A
% \changes{v3.28}{2019/11/18}{\cs{ifstr} umbenannt in \cs{Ifstr}}%^^A
% \begin{macro}{\AddLayersToPageStyleAfterLayer}
% \changes{v3.28}{2019/11/18}{\cs{ifstr} umbenannt in \cs{Ifstr}}%^^A
% \changes{v3.26}{2018/08/29}{\cs{scr@trim@spaces} added}%^^A
%   \begin{description}
%   \item[\Parameter{string}:] the name of the page style to be modified (must
%     be expandable and result in a string).
%   \item[\Parameter{string list}:] comma separated list of layer names (must
%     be expandable and result in strings); first in the list will be added
%     first.
%   \item[\Parameter{string}:] the name of the layer before
%     (\Macro{AddLayersToPageStyleBeforeLayer}) or after
%     (\Macro{AddLayersToPageStyleAfterLayer}) that the layers of the list
%     should be added.
%   \end{description}
% Note: If the layer from third argument is not part of the page style's layer
% list, the new layers won't be added anywhere.
%    \begin{macrocode}
%<*package&body>
\newcommand*{\AddLayersToPageStyleAfterLayer}[3]{%
  \edef\reserved@b{\GetRealPageStyle{#1}}%
  \IfLayerPageStyleExists{\reserved@b}{%
    \begingroup
      \expandafter\let\expandafter\reserved@a
      \csname @ps@\reserved@b @layers\endcsname
      \@namedef{@ps@\reserved@b @layers}{}%
      \def\@elt##1{%
        \Ifstr{##1}\@empty{}{%
          \expandafter\@cons\csname @ps@\reserved@b @layers\endcsname{{##1}}%
          \Ifstr{##1}{#3}{%
            \@for \reserved@a:=#2\do {%
              \scr@trim@spaces\reserved@a
              \Ifstr\reserved@a\@empty{}{%
                \expandafter\@cons\csname @ps@\reserved@b @layers\endcsname
                {{\reserved@a}}%
              }%
            }%
          }{}%
        }%
      }%
      \reserved@a
    \endgroup
  }{%
    \scrlayer@lpm@error{#1}{adding layers}%
  }%
}
\newcommand*{\AddLayersToPageStyleBeforeLayer}[3]{%
  \edef\reserved@b{\GetRealPageStyle{#1}}%
  \IfLayerPageStyleExists{\reserved@b}{%
    \begingroup
      \expandafter\let\expandafter\reserved@a
      \csname @ps@\reserved@b @layers\endcsname
      \@namedef{@ps@\reserved@b @layers}{}%
      \def\@elt##1{%
        \Ifstr{##1}\@empty{}{%
          \Ifstr{##1}{#3}{%
            \@for \reserved@a:=#2\do {%
              \scr@trim@spaces\reserved@a
              \Ifstr\reserved@a\@empty{}{%
                \expandafter\@cons\csname @ps@\reserved@b @layers\endcsname
                {{\reserved@a}}%
              }%
            }%
          }{}%
          \expandafter\@cons\csname @ps@#1@layers\endcsname{{##1}}%
        }%
      }%
      \reserved@a
    \endgroup
  }{%
    \scrlayer@lpm@error{#1}{adding layers}%
  }%
}
%</package&body>
%    \end{macrocode}
% \end{macro}%^^A \AddLayersToPageStyleAfterLayer
% \end{macro}%^^A \AddLayersToPageStyleBeforeLayer
%
%
% \begin{macro}{\UnifyLayersAtPageStyle}
% \changes{v3.28}{2019/11/18}{\cs{ifstr} umbenannt in \cs{Ifstr}}%^^A
%   \begin{description}
%   \item[\Parameter{string}:] the name of the page style to be unified (must
%     be expandable and result in a string).
%   \end{description}
% Remove doublets of layers from a page style.
%    \begin{macrocode}
%<*package&body>
\newcommand*{\UnifyLayersAtPageStyle}[1]{%
  \edef\reserved@b{\GetRealPageStyle{#1}}%
  \IfLayerPageStyleExists{\reserved@b}{%
    \expandafter\let\expandafter\reserved@a
    \csname @ps@\reserved@b @layers\endcsname
    \@namedef{@ps@\reserved@b @layers}{}%
    \begingroup
      \def\@elt##1{%
        \Ifstr{##1}\@empty{}{%
          \remove@layer@from@page@style{##1}{\reserved@b}%
          \expandafter\@cons\csname @ps@\reserved@b @layers\endcsname{{##1}}%
        }%
      }%
      \reserved@a
    \endgroup
  }{%
    \scrlayer@lpm@error{#1}{unifying}%
  }%
}
%</package&body>
%    \end{macrocode}
% \end{macro}%^^A \UnifyLayersAtPageStyle
%
% \begin{macro}{\ModifyLayerPageStyleOptions}
% \begin{macro}{\AddToLayerPageStyleOptions}
%   \begin{description}
%   \item[\Parameter{string}:] the name of the page style to be modified (must
%     be expandable and result in a string).
%   \item[\Parameter{option list}:] comma separated list of named page
%     style options.  You may use any of the options provided for
%     \Macro{DeclarePageStyle}.
%   \end{description}
% \Macro{ModifyLayerPageStyleOptions} replaces the options and only the
% options from the list by their new
% values. \Macro{AddToLayerPageStyleOptions} adds the new values to the
% already given.
%    \begin{macrocode}
%<*package&body>
\newcommand*{\ModifyLayerPageStyleOptions}[2]{%
  \edef\reserved@a{\GetRealPageStyle{#1}}%
  \IfLayerPageStyleExists{#1}{%
    \expandafter\scrlayer@modify@layer@ps@options\expandafter{%
      \reserved@a
    }{#2}%
  }{%
    \scrlayer@lpm@error{#1}{modifying}%
  }%
}
%    \end{macrocode}
% \begin{macro}{\scrlayer@modify@layer@ps@options}
% \changes{v3.28}{2019/11/28}{usage of marker makros}%^^A
% Helper needed because of alias page styles. Same parameters like
% \cs{ModifyLayerPageStyleOptions}
%    \begin{macrocode}
\newcommand*{\scrlayer@modify@layer@ps@options}[2]{%
  \begingroup
    \def\scrlayer@current@pagestyle{#1}%
    \@namedef{@ps@#1@initialhook}{}%
    \@namedef{@ps@#1@hook}{}%
    \@namedef{@ps@#1@backgroundhook}{}%
    \@namedef{@ps@#1@foregroundhook}{}%
    \@namedef{@ps@#1@oddpagehook}{}%
    \@namedef{@ps@#1@evenpagehook}{}%
    \@namedef{@ps@#1@onesidehook}{}%
    \@namedef{@ps@#1@twosidehook}{}%
    \@namedef{@ps@#1@floatpagehook}{}%
    \@namedef{@ps@#1@nonfloatpagehook}{}%
    \let\scr@opt@marker@initialhook\@empty
    \let\scr@opt@marker@hook\@empty
    \let\scr@opt@marker@backgroundhook\@empty
    \let\scr@opt@marker@foregroundhook\@empty
    \let\scr@opt@marker@oddpagehook\@empty
    \let\scr@opt@marker@evenpagehook\@empty
    \let\scr@opt@marker@onesidehook\@empty
    \let\scr@opt@marker@twosidehook\@empty
    \let\scr@opt@marker@floatpagehook\@empty
    \let\scr@opt@marker@nonfloatpagehook\@empty
    \FamilyExecuteOptions[.definelayerpagestyle]{KOMAarg}{#2}%
    \def\reserved@a{\endgroup}%
    \def\@sls@##1{%
      \expandafter\ifx \csname scr@opt@marker@##1hook\endcsname\@empty\else
        \expandafter\let\expandafter\reserved@b\csname @ps@#1@##1hook\endcsname
        \l@addto@macro\reserved@a{\@namedef{@ps@#1@##1hook}}%
        \expandafter\l@addto@macro\expandafter\reserved@a\expandafter{%
          \expandafter{%
            \reserved@b
          }%
        }%
      \fi
    }%
    \@sls@{initial}%
    \@sls@{}%
    \@sls@{background}%
    \@sls@{foreground}%
    \@sls@{oddpage}%
    \@sls@{evenpage}%
    \@sls@{oneside}%
    \@sls@{twoside}%
    \@sls@{floatpage}%
    \@sls@{nonfloatpage}%
  \reserved@a
}
%    \end{macrocode}
% \end{macro}%^^A \scrlayer@modify@layer@ps@options
%    \begin{macrocode}
\newcommand*{\AddToLayerPageStyleOptions}[2]{%
  \IfLayerPageStyleExists{#1}{%
    \def\scrlayer@current@pagestyle{#1}%
    \FamilyExecuteOptions[.definelayerpagestyle]{KOMAarg}{#2}%
  }{%
    \scrlayer@lpm@error{#1}{modifying}%
  }%
}        
%</package&body>
%    \end{macrocode}
% \end{macro}%^^A \AddToLayerPageStyleOptions
% \end{macro}%^^A \ModifyLayerPageStyleOptions
%
% \begin{macro}{\scrlayer@beginartifact}
% \changes{v3.26}{2018/07/14}{new (semi internal)}%^^A
% \begin{macro}{\scrlayer@endartifact}
% \changes{v3.26}{2018/07/14}{new (semi internal)}%^^A
% These macros are reserved for tagging packages. The first one is executed
% after the initial contents hook, the last one is executed after the final
% contents hook. Both executions are done only, if the \texttt{artifact}
% option of the layer has been used an was not boolean false. With boolean
% true the argument will be empty. All other values will be passed as
% argument.
%
% In case of package \textsf{tagpdf} the following definition would be
% usefull (here automatically done after loading the package, if the package
% does not do its own definitions):
%    \begin{macrocode}
%<*package&body>
\RequirePackage{scrlfile}
\BeforePackage{tagpdf}{%
%    \end{macrocode}
% Deactivation of the two commands before loading \textsf{tagpdf}, so that
% after loading the package \cs{providecommand} can be used to do a new
% default definition.
%    \begin{macrocode}
  \let\scrlayer@beginartifact\relax
  \let\scrlayer@endartifact\relax
}
\AfterPackage*{tagpdf}{%
  \providecommand*{\scrlayer@beginartifact}[1]{%
    \Ifstr{#1}{}{%
      \tagmcbegin{artifact}%
    }{%
      \tagmcbegin{artifact=#1}%
    }%
  }%
  \providecommand*{\scrlayer@endartifact}[1]{%
    \tagmcend
  }%
}
%    \end{macrocode}
% But the default definition (if \textsf{tagpdf} has not already been loaded)
% are simple dummies:
%    \begin{macrocode}
\providecommand*{\scrlayer@beginartifact}[1]{}
\providecommand*{\scrlayer@endartifact}[1]{}
%</package&body>
%    \end{macrocode}
% \end{macro}%^^A \scrlayer@endartifact
% \end{macro}%^^A \scrlayer@beginartifact
%
% \begin{macro}{\DeclarePageStyleAlias}
% \begin{macro}{\DeclareNewPageStyleAlias}
% \begin{macro}{\ProvidePageStyleAlias}
% \begin{macro}{\RedeclarePageStyleAlias}
%   \begin{description}
%   \item[\Parameter{string}:] The name of the page style to be declared
%     (must be expandable and result in a string).
%   \item[\Parameter{string}:] The name of the existing page style
%     (must be expandable and result in a string).
%   \end{description}
%    \begin{macrocode}
%<*package&body>
\newcommand*{\DeclarePageStyleAlias}[2]{%
  \edef\reserved@a{\GetRealPageStyle{#2}}%
  \scr@ifundefinedorrelax{ps@\reserved@a}{%
    \PackageError{scrlayer}{unknown real page style `#2'}{%
      You've tried to declare an alias for page style `#2',\MessageBreak
      but the real page style of `#2' is undefined.\MessageBreak
      You can define aliases, only if the real page style has been
      defined.\MessageBreak
      If you'll continue, the declaration will be ignored.%
    }%
    \DestroyRealLayerPageStyle{#1}%
    \DestroyLayerAlias{#1}%
  }{%
    \@namedef{@ps@#1@alias}{#2}%
    \@namedef{ps@#1}{\pagestyle{\@nameuse{@ps@#1@alias}}}%
  }%
}
\newcommand*{\DeclareNewPageStyleAlias}[1]{%
  \@ifundefined{ps@#1}{}{%
    \PackageError{scrlayer}{%
      Page style `#1' already defined%
    }{%
      You may use \string\DeclareNewPageStyleAlias\space to declare a new
      page style only\MessageBreak
      if that page style hasn't been declared or defined before.\MessageBreak
      You may use either \string\ProvidePageStyleAlias\space to declare the
      page style only\MessageBreak
      if it hasn't been declared or defined before, or
      \string\RedeclarePageStyleAlias\MessageBreak
      to overwrite the former declaration or definition of the page
      style\MessageBreak
      Nevertheless, if you'll continue, the page style will be
      overwritten\MessageBreak
      by the new alias.%
    }%
  }%
  \DeclarePageStyleAlias{#1}%
}
\newcommand*{\ProvidePageStyleAlias}[2]{%
  \@ifundefined{ps@#1}{%
    \DeclarePageStyleAlias{#1}{#2}%
  }{%
%<*trace>
    \PackageInfo{scrlayer}{%
      \string\ProvidePageStyleAlias{#1}{#2} ignored,\MessageBreak
      because page style `#1' already\MessageBreak
      exists%
    }%
%</trace>
  }%
}
\newcommand*{\RedeclarePageStyleAlias}[1]{%
  \@ifundefined{ps@#1}{%
    \PackageError{scrlayer}{%
      Page style `#1' not yet defined%
    }{%
      You may use \string\RedeclarePageStyleAlias\space to declare a page
      style only\MessageBreak
      if that page style has already been declared or defined.\MessageBreak
      You may use either \string\DeclareNewPageStyleAlias,
      \string\DeclarePageStyleAlias,\MessageBreak
      or \string\ProvidePageStyleAlias\space to declare that not yet
      defined page style.\MessageBreak
      Nevertheless, if you'll continue, the page style will be declared.%
    }%
  }{}%
  \DeclarePageStyleAlias{#1}%
}
%    \end{macrocode}
% \end{macro}%^^A \RedeclarePageStyleAlias
% \end{macro}%^^A \ProvidePageStyleAlias
% \end{macro}%^^A \DeclareNewPageStyleAlias
% \end{macro}%^^A \DeclarePageStyleAlias
%
% \begin{macro}{\DestroyPageStyleAlias}
%   \begin{description}
%   \item[\Parameter{string}:] the name of a page style (must be
%     expandable and result in a string).
%   \end{description}
%    \begin{macrocode}
\newcommand*{\DestroyPageStyleAlias}[1]{%
  \scr@ifundefinedorrelax{@ps@#1@alias}{}{%
    \expandafter\let\csname @ps@#1@alias\endcsname\relax
    \expandafter\let\csname ps@#1\endcsname\relax
  }%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\GetRealPageStyle}
%   \begin{description}
%   \item[\Parameter{string}:] the name of a page style (must be
%     expandable and result in a string).
%   \end{description}
% Get the real name of the page style.
%    \begin{macrocode}
\newcommand*{\GetRealPageStyle}[1]{%
  \scr@ifundefinedorrelax{@ps@#1@alias}{#1}{%
    \expandafter\GetRealPageStyle\expandafter{%
      \expandafter\csname @ps@#1@alias\expandafter\endcsname\expandafter}%
  }%
}
%</package&body>
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\IfLayerPageStyleExists}
% \begin{macro}{\IfRealLayerPageStyleExists}
%   \begin{description}
%   \item[\Parameter{string}:] the name of the page style to be tested (must
%     be expandable and result in a string).
%   \item[\Parameter{code}:] whatever code should be expanded, if the test
%     result is true.
%   \item[\Parameter{code}:] whatever code should be expanded, if the test
%     result is false.
%   \end{description}
% Test, whether or not the page style is a declared layer page style.
%    \begin{macrocode}
%<*package&body>
\newcommand*{\IfLayerPageStyleExists}[1]{%
  \scr@ifundefinedorrelax{ps@#1}{%
    \expandafter\@secondoftwo
  }{%
    \scr@ifundefinedorrelax{@ps@#1@layers}{%
      \scr@ifundefinedorrelax{@ps@#1@alias}{%
        \expandafter\@secondoftwo
      }{%
        \expandafter\IfLayerPageStyleExists\expandafter{%
          \expandafter\csname @ps@#1@alias\expandafter\endcsname\expandafter}%
      }%
    }{%
      \expandafter\@firstoftwo
    }%
  }%
}
\newcommand*{\IfRealLayerPageStyleExists}[1]{%
  \scr@ifundefinedorrelax{ps@#1}{%
    \expandafter\@secondoftwo
  }{%
    \scr@ifundefinedorrelax{@ps@#1@layers}{%
      \expandafter\@secondoftwo
    }{%
      \expandafter\@firstoftwo
    }%
  }%
}
%</package&body>
%    \end{macrocode}
% \end{macro}%^^A \IfRealLayerPageStyleExists
% \end{macro}%^^A \IfLayerPageStyleExists
%
% \begin{macro}{\IfLayerAtPageStyle}
% \changes{v3.26}{2018/08/29}{\cs{scr@trim@spaces} added}%^^A
% \changes{v3.28}{2019/11/18}{\cs{ifstr} umbenannt in \cs{Ifstr}}%^^A
% \begin{macro}{\IfSomeLayersAtPageStyle}
% \changes{v3.26}{2018/08/29}{\cs{scr@trim@spaces} added}%^^A
% \changes{v3.28}{2019/11/18}{\cs{ifstr} umbenannt in \cs{Ifstr}}%^^A
% \begin{macro}{\IfLayersAtPageStyle}
%   \begin{description}
%   \item[\Parameter{string}:] the name of the page style to be tested (must
%     be expandable and result in a string).
%   \item[\Parameter{string}:] the name(s) of the layer(s) to be tested (must be
%     expandable and result in a string).
%   \item[\Parameter{code}:] whatever code should be expanded, if the test
%     result is true.
%   \item[\Parameter{code}:] whatever code should be expanded, if the test
%     result is false.
% \end{description}
% Tests:
% \begin{description}
% \item[\Macro{IfLayerAtPageStyle}:] Test, whether or not the page style has a
%   layer. The second argument is the name of one layer only!
% \item[\Macro{IfSomeLayersAtPageStyle}:] Test, whether or not the page style
%   has at least one layer of a list of layers. The second argument is a comma
%   separated list of layer names.
% \item[\Macro{IfLayersAtPageStyle}:] Test, whether or not the page style has
%   every layer of a list of layers. The second argument is a comma separated
%   list of layer names.
% \end{description}
% Note, that testing an page style, that is not a layer page style will result
% in an error and neither the third nor the fourth argument will be expanded.
% Note, that layers with empty name are only part of a layer page style
% without any layers.
%
% Note also, that with active \Option{deactivatepagestylelayers} layers are
% logically not longer part of the page styles.
%    \begin{macrocode}
%<*package&body>
\newcommand*{\IfLayerAtPageStyle}[2]{%
  \IfLayerPageStyleExists{#1}{%
    \begingroup
      \edef\reserved@a{\GetRealPageStyle{#1}}%
      \@tempswafalse
      \Ifstr{#2}{}{%
        \expandafter\ifx\csname @ps@\reserved@a @layers\endcsname\@empty
          \@tempswatrue
        \fi
      }{%
        \expandafter\ForEachLayerOfPageStyle\expandafter{%
          \reserved@a}{\Ifstr{##1}{#2}{\aftergroup\@tempswatrue}{}}%
      }%
      \if@tempswa \aftergroup\@firstoftwo \else \aftergroup\@secondoftwo \fi
    \expandafter\endgroup
  }{%
    \scrlayer@lpm@error{#1}{testing for layers}%
    \expandafter\@gobbletwo
  }%
}
\newcommand*{\IfSomeLayersAtPageStyle}[2]{%
  \IfLayerPageStyleExists{#1}{%
    \begingroup
      \@tempswafalse
      \@for \reserved@a:=#2\do {%
        \scr@trim@spaces\reserved@a
        \edef\reserved@a{\noexpand\IfLayerAtPageStyle{#1}{\reserved@a}}%
        \reserved@a{\@tempswatrue}{}%
      }%
      \if@tempswa \aftergroup\@firstoftwo \else \aftergroup\@secondoftwo \fi
    \expandafter\endgroup
  }{%
    \scrlayer@lpm@error{#1}{testing for layers}%
    \expandafter\@gobbletwo
  }%
}
\newcommand*{\IfLayersAtPageStyle}[2]{%
  \IfLayerPageStyleExists{#1}{%
    \begingroup
      \@tempswatrue
      \Ifstr{#2}{}{%
        \edef\reserved@a{\GetRealPageStyle{#1}}%
        \expandafter\ifx\csname @scr@\reserved@a @layers\endcsname\@empty \else
          \@tempswafalse
        \fi
      }{%
        \@for \reserved@a:=#2\do {%
          \scr@trim@spaces\reserved@a
          \edef\reserved@a{\noexpand\IfLayerAtPageStyle{#1}{\reserved@a}}%
          \reserved@a{}{\@tempswafalse}%
        }%
      }%
      \if@tempswa \aftergroup\@firstoftwo \else \aftergroup\@secondoftwo \fi
    \expandafter\endgroup
  }{%
    \scrlayer@lpm@error{#1}{testing for layers}%
    \expandafter\@gobbletwo
  }%
}
%</package&body>
%    \end{macrocode}
% \end{macro}%^^A \IfLayersAtPageStyle
% \end{macro}%^^A \IfSomeLayersAtPageStyle
% \end{macro}%^^A \IfLayerAtPageStyle
%
%
% \begin{macro}{\DestroyRealLayerPageStyle}
% \changes{v3.28}{2019/11/18}{\cs{ifstr} umbenannt in \cs{Ifstr}}%^^A
%   \begin{description}
%   \item[\Parameter{string}:] name of the layer page style to be destroyed.
%   \end{description}
% Destroys the given layer page style but not the layers! If the page style is
% the current page style, the empty page style an empty page style will be
% activated. If the special page style is valid an the destroyed one, this
% will be removed. This command could be used, e.g., at
% \Macro{scrlayerOnAutoRemoveInterface} after destroying the layers. However,
% the interface commands are deprecated.
%    \begin{macrocode}
%<*package&body>
\newcommand*{\DestroyRealLayerPageStyle}[1]{%
  \IfRealLayerPageStyleExists{#1}{%
    \expandafter\let\csname @ps@#1@initialhook\endcsname\relax
    \expandafter\let\csname @ps@#1@hook\endcsname\relax
    \expandafter\let\csname @ps@#1@backgroundhook\endcsname\relax
    \expandafter\let\csname @ps@#1@foregroundhook\endcsname\relax
    \expandafter\let\csname @ps@#1@oddpagehook\endcsname\relax
    \expandafter\let\csname @ps@#1@evenpagehook\endcsname\relax
    \expandafter\let\csname @ps@#1@onesidehook\endcsname\relax
    \expandafter\let\csname @ps@#1@twosidehook\endcsname\relax
    \expandafter\let\csname @ps@#1@floatpagehook\endcsname\relax
    \expandafter\let\csname @ps@#1@nonfloatpagehook\endcsname\relax
    \expandafter\let\csname @ps@#1@layers\endcsname\relax
    \expandafter\let\csname ps@#1\endcsname\relax
    \Ifstr{\currentpagestyle}{#1}{%
      \def\currentpagestyle{scrlayer@empty}%
      \let\@oddhead\@empty\let\@evenhead\@empty
      \let\@oddfoot\@empty\let\@evenfoot\@empty
    }{}%
    \if@specialpage
      \Ifstr{\@specialstyle}{#1}{%
        \global\let\@specialstyle\relax
        \global\@specialpagefalse
      }{}%
    \fi
  }{%
%<*trace>
    \PackageInfo{scrlayer}{%
      \string\DestroyRealLayerPageStyle{#1} ignored,\MessageBreak
      because the layer page style isn't\MessageBreak
      defined (any longer)%
    }%
%</trace>
  }%
}
%</package&body>
%    \end{macrocode}
% \end{macro}%^^A \DestroyRealLayerPageStyle
%
%
% \subsection{Kernel Patches}
%
% This package as so many others need to patch the \LaTeX{} kernel. This will
% be done, because we need information about the current active package style.
%
% \begin{macro}{\pagestyle}
% \begin{macro}{\currentpagestyle}
% \changes{v3.28}{2019/11/18}{\cs{ifstr} umbenannt in \cs{Ifstr}}%^^A
% We save the current page style. Note, that this doesn't work for special
% page styles\footnote{Special page styles are set by
% \Macro{thispagestyle}.} that hasn't been defined using
% \Package{scrlayer}. As long as \Macro{currentpagestyle} is empty, the
% current page style is unknown. And we add two hooks into page style
% selection: one before an one after the selection.
%    \begin{macrocode}
%<*package&body>
\newcommand*{\currentpagestyle}{}
\PackageInfo{scrlayer}{patching LaTeX kernel macro \string\pagestyle}
\def\reserved@a{%
  \iftoplevelpagestyle\edef\toplevelpagestyle{##1}\toplevelpagestylefalse\fi
  \scrlayer@exec@before@pagestyle@hook{##1}%
}
\expandafter\expandafter\expandafter\renewcommand
\expandafter\expandafter\expandafter*%
\expandafter\expandafter\expandafter\pagestyle
\expandafter\expandafter\expandafter[%
\expandafter\expandafter\expandafter1%
\expandafter\expandafter\expandafter]%
\expandafter\expandafter\expandafter{%
  \expandafter\reserved@a
  \pagestyle{#1}%
  \edef\currentpagestyle{\GetRealPageStyle{#1}}%
  \scrlayer@exec@after@pagestyle@hook{#1}%
  \toplevelpagestyletrue
}
\newif\iftoplevelpagestyle\toplevelpagestyletrue
\AtBeginDocument{%
  \begingroup
    \let\scrlayer@exec@before@pagestyle@hook\@gobble
    \let\scrlayer@exec@after@pagestyle@hook\@gobble
    \def\ps@test{}%
    \pagestyle{test}%
    \Ifstr{\currentpagestyle}{test}{}{%
      \PackageError{scrlayer}{package incompatibility detected}{%
        Another package redefines \string\pagestyle\space incompatible with
        scrlayer.\MessageBreak
        This disables setting of \string\currentpagestyle\space and may
        be serious.\MessageBreak
        Maybe you could prevent this loading package scrlayer
        later.\MessageBreak
        If not you should either not use scrlayer or not the other
        package,\MessageBreak
        that redefines \string\pagestyle.%
      }%
    }%
  \endgroup
}
%</package&body>
%    \end{macrocode}
% \end{macro}%^^A \currentpagestyle
%
% \begin{macro}{\BeforeSelectAnyPageStyle}
% \begin{macro}{\scrlayer@exec@before@pagestyle@hook}
% \begin{macro}{\AfterSelectAnyPageStyle}
% \begin{macro}{\scrlayer@exec@after@pagestyle@hook}
% We have two macros to locally add code to be executed whenever a page style
% changes using \Macro{pagestyle}. The first one executes the code before the
% page style will be changed, the second one after the page style has been
% changed. Note, that you may use \#1 as a placeholder of the argument of
% \Macro{pagestyle}.
%    \begin{macrocode}
%<*package&body>
\newcommand*{\BeforeSelectAnyPageStyle}[1]{%
  \expandafter\renewcommand\expandafter*%
  \expandafter\scrlayer@exec@before@pagestyle@hook
  \expandafter[\expandafter1\expandafter]\expandafter{%
    \scrlayer@exec@before@pagestyle@hook{##1}#1}%
}
\newcommand*{\scrlayer@exec@before@pagestyle@hook}[1]{}
\newcommand*{\AfterSelectAnyPageStyle}[1]{%
  \expandafter\renewcommand\expandafter*%
  \expandafter\scrlayer@exec@after@pagestyle@hook
  \expandafter[\expandafter1\expandafter]\expandafter{%
    \scrlayer@exec@after@pagestyle@hook{##1}#1}%
}
\newcommand*{\scrlayer@exec@after@pagestyle@hook}[1]{}
%</package&body>
%    \end{macrocode}
% \end{macro}%^^A \scrlayer@exec@after@pagestyle@hook
% \end{macro}%^^A \AfterSelectAnyPageStyle
% \end{macro}%^^A \scrlayer@exec@before@pagestyle@hook
% \end{macro}%^^A \BeforeSelectAnyPageStyle
% \end{macro}%^^A \pagestyle
%
%
% \subsection{Declaration of End User Interfaces}
%
% \changes{v3.32}{2020/09/11}{the interface commands are deprecated}
%
% The package also supports an interface for loading end user interfaces.
% Maybe it would be a good idea to move this to \Package{scrbase}, but
% currently it is not needed.
%
% \begin{macro}{\scrlayerAddToInterface}
% \begin{macro}{\scrlayerAddCsToInterface}
%   \begin{description}
%   \item[\texttt{\{\meta{command}\textbar\meta{command sequence}\}}:] the
%     command (with backslash) or the command sequence of the command (without
%     backslash) of the command, that should be added to the interface.
%   \item[\Parameter{code}:] will be executed, only if the command could be
%     added to the interface.
%   \end{description}
% Add either a command sequence or a command to the user interface.
%    \begin{macrocode}
%<*package&body>
\newcommand*{\scrlayerAddToInterface}[2][\@currname.\@currext]{%
  \scrlayer@report@deprecated{#1}{\scrlayerAddToInterface}%
  \begingroup
    \edef\reserve@a{%
      \noexpand\scrlayerAddCsToInterface[#1]{\expandafter\@gobble\string #2}%
    }%
  \expandafter\endgroup\reserve@a
}
\newcommand{\scrlayerAddCsToInterface}[3][\@currname.\@currext]{%
  \scrlayer@report@deprecated{#1}{\scrlayerAddCsToInterface}%
  \@ifundefined{scrlayer@#1@commandlist}{%
    \PackageError{scrlayer}{unkown interface `#1'}{%
      I've been told to add a command sequence to an interface, that hasn't
      been\MessageBreak
      defined yet. Please initialise every interface using
      \string\InitInterface\space before\MessageBreak
      trying to add command sequences to it.\MessageBreak
      If you'll continue, the command will be ignored.%
    }%
  }{%
    \@ifundefined{#2}{%
      \scrlayer@AddCsToInterface[#1]{#2}#3%
    }{%
      \@ifundefined{scrlayer@command@#2}{%
        \ifscrlayer@forceoverwrite
          \PackageWarning{scrlayer}{%
            Overloading `\@backslashchar#2'!\MessageBreak
            scrlayer detected, that the given command\MessageBreak
            has been defined already, when\MessageBreak
            `#1' tried to define it again.\MessageBreak
            Nevertheless, while scrlayer is in force overwrite\MessageBreak
            mode currently, the original definition will be\MessageBreak 
            removed%
          }%
          \expandafter\let\csname #2\endcsname\relax
          \scrlayer@AddCsToInterface[#1]{#2}#3%
        \else
          \PackageError{scrlayer}{cannot define `\@backslashchar#2'}{%
            scrlayer interface `#1' has tried to
            define command\MessageBreak
            `\@backslashchar#2', but this has already been defined\MessageBreak
            and is not part of another interface. So it cannot be
            defined.\MessageBreak
            Before continuing you should solve this conflict.\MessageBreak
            Nevertheless, you may use option `forceoverwrite' to get only a
            warning instead\MessageBreak
            of an error. But this wouldn't solve the problem at
            all!\MessageBreak
            This error is almost fatal, so you should abort the LaTeX
            run.%
          }%
        \fi
      }{%
        \ifscrlayer@autoremoveinterfaces
          \PackageInfo{scrlayer}{%
            already define interface command\MessageBreak
            `\@backslashchar#2' detected.\MessageBreak
            Command has been defined by interface\MessageBreak
            `\@nameuse{scrlayer@command@#2}'.\MessageBreak
            To continue installation of interface\MessageBreak
            `#1', interface\MessageBreak
            `\@nameuse{scrlayer@command@#2}' will\MessageBreak
            be removed%
          }%
          \@nameuse{scrlayer@\@nameuse{scrlayer@command@#2}@onremove}%
          \begingroup
            \def\@elt##1{%
              \aftergroup\let\aftergroup##1\aftergroup\relax
            }%
            \@nameuse{scrlayer@\@nameuse{scrlayer@command@#2}@commandlist}%
          \endgroup
          \expandafter\let\csname
          scrlayer@\@nameuse{scrlayer@command@#2}@commandlist\endcsname\relax
          \expandafter\let\csname
          scrlayer@\@nameuse{scrlayer@command@#2}@onremove\endcsname\relax
          \expandafter\let\csname #2\endcsname\relax
          \scrlayer@AddCsToInterface[#1]{#2}#3%
        \else
          \PackageError{scrlayer}{cannot define `\@backslashchar#2'}{%
            Interface command `\@backslashchar#2' has already
            been\MessageBreak
            defined by interface
            `\@nameuse{scrlayer@command@#2}'.\MessageBreak
            So it cannot be defined again.\MessageBreak
            You may try scrlayer option `autoremoveinterfaces' to
            automatically remove\MessageBreak
            older interfaces in such conflict situations.\MessageBreak
            For now, it's recommended so solve the problem before you'll
            continue.%
          }%
        \fi
      }%
    }%
  }%
}%
%    \end{macrocode}
% \begin{macro}{\scrlayer@AddCsToInterface}
% Little helper, to avoid repeating this \Macro{expandafter} orgy.
% \begin{description}
% \item[\OParameter{string}:] the interface name (must be expandable and
%   expand to a string)
% \item[\Parameter{command sequence}] the command sequence of the command to
%   be added.
% \end{description}
%    \begin{macrocode}
\newcommand*\scrlayer@AddCsToInterface[2][\@currname.\@currext]{%
  \scrlayer@report@deprecated{#1}{\scrlayer@AddCsToInterface}%
  \expandafter\expandafter\expandafter\def\expandafter
  \csname scrlayer@#1@commandlist\expandafter\expandafter\expandafter\endcsname
  \expandafter\expandafter\expandafter{%
    \csname scrlayer@#1@commandlist\expandafter\endcsname
    \expandafter\@elt\csname #2\endcsname
  }%
  \@namedef{scrlayer@command@#2}{#1}%
}
%</package&body>
%    \end{macrocode}
% \begin{option}{forceoverwrite}
% \begin{macro}{\ifscrlayer@forceoverwrite}
%   \begin{description}
%   \item[\Parameter{simple switch}:] whether or not to overwrite already
%     defined command. Note: If true, there will still be a warning.
%   \end{description}
%    \begin{macrocode}
%<*options>
%<*package>
\KOMA@ifkey{forceoverwrite}{scrlayer@forceoverwrite}
%<package>\scrlayer@@add@inherited@option{forceoverwrite}
%</package>
%<*interface>
\KOMA@key{forceoverwrite}[true]{%
  \KOMA@set@ifkey{forceoverwrite}{scrlayer@forceoverwrite}{#1}%
  \KOMA@kav@replacebool{.scrlayer.sty}{forceoverwrite}{scrlayer@forceoverwrite}%
}
%</interface>
%</options>
%<*interface&body>
\expandafter\let
  \csname KV@KOMA.\@currname.\@currext @forceoverwrite\endcsname\relax
\expandafter\let
  \csname KV@KOMA.\@currname.\@currext @forceoverwrite@default\endcsname\relax
%</interface&body>
%    \end{macrocode}
% \end{macro}%^^A \ifscrlayer@forceoverwrite
% \end{option}%^^A forceoverwrite
%
% \begin{option}{autoremoveinterfaces}
% \begin{macro}{\ifscrlayer@autoremoveinterfaces}
%   \begin{description}
%   \item[\Parameter{simple switch}:] whether or not older interfaces may be
%     automatically removed in conflict cases.
%   \end{description}
%    \begin{macrocode}
%<*options>
%<*package>
\KOMA@ifkey{autoremoveinterfaces}{scrlayer@autoremoveinterfaces}
%<package>\scrlayer@@add@inherited@option{autoremoveinterfaces}
%</package>
%<*interface>
\KOMA@key{autoremoveinterfaces}[true]{%
  \scrlayer@report@deprecated{#1}{autoremoveinterface}%
  \KOMA@set@ifkey{autoremoveinterfaces}{scrlayer@autoremoveinterfaces}{#1}%
  \KOMA@kav@replacebool{.scrlayer.sty}{autoremoveinterfaces}
                       {scrlayer@autoremoveinterfaces}%
}
%</interface>
%</options>
%<*interface&body>
\expandafter\let
  \csname KV@KOMA.\@currname.\@currext @autoremoveinterfaces\endcsname\relax
\expandafter\let
  \csname KV@KOMA.\@currname.\@currext @autoremoveinterfaces@default\endcsname
  \relax
%</interface&body>
%    \end{macrocode}
% \end{macro}%^^A \ifscrlayer@autoremoveinterfaces
% \end{option}%^^A autoremoveinterfaces
% \end{macro}%^^A \scrlayer@AddCsToInterface
% \end{macro}%^^A \scrlayerAddCsToInterface
% \end{macro}%^^A \scrlayerAddToInterface
%
% \begin{macro}{\scrlayerInitInterface}
%   \begin{description}
%   \item[\OParameter{string}:] the name of the interface. Generally this is
%     the file name of the package or class, that defines the interface
%     (default: \texttt{\Macro{@currname}.\Macro{@currext}}).
%   \end{description}
% This registers a new user interface.
%    \begin{macrocode}
%<*package&body>
\newcommand*{\scrlayerInitInterface}[1][\@currname.\@currext]{%
  \scrlayer@report@deprecated{#1}{\scrlayerInitInterface}%
  \@ifundefined{scrlayer@#1@commandlist}{%
    \@namedef{scrlayer@#1@commandlist}{}%
  }{%
    \begingroup
      \def\@elt##1{\space\space\string##1\MessageBreak}%
      \PackageError{scrlayer}{interface `#1' already initialised}{%
        You've tried to initialise scrlayer interface `#1',\MessageBreak
        but an interface of this name has been initialised
        already.\MessageBreak
        Here's a list of all macros of the already initialised
        interface:\MessageBreak
        \@nameuse{scrlayer@#1@commandlist}.%
        If you'll continue, this re-initialisation will be ignored.%
      }%
    \endgroup
  }%
}
%</package&body>
%    \end{macrocode}
% \end{macro}%^^A \scrlayerInitInterface
%
% \begin{macro}{\scrlayerOnAutoRemoveInterface}
%   \begin{description}
%   \item[\OParameter{string}:] the name of the interface. Generally this is
%     the file name of the package or class, that defines the interface
%     (default: \texttt{\Macro{@currname}.\Macro{@currext}}).
%   \item[\Parameter{code}:] will be executed if the interface will be removed
%     automatically (see option \Option{autoremoveinterfaces}).
%   \end{description}
%    \begin{macrocode}
%<*package&body>
\newcommand*{\scrlayerOnAutoRemoveInterface}[2][\@currname.\@currext]{%
  \scrlayer@report@deprecated{#1}{\scrlayerOnAutoRemoveInterface}%
  \@ifundefined{scrlayer@#1@onremove}{\@namedef{scrlayer@#1@onremove}{}}{}%
  \expandafter\l@addto@macro\csname scrlayer@#1@onremove\endcsname{#2}%
}
%</package&body>
%    \end{macrocode}
% \end{macro}%^^A \scrlayerOnAutoRemoveInterface
%
% \begin{macro}{\scrlayer@report@deprecated}
% \changes{v3.32}{2020/09/11}{new (internal)}
% Report that the deprecated interface commands are used but should not. But
% report this only once per interface.
%    \begin{macrocode}
%<*package&init>
\newcommand*{\scrlayer@report@deprecated}[2]{%
  \@ifundefined{scrlayer@deprecated@reported@for@#1}{%
    \PackageWarning{scrlayer}{%
      Deprecated interface detected for `#1'.\MessageBreak
      There isn't any support for using, e.g.,\MessageBreak
      `\string #2'%
    }%
    \@namedef{scrlayer@deprecated@reported@for@#1}{\string #2}%
  }{}%
}
%</package&init>
%    \end{macrocode}
% \end{macro}
%
% \iffalse^^A meta-comment
%</package|interface|class>
% \fi^^A meta-comment
%
%
% \Finale
%
\endinput
%
% end of file `scrlayer.dtx'

%%% Local Variables:
%%% mode: doctex
%%% ispell-local-dictionary: "en_GB"
%%% flyspell-mode: t
%%% TeX-master: t
%%% End:
