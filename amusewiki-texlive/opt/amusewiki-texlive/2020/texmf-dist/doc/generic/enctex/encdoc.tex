% EncTeX documentation
%%%%%%%%%%%%%%%%%%%%%%
%           Petr Olsak

% see encdoce-e.tex for English version of this documentation

\chyph % zpracujte formatem csplain

\def\Red{}
\def\Black{}
\def\Blue{}
\def\Green{}
\def\beglink#1{}
\def\endlink{}
\def\aimlink#1{}
\def\urllink#1{{\tt#1}}
\def\urllinkk#1#2{{\tt#1}}

\ifx\pdfoutput\undefined\else   %%%% pdfTeX is used %%%%%%%%%%
\ifnum\pdfoutput>0    

\ifx\pdfannotlink\undefined  % Verze pdfTeXu >= 14
   \let\pdfannotlink=\pdfstartlink
\fi


\def\beglink#1{%          % Zaèátek textu odkazu, #1 je klíè odkazu
   \Green \pdfstartlink height9pt depth3pt 
     attr{/Border[0 0 0]} goto name{#1}\relax}
\def\endlink{\pdfendlink\Black}  

\def\aimlink#1{%          % Místo cíle odkazu, #1 je klíè odkazu
   \expandafter\ifx \csname aim:#1\endcsname \relax
      \expandafter\gdef \csname aim:#1\endcsname {}%
      \vbox to0pt{\vss\hbox{\pdfdest name{#1} fith}\kern15pt}%
   \fi
}
\def\urllinkk#1#2{\pdfannotlink height 10pt depth 3pt 
   user{/Border[0 0 0]/Subtype/Link/A << /Type/Action/S/URI/URI(#2)>>}\relax
   \Green{\tt #1}\Black\pdfendlink}
\def\urllink#1{\urllinkk{#1}{#1}}


\def\pdfsetcmykcolor#1{\special{PDF:#1 k}}
\def\Red{\leavevmode\pdfsetcmykcolor{0.1 0.9 0.9 0}}
\def\Black{\leavevmode\pdfsetcmykcolor{0 0 0 1}}
\def\Green{\leavevmode\pdfsetcmykcolor{0.9 0.1 0.9 .3}}
\def\Blue{\leavevmode\pdfsetcmykcolor{0.9 0.9 0.1 0}}

\pdfcompresslevel=9
\pdfinfo{/Author (Petr Olsak)
         /CreationDate (Feb. 2003) 
         /ModDate (Jun. 2004)
         /Creator (TeX)
         /Producer (pdfTeX)
         /Title (encTeX)
         /Subject (Documentation)
         /Keywords (TeX, fonts)
}

\fi\fi %%%%%%%%%%%%%%%%%%%%%%%%%%%% End of pdfTeX macros %%%%%


\font\titulfont=\fontname\tenbf\space scaled\magstep4
\font\bigbf=\fontname\tenbf\space scaled\magstep1

\parindent=12pt

\newcount\secnum  \newcount\subsecnum

\def\kap #1\par{\ifnum\secnum>0 \goodbreak\fi\removelastskip
   \vskip2\baselineskip
   \subsecnum=0 \advance\secnum by1
   \noindent{\bigbf\llap{\the\secnum.\quad}#1}\par\nobreak\medskip}
\def\sec #1\par{\removelastskip\bigskip
   \advance\subsecnum by1   
   \noindent{\bf \llap{\aimlink{\the\secnum.\the\subsecnum}%
      \the\secnum.\the\subsecnum.\quad}#1}\par\nobreak\medskip}
\def\title #1\par{\vglue2\baselineskip 
   \centerline{\titulfont #1}\vskip2\baselineskip}
\def\date #1\par{\bigskip#1\par}
\def\author #1\par{\bigskip#1\par}

\catcode`<=13
\def<{\hbox\bgroup\catcode`_=\active\relax\skoba}
\def\skoba #1>{$\langle$\it#1\/$\rangle$\egroup}
\def\,{\thinspace}
{\catcode`_=\active \gdef_{\_}}

{\obeyspaces \gdef\activespace{\obeyspaces\let =\ }}
\def\setverb{\def\do##1{\catcode`##1=12}\dospecials}
\def\begtt{\medskip\bgroup \setverb \activespace
   \catcode`\"=12 \catcode`_=13
   \def\par##1{\endgraf\ifx##1\par\leavevmode\fi ##1}
   \obeylines \startverb}
{\catcode`\|=0 \catcode`\\=12
|gdef|startverb#1\endtt{|tt#1|egroup|medskip|testpar}}
\long\def\testpar#1{\ifx\par#1\else\noindent\fi#1}

\catcode`"=13
\def"{\leavevmode\hbox\bgroup\setverb\activespace\tt\readverb}
\def\readverb #1"{#1\egroup}

\def\begitems{\medskip\bgroup \catcode`*=13 }
{\catcode`*=13 \gdef*{\item{$\bullet$}}}
\def\enditems{\medskip\egroup}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

{\nopagenumbers

\vglue 4cm

\centerline {\titulfont Enc\TeX}
\vskip2cm
\centerline {\titulfont mo¾nost pøekódování vstupu v~\TeX{}u}

\vskip3cm

\centerline {\bigbf Petr Ol¹ák}

\vskip2cm

\centerline{\urllinkk{www.olsak.net/enctex.html}{http://www.olsak.net/enctex.html}}

\vfil

\centerline {\bigbf Toto je dokumentace k~verzi Feb. 2003 a Jun. 2004}

\vskip 4cm 
\break

\null \vfil

Enc\TeX{} je volné programové vybavení; mù¾ete jej dále ¹íøit
a modifikovat podle podmínek \uv{GNU General Public License}, kterou
publikovala "Free Software Foundation"; pou¾ijte verzi 2 této licence
nebo (podle Va¹í volby) libovolnou pozdìj¹í verzi.

Balíèek najdete na Internetu na
\urllink{ftp://math.feld.cvut.cz/pub/olsak/enctex/}.


Tento balíèek je roz¹iøován v~nadìji, ¾e bude u¾iteèný, av¹ak BEZJAKÉKOLI ZÁRUKY; neposkytují se ani odvozené záruky PRODEJNOSTI anebo
VHODNOSTI PRO URÈITÝ ÚÈEL. Dal¹í podrobnosti hledejte v~Obecné veøejné
licenci GNU.

Kopii \uv{GNU General Public License} jste mìl obdr¾et spolu s~tímto
programem; pokud se tak nestalo, napi¹te o~ni Free Software Foundation,
Inc., 675 Mass Ave, Cambridge, MA 02139, USA. Èeský pøeklad této
licence najdete na "http://www.gnu.cz/gplcz.html".

\bigskip 
\copyright\quad  1997, 2002, 2003, 2004\enspace RNDr. Petr Ol¹ák

\bigskip

\TeX{} je ochranná známka American Mathematical Society.

\bigskip
Autor \TeX{}u je profesor Donald Knuth. \TeX{} je volné programové
vybavení se specifickou licencí, viz dokumentaci k~tomuto programu.

\break
}

\kap Základní informace
     %%%%%%%%%%%%%%%%%%

Balík enc\TeX{} je jednoduché roz¹íøení \TeX{}u pro takové implementace, ve
kterých se \TeX{} instaluje ze zdrojového kódu "tex.web". Tuto
podmínku napøíklad splòuje implementace web2c, urèená pro UNIXy 
a jiné operaèní systémy s~kvalitním pøekladaèem jazyka C.

Roz¹íøení enc\TeX{} je zpìtnì kompatibilní s~originálním
\TeX{}em. Pøidává deset nových primitivù, kterými lze èíst nebo
naplòovat vnitøní kódovací tabulky, podle nich¾ je znak transformován
na úrovni vstupního procesoru \TeX{}u nebo pøi výstupu na terminál, do
"log" souboru a "\write" souborù.  Tyto tabulky se ukládají do
formátových souborù, tak¾e po naètení formátu se inicializují ve
stejném stavu, v~jakém byly v~okam¾iku pøíkazu "\dump".

Zmìna \TeX{}u je dùkladnì testovaná a pro¹la té¾ testem TRIP 
s~tìmito dvìma odli¹nostmi:

\begitems
* Odli¹ný banner 
* Poèet \uv{multiletter control sequences} je o~deset vìt¹í.
\enditems

\sec Instalace
%    ---------

Viz soubor "INSTALL".

\sec Verze
%    -----

V~roce 1997 byla zveøejnìna první verze enc\TeX{}u, která umo¾òovala
konverze pouze v~re¾imu \uv{byte na byte} a nastavovala tisknutelnost
znakù (primitivy "\xordcode", "\xchrcode", "\xprncode").

V~roce 1998 obnovil nìkdo z~Polska pou¾ívání TCX tabulek ve web2c
\TeX{}u. Proto¾e enc\TeX{} z~roku 1997 dìlal víceménì toté¾ a
pou¾ívání obou nadstaveb souèasnì by mohlo být pro mnoho u¾ivatelù
matoucí, pøestal jsem enc\TeX{} prosazovat. Ov¹em v~roce 2002
jsem se rozhodl pøidat do enc\TeX{}u podporu UTF-8 kódování, proto¾e
tato podpora není a asi nebude v~TCX tabulkách implementována.
V~prosinci 2002 jsem se tedy rozhodl znovu zaèít propagovat enc\TeX{},
který navíc zvládne UTF-8 kódování.

Verze enc\TeX{}u "Feb.2003"  pøidává dal¹ích
7~primitivù "\mubyte", "\endmubyte", "\mubytein", "\mubyteout",
"\mubytelog", "\specialout" a "\noconvert". To umo¾ní definovat vstup
pro UTF-8 kódované soubory. Tato verze je samozøejmì zpìtnì
kompatibilní s~pùvodní verzí enc\TeX{}u z~roku 1997. Neplánuji do
budoucna ¾ádné rozsáhlej¹í zmìny. Pokud pøeci jenom k~nìjakým zmìnám
dojde, pak v¾dy budou zpìtnì kompatibilní se stávajícím øe¹ením

Verze "Jun.2004" opravuje jen nìkteré drobné chyby a nepøídává ¾ádné
nové funkce (podrobnìji viz soubor "enctex.patch-jun2004").


\sec Enc\TeX{} ve web2c distribuci
%    -----------------------------

Enc\TeX{} se v~\TeX{}u, pdf\TeX{}u, e-\TeX{}u a pdfe\TeX{}u 
v~distribuci web2c inicializuje pomocí pøepínaèe "-enc" na pøíkazové
øádce. Tento pøepínaè je nutno pou¾ít pøi inicializaci formátu.  
V~takovém pøípadì enc\TeX{} ulo¾í své primitivy a svá data do formátu.  Pøi
pou¾ití formátu u¾ není nutné pøepínaè "-enc" psát znova. Enc\TeX{} se 
v~tomto pøípadì inicializuje z~formátu a napí¹e o~tom zprávu na terminál
a do log souboru. Pokud nepou¾ijete pøepínaè "-enc" v~dobì generování
formátu, ale pou¾ijete jej a¾ pøi pou¾ití formátu, pak
\TeX{} vypí¹e varování o~neexistenci enc\TeX{}u ve formátu a pøepínaè
"-enc" je ignorován.

Ve web2c distribuci pracují se stejnými kódovacími vektory xord a xchr
(pro pøekódování byte na byte) jednak enc\TeX{} a jednak tzv. TCX tabulky
(pøi pou¾ití pøepínaèe "-translate-file"). Urèitému konfliktu se tedy pøi
souèasném pou¾ívání obou roz¹íøení nevyhneme. 
Je-li v~enc\TeX{}u pou¾ita TCX tabulka, pak pøi startu \TeX{}u 
pøepí¹e hodnoty "\xordcode", "\xchrcode" a "\xprncode" podle sebe. 
Znamená to, ¾e pøi pou¾ití ini\TeX{}u pak nemusejí platit implicitní
hodnoty tìchto kódù dokumentované v~sekci 2.2 a pøi pou¾ití formátu
s~enc\TeX{}em jsou hodnoty tìchto kódù, které si do formátu ulo¾il
enc\TeX{}, pøepsány podle TCX tabulky. O~této skuteènosti enc\TeX{}
nále¾itì informuje na terminálu a v~logu. Pøi bìhu programu pak mù¾ete
enc\TeX{}ovými primitivy tyto kódy dále èíst a mìnit. Pou¾ití TCX
tabulky tedy nevyluèuje mo¾nosti enc\TeX{}u.

\sec Problém s~licencí \TeX{}u
%    -------------------------

Enc\TeX{} roz¹iøuje \TeX{} o~nové primitivy, tak¾e bychom nemìli tomuto
programu øíkat \TeX{}. Na druhé stranì ale Knuth samotný pøedpokládá,
¾e vnitønosti \TeX{}u budou odstínìny od prostøedí operaèního
systému. Proto implementoval xord a xchr vektory. V~enc\TeX{}u mù¾eme
nastavit podle zvyklostí operaèního systému vstupní a výstupní
pøekódovací tabulky a pak nastavit v¹em novým primitivùm význam
"\undefined". Dále se bude \TeX{} modifikovaný enc\TeX{}em chovat stejnì,
jako originální \TeX{}. Navíc mù¾eme pøekódovací tabulky nastavit pøi
generování formátu a v~produkèní verzi \TeX{}u zakázat pøístup 
k~primitivùm. Produkèní verze \TeX{}u se pak chová zcela stejnì jako
originální \TeX{}. Knuth pøedpokládá, ¾e odstínìní od prostøedí 
operaèního systému se provede v¾dy pøi kompilaci zdrojového kódu
\TeX{}u, zatímco enc\TeX{} umo¾òuje tuto otázku øe¹it pozdìji,
napøíklad v~dobì generování formátu. Umo¾nìní úpravy nìkterých
(napøíklad pamì»ových) parametrù a¾ za bìhu \TeX{}u také není nic
nového a známe to skoro u~v¹ech distribucí \TeX{}u.

Domnívám se, ¾e druhý øádek na terminálu a v~logu dostateènì informuje
o~tom, ¾e se jedná o~modifikovanou verzi \TeX{}u. Také se domnívám, ¾e
pokud se velmi roz¹íøí kódování UTF-8, pak není zbytí a takové
konverze jsou v~8 bitové verzi \TeX{}u nezbytné.

Je dùle¾ité rovnì¾ pøipomenout, ¾e implicitní chování enc\TeX{}u je
takové, ¾e pokud se nepou¾ijí roz¹íøené primitivy enc\TeX{}u, pak se
chová naprosto stejnì jako originální \TeX{}.

Podle mého názoru novìj¹í implementace web2c \TeX{}u taky není v~pøísném
slova smyslu \TeX{}. Umo¾òuje toti¾ zmìnu chování programu, pokud na
prvním øádku dokumentu za znaky "%&" je cosi specifického napsáno.  To
je podle mého názoru vìt¹í pøestupek oproti licenci \TeX{}u, ne¾
enc\TeX{}ovými primitivy nastavit ve formátu prostøedí systému a pak tyto
primitivy v~produkèní verzi \TeX{}u zakázat.


\kap Pøekódování byte na byte pomocí vektorù xord, xchr
     %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\sec Vektory xord a xchr
%    -------------------

Vektory xord a xchr mají velikost 255 bytù a obsahují informaci
o~pøekódování znaku vstupujícího do \TeX{}u nebo vystupujícího na
terminál a do textových souborù. Jedná se o~pole vestavìná do
programu, pøes která jsou filtrovány ve¹keré textové vstupní a
výstupní informace. Má-li znak na vstupu kód $x$ a chceme, aby mìl
uvnitø \TeX{}u kód $y$, pak musí být nastaven vektor xord tak, aby
xord[$x$]=$y$. Pøi zpìtném výstupu znaku na terminál, do logu a do
souborù zpracovávaných pomocí "\write" platí tato pravidla: Není-li znak
s~kódem $y$ oznaèen jako \uv{tisknutelný}, pak vystupuje pomocí pøepisu
"^^"kód~$y$. Je-li tisknutelný, pak vystupuje s~kódem $z$=xchr[$y$].

Standardnì bývají v~systémech s~kódem ASCII nastaveny hodnoty tìchto
vektorù tak, ¾e 
\medskip
xord[$i$]=xchr[$i$]=$i$ pro v¹echna $i$ v~rozsahu 0~a¾~255. 
\medskip
Na systémech, které nepou¾ívají ASCII, se mù¾e mapovat 94
tisknutelných ASCII znakù jinam. Mimoto je deklarovaná vlastnost
\uv{tisknutelnosti} znaku v~ASCII takto: Znak je tisknutelný, pokud má
kód~$y$ v~rozsahu 32 a¾ 126. Ostatní znaky se pova¾ují za netisknutelné a
\TeX{} je standardnì pøepisuje pomocí dvojité støí¹ky.

Po instalaci balíèku enc\TeX{} je mo¾no pøímo nastavovat a èíst obsahy
vektorù xord a xchr prostøednictvím primitivù "\xordcode"
a "\xchrcode" a dále nastavovat vlastnost \uv{tisknutelnosti} znaku
pomocí primitivu "\xprncode". Syntaxe v¹ech tøí nových primitivù
je naprosto stejná, jakou známe napøíklad u~primitivù "\lccode" a
"\uccode". Napøíklad:

\begtt
\xordcode"AB="CD  \xchrcode\xordcode"AB="AB \the\xchrcode200
\endtt
%
nastavuje xord[0xAB]=0xCD; xchr[xord[0xAB]]=0xAB a dále vytiskne
hodnotu xchr[200].

Na rozdíl od podobných primitivù "\catcode", "\lccode", "\sfcode" a 
dal¹ích v¹ak novì zavedené primitivy mají jednu podstatnou výjimku. 
Reprezentují interní registry \TeX{}u, které v¾dy mají globální 
platnost. Proto je nastavení "\xordcode" a "\xchrcode" uvnitø 
skupiny za v¹ech okolností globální, aèkoli to explicitnì nepí¹eme. 
Ústupem z~po¾adavku na mo¾nost lokálního deklarování
hodnot jsem dosáhl podstatnì vìt¹í efektivity výsledného kódu programu.


\sec Tisknutelnost znakù nastavená pomocí {\tt\char`\\xprncode}
%    ----------------------------------------------------------

Primitiv "\xprncode" umo¾òuje nastavovat vlastnost \uv{tisknutelnosti}
znaku takto: Znak s~kódem $y$ je tisknutelný právì tehdy, kdy¾ je
$y$ v~rozsahu 32 a¾ 126 nebo je "\xprncode" $y > 0$. Napí¹eme-li napøíklad
"\xprncode255=1", bude tisknutelný znak s~kódem 255. Na druhé stranì,
nastavení "\xprncode`a" tøeba na nulu nemá na chování programu ¾ádný
vliv, proto¾e kód znaku "a" je v~rozsahu 32 a¾ 126. Tímto
opatøením program vykazuje urèitý pud sebezáchovy, proto¾e zlý u¾ivatel
by mu mohl nastavit v¹echny znaky jako netisknutelné a program by ztratil
schopnost se vyjadøovat. Hodnoty "\xprncode" lze nastavit jako u~ostatních
nových primitivù v~rozsahu nula a¾ 255, ov¹em otázka tisknutelnosti je
toto¾ná s~otázkou na kladnou hodnotu bez ohledu na to, jak velká tato
hodnota je.

Výchozí hodnoty pro kódování v~dobì ini\TeX{}u jsou následující:

\vbox{
\begitems
* "\xordcode" $i$ = $i$ pro v¹echna $i$ v~rozsahu 0...255,
* "\xchrcode" $i$ = $i$ pro v¹echna $i$ v~rozsahu 0...255,
* "\xprncode" $i$ = 0 pro $i$ v~rozsahu 0...31, 127...255,
* "\xprncode" $i$ = 1 pro $i$ v~rozsahu 32...126.
\enditems
}

První dva øádky jsou pravdivé jen na operaèních systémech, které pøijaly
kódování anglické abecedy podle ASCII. Pokud tomu tak není, pak jsou
výchozí hodnoty vektorù xord a xchr pozmìnìny tak, aby mapovaly tisknutelné
znaky podle systému do ASCII uvnitø \TeX{}u. Taková zmìna se týká jen 95
základních tisknutelných znakù, které jsou v~ASCII na pozicích
32~a¾~126.


\kap Konverze více bytù na jeden byte nebo kontrolní sekvenci
     %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Od verze Dec 2002 enc\TeX{} umí také konvertovat na úrovni vstupního
procesoru více bytù na jeden byte nebo kontrolní sekvenci. 
Pøi výstupu do logu a "\write" souborù je pak tento objekt 
zpìtnì pøeveden na pùvodních více bytù. Tato vlastnost nechce nahradit
chybìjící interpret regulárních výrazù ve vstupním procesoru \TeX{}u.
Byla implementována pouze z~dùvodu umo¾nit pracovat s~UTF-8 kódovanými
soubory v~bì¾ném 8 bitovém \TeX{}u tak, ¾e znaky z~UTF-8 
z~nejèastìji pou¾ívané abecedy mohou být mapovány na jeden znak, 
který mù¾e mít svùj "\catcode", "\uccode" atd. Jiné znaky 
z~UTF-8 mohou být mapovány na libovolné kontrolní sekvence.

Pro nastavení takové konverze jsou do \TeX{}u pøidáno nový pìt
primitivù: "\mubytein", "\mubyteout", "\mubytelog", "\mubyte" a "\endmubyte".
Primitivy "\mubytein", "\mubyteout" a "\mubytelog" jsou celoèíselné
registry implicitnì s~nulovou hodnotou, tj. konverze vstupu a výstupu
podle konverzní tabulky se neprovádìjí. Je-li "\mubytein" nastaveno na
kladnou hodnotu, \TeX{} okam¾itì zahájí konverze vstupního øádku podle
konverzní tabulky. Je-li "\mubyteout" nastaveno na kladnou hodnotu,
\TeX{} zaène konvertovat do výstupních "\write" souborù podle
stejné konverzní tabulky. Pøi kladném "\mubytelog" bude \TeX{} zpìtnì 
konvertovat také výstup do logu a na terminál.
Implicitnì je konverzní tabulka prázdná a
jednotlivé øádky se do ní pøidávají pomocí dvojice primitivù
"\mubyte", "\endmubyte" s~touto syntaxí:

\begtt
\mubyte <first_token><one_optional_space><optional_prefix><byte_sequence>\endmubyte
\endtt

Ka¾dá <byte_sequence> bude pøevedena ve vstupním procesoru na
<first_token>. Je-li <first_token> znakem (tj. není to kontrolní
sekvence), pak se ignoruje jeho kategorie, proto¾e konverze je
provádìna v~input procesoru podle schématu: <byte_sequence> na jeden
<byte>. Pøi výstupu do logu a "\write" souborù se pak ka¾dý takový
<byte> znovu pøevede na <byte_sequence>. 

Pokud je <first_token>
kontrolní sekvence, pak se na úrovni vstupního procesoru promìní
ka¾dá <byte_sequence> na tuto kontrolní sekvenci implementovanou ve formì
nemìnitelného tokenu. Token procesor tuto sekvenci tedy znovu
neinterpretuje a zùstává za ní ve stavu neignorování mezer. Pøi 
{\catcode`\<=12 "\mubyteout<2"} není pøi výstupu do "\write" 
souborù tato kontrolní sekvence zpìtnì pøevádìna na pùvodní <byte_sequenci>, 
ale podléhá jen bì¾né expanzi, jako ostatní kontrolní sekvence.
Pøi "\mubyteout>=2" se i tyto kontrolní sekvence pøevádìjí do
"\write" souborù na pùvodní <byte_sequence>. Aby se ale mohly pøevést,
nesmìjí pøed tím expandovat, tj.~musejí
mít v~dobì expanze význam neexpandovatelné kontrolní sekvence
nebo musejí být oznaèeny pomocí "\noexpand".
Pøi "\mubyteout>=3" enc\TeX{} potlaèí expanzi kontrolních sekvencí
deklarovaných v~"\mubyte" automaticky (podrobnìji viz sekci~3.8).
Výstup do logu a na terminál, který není produktem pøíkazu "\write", 
ponechává i pøi kladném "\mubytelog" kontrolní sekvence nezmìnìny.

Význam <optional_prefix> je vysvìtlen v~sekci~3.5.

\sec Zaná¹ení údajù do konverzní tabulky
%    -----------------------------------

Záznamy do konverzní tabulky jsou pomocí primitivù "\mubyte", "\endmubyte"
zaná¹eny globálnì, zatímco hodnoty v~registerch "\mubytein",
"\mubyteout" a "\mubytelog" mají obvykou lokální platnost. 

Dvojice primitivù "\mubyte", "\endmubyte" pracuje analogicky, jako
dvojice "\csname", "\endcsname". Rozdíl je pouze v~tom, ¾e první token
<first_byte> se neexpanduje a ¾e za ním mù¾e (po expanzi) následovat
<one_optional_space>. Pøi skenování <optional_prefix> a 
<byte_sequence> ji¾ probíhá úplná expanze a pøi ní se nesmí objevit na
vstupu do hlavního procesoru token typu kontrolní sekvence, jinak
nastane chyba, kterou u¾ známe z~pou¾ívání "\csname", "\endcsname":

\begtt
! Missing \endmubyte inserted.
\endtt

Primitiv "\mubyte" na rozdíl od "\csname" neprovádí èinnost na úrovni
expand procesoru, ale jedná se o~pøiøazovací primitiv zpracovaný na
úrovni hlavního procesoru. Tak¾e po

\begtt
\edef\a{\mubyte X ABC\endmubyte}
\endtt
%
bude makro "\a" obsahovat tokeny: "\mubyte X ABC\endmubyte".

Pøíklady:

\begtt
\mubyte  ^^c1      ^^c3^^81\endmubyte % Á
\mubyte  ^^e1      ^^c3^^a1\endmubyte % á
% atd. -- implementace UTF8

\mubyte  \endash   ^^c4^^f6\endmubyte % pøíklad na kontrolní sekvenci
\mubyte  \integral  INT\endmubyte     % pøíklad pro ilustraci, viz dále.

\mubytein=1 \mubyteout=1 \mubytelog=1 % od této chvíle je pøekódování aktivní

\def\endash {--}
\def\integral {\ifmmode \int\else $\int$\fi}
\endtt

V~tomto pøíkladì je v~místì <one optional space> více mezer a
tabulátorù. Proto¾e tabulátory mají kategorii mezery, jsou v¹echny
tyto znaky pøemìnìny token procesorem na jedinou mezeru po¾adovanou 
v~syntaktickém pravidle pro "\mubyte", "\endmubyte".

Po pou¾ití definic z~pøíkladu se napøíklad slovo INTEGRAL promìní v~token
"\integral" okam¾itì následovaný písmeny \uv{EGRAL}. V~textu INT EGRAL
bude za tokenem "\integral" mezera a teprve pak písmena
\uv{EGRAL}. Také jsou mo¾né konstrukce typu "\defINT{nìco}" apod. 
Kdy¾ napí¹eme "\show INT", dostaneme odpovìï:

\begtt
> \integral=macro:
->\ifmmode \int \else $\int $\fi .
l.18 \show INT
\endtt
%
a "\string INT" se expanduje na text: "\integral".

Po deklaraci INT podle pøedchozího pøíkladu se mù¾e
stát, ¾e nìkdo napí¹e: "\INT". Správnì by to mìlo vést na prázdnou
kontrolní sekvenci ("\csname\endcsname") následovanou kontrolní
sekvencí "\integral". Proto¾e se ale s~prázdnými kontrolními
sekvencemi v~\TeX{}u moc èasto nepracuje a pro u¾ivatele by to mohlo
být matoucí, rozhodl jsem se tuto situaci o¹etøit tak, ¾e "\INT" je
pøevedeno pouze na token "\integral".  Pozor na skuteènost, 
¾e za sekvencí "\INT" není \TeX{} ve stavu ignorování mezer 
a navíc mù¾e za ní okam¾itì následovat písmeno.

\sec Vlastnosti konverze
%    -------------------

Multibytové sekvence jsou pøevedeny ze vstupu pouze tehdy, pokud jsou
celé obsa¾eny v~jediném øádku. Pøesah do dal¹ího øádku není
mo¾ný. Pøipojený "\endlinechar" na konci øádku se mù¾e stát pøedmìtem
konverze podle konverzní tabulky.

Sekvence "^^c3^^81" se nepromìní ani po pou¾ití definic z~pøíkladu na
byte \uv{Á}, proto¾e pøevod dvojitých zobákù na jednotlivé byty
probíhá v~token procesoru, tj. pozdìji, ne¾ pøevody více bytù na
jeden podle "\mubyte".

Pøevod více bytù na jeden byte nebo kontrolní sekvenci 
probíhá pozdìji ne¾ konverze podle "\xordcode" a pøi výstupu do "\write" a
log souborù pak pøevod podle "\mubyte" probíhá døíve ne¾ konverze podle 
"\xchrcode". <byte_sequence> tedy musí obsahovat sekvenci bytù tak, jak
jsou tyto byty konvertovány ze vstupního souboru pomocí "\xordcode".

Postupné procesy na vstupu a výstupu si mù¾eme naznaèit takto:

\begtt
vstupní text -> \xordcode -> pøipojení \endlinechar -> 
                \mubyte -> token procesor -> expanze ...
argument \write -> expanze -> \mubyte -> \xchrcode -> výstup
\endtt

Pøi výstupu do "\write" souborù a logù zpìtnì konvertované 
<byte_sequence> u¾ nepodléhají dal¹í konverzi na formát typu 
"^^c3^^81" ani opakované konverzi podle "\mubyte". Tyto
<byte_sequence> se pouze pøevedou podle hodnot "\xchrcode".

Pokud se v~konverzní tabulce vyskytují <byte_sequence> se spoleèným
zaèátkem, ale rùznì dlouhé, pak input procesor enc\TeX{}u (od verze
Feb.~2003) pøevádí v¾dy podle nejdel¹í mo¾né <byte_sequence>, která se
na vstupu objeví. Pøíklad:

\begtt
\mubyte X A\endmubyte
\mubyte Y ABC\endmubyte
\mubyte \foo ABCD\endmubyte
\endtt

V~tomto pøíkladì se ka¾dé A~konvertuje na X, ale pokud následuje BC,
pak se skupina ABC konvertuje na Y ov¹em s~tou výjimkou, ¾e se skupina
ABCD konvertuje na "\foo". Na poøadí vkládání údajù do konverzní tabulky
primitivem "\mubyte" v~tomto pøípadì nezále¾í.

Pokud se v~konverzní tabulce objeví dvì stejné <byte_sequence>, pak má
pøednost ta, která byla zanesena do tabulky pozdìji.


\sec Konverze výstupu do logu a na terminál
%    --------------------------------------

Výstup do logu a na terminál je pøi nulovém "\mubytelog" ponechán bez
konverze. Pokud je v~takovém pøípadì "\xprncode" znaku nulový, pak se
znak vytiskne ve formì "^^A" nebo "^^bc". Pøi kladném "\mubytelog" se
znaky zanesené do konverzní tabulky konvertují zpìt na
<byte_sequence>. Do logu a na terminál se ale na <byte_sequence>
nikdy nekonvertují kontrolní sekvence.

Zpìtná konverze do logu a na terminál je nastavována spoleènì
primitivem "\mubytelog" a nelze ji oddìlit tak, ¾e by napøíklad pro
terminál byla zpìtná konverze potlaèena a pro log soubory nikoli.

Výpisy do logu a na terminál obèas obsahují kompletní pøepis právì
èteného øádku, který je napøíklad pøi hlá¹ení chyby rozrt¾en na dva
øádky, aby \TeX{} naznaèil místo, kde do¹lo k~problému. Pro dal¹í
výklad budeme tìmto èástem logu øíkad \uv{pøepisy øádkù}.

Je-li registr "\mubytein" nulový, pak pøepisy øádkù
fungují jako ve standardním \TeX{}u. Je-li "\mubytein" kladný a 
"\mubytelog" nulový, pak je v~pøepisech øádkù zobrazen obsah øádku a¾
po konverzi input procesorem enc\TeX{}u, tj. v~tìchto pøepisech se
mohou napøíklad vyskytovat kontrolní sekvence, které tam u¾ivatel
vùbec nenapsal. Jsou-li "\mubytein" i "\mubytelog"
kladné, pak jsou pøepisy øádkù realizovány bez multibytové konverze
tam ani zpìt. Probíhá jen konverze podle xchr a xord vektorù. 
Je tøeba si uvìdomit, ¾e v~tomto pøípadì mohou být chybové výpisy
ponìkud matoucí. Napøíklad po

\begtt
\mubyte \sekvence ABC\endmubyte  \let\sekvence=\undefined
\mubytein=1 \mubytelog=1
Tady je test ABC a øádek pokaèuje.
\endtt
%
dostáváme na výstupu:

\begtt
! Undefined control sequence.
l.3 Tady je test ABC
                     a øádek pokaèuje.
?
\endtt
%
Teprve "\show ABC" odhalí:

\begtt
> \sekvence=undefined.
l.3 \show ABC
\endtt


\sec Mazání údajù v~konverzí tabulce
%    -------------------------------

Údaje v~konverzní tabulce lze mazat jen hromadnì: pøíkaz vyma¾e
v¹echny údaje zaèínající na spoleèný první znak v~<byte_sequenci>.
Provede se to pomocí pøíkazu "\mubyte <znak> <znak>\endmubyte".
Napøíklad:

\begtt
\mubyte A A\endmubyte
\endtt
%
odstraní z~konverzní tabulky v¹echny <byte_sequence> zaèínající
písmenem A. 

Následující kód proma¾e celou tabulku:

\catcode`<=12
\begtt
{\catcode`\^^@=12
\gdef\clearmubytes{\bgroup \count255=1
   \loop \uccode`X=\count255
       \uppercase{\mubyte XX\endmubyte}%
       \advance\count255 by1
       \ifnum\count255<256 \repeat
   \mubyte ^^@^^@\endmubyte
   \egroup}
}
\clearmubytes
\endtt
\catcode`<=13


\sec Vstupní a výstupní èást konverzní tabulky
%    -----------------------------------------

Konverzní tabulka konstruovaná pomocí "\mubyte", "\endmubyte" má dvì
nezávislé èásti: vstupní, se kterou pracuje input procesor a výstupní,
která se pou¾ívá pøi zpìtných konverzích. Údaje je mo¾né zanést
nezávisle do ka¾dé èásti pøi pou¾ití neprázdného <optional_prefix>
(viz syntaktické pravidlo "\mubyte" na zaèátku této kapitoly). 
Je-li <optional_prefix>
prázdný, pak se po¾adavek na konverzi zanese dvojmo do vstupní i
výstupní èásti. Je-li ale <optional_prefix> znak kategorie~8 (obvykle
znak "_"), pak se údaj zanese jen do vstupní èásti tabulky. Obsahuje-li
<optional_prefix> dvojici znakù kategorie~8 (obvykle tedy "__"), pak
se údaj zanese jen do výstupní èásti tabulky. 

Pøi <optional_prefix> "__" (výstupní èást tabulky) je dovoleno mít
prázdnou <byte_sequenci>. V~takovém pøípadì se pùvodní
údaje z~výstupní èásti tabulky, které odpovídají <first_token>,
vyma¾ou. Pokud tam ¾ádné takové údaje nebyly, nestane se nic.

Vra»me se ke kódu na vymazání tabulky z~pøedchozí sekce. Tento kód
vyma¾e v¹e ze vstupní èásti tabulky a z~výstupní jen ty údaje, které
jsou vázány na <first_token> ve tvaru <byte>. Údaje z~výstupní èásti
vázané na kontrolní sekvence nejsou tímto zpùsobem promazány.
Promazání jednoho údaje udìláme pomocí:
"\mubyte \foo __\endmubyte".


\sec Vkládání dal¹ích kontrolních sekvencí
%    -------------------------------------

Je-li <first_token> ve tvaru kontrolní sekvence a navíc 
<optional_prefix> je token kategorie~6 
(obvykle znak "#") následovaný <èíslem>, 
pak input procesor ponechá beze zmìny <èíslo> znakù, 
ale vlo¾í pøed nì deklarovanou kontrolní sekvenci. 
Údaj se zanese jen do vstupní èásti konverzní tabulky.
Pøíklad:

\begtt
\def\abc{ABC}
\mubyte X BC\endmubyte \mubytein=1  
\mubyte \foo #3 \abc\endmubyte  Nyní ABC pøechází na \foo ABC
\mubyte \foo #1 \abc\endmubyte  Nyní ABC pøechází na \foo AX
\endtt  

Parametr <èíslo> má stejnou syntaxi, jako gramatická kategorie <number> 
z~\TeX{}booku. Napøíklad pøi pøímém zápisu dekadických èíslic
mù¾e následovat jedna nepovinná mezera, jako v~pøedchozí ukázce.

Je-li <èíslo> rovno nule, pak bude
ponechána beze zmìny celá <byte_sequence>, která následuje. 
Výsledek je tedy stejný, jako kdyby <èíslo> mìlo hodnotu délky 
<byte_sequence>.

Hodnota <èísla> je akceptována jen v~rozsahu 0 a¾ 50. Záporná èísla
jsou interpretována stejnì jako nula a èísla vìt¹í ne¾ 50 zpùsobí, ¾e
input procesor vypne po vlo¾ení kontrolní sekvence dal¹í konverzi a¾
do konce øádku.

Praktický pøíklad pou¾ití:

\begtt
\mubyte \warntwobytes  #2^^c3\endmubyte
\mubyte \warntwobytes  #2^^c4\endmubyte
\mubyte \warntwobytes  #2^^c5\endmubyte
% atd...
\def\warntwobytes #1#2{\message{WARNING: the UTF8 code: 
   \noconvert#1\noconvert#2 is not defined i my macros.}}
\endtt

V~tomto pøíkladì byl pou¾it nový primitiv enc\TeX{}u "\noconvert",
jeho¾ vlastnosti jsou uvedeny pozdìji v~kapitole~5. Pøipomínám také,
¾e od verze Feb.~2003 nezpùsobují jednoznakové <byte_sequence> kolizi
s~víceznakovými <byte_sequencemi> se stejným zaèátkem, tak¾e tento
pøíklad neru¹í konverzi \uv{známých} UTF-8 kódù.



\sec Rozpoznání zaèátku øádku
%    ------------------------

Existují-li v~konverzní tabulce <byte_sequence> 
s~prvním znakem shodným s~aktuálním "\endlinechar", 
tj.~<byte_sequence> jsou ve tvaru <endlinechar><zbytek>,
pak input procesor navíc ovìøuje, zda je <zbytek> shodný se 
zaèátkem ka¾dého øádku. Pokud ano, provede po¾adovanou konverzi. 
Pøíklad pou¾ití:

\begtt
\bgroup \uccode`X=\endlinechar \uppercase{\gdef\echar{X}}\egroup
\mubyte \fooB \echar ABC\endmubyte % vyhovuje ABC na zaèátku øádku
\mubyte \fooE ABC\echar \endmubyte % vyhovuje ABC na konci øádku
\mubyte \fooW \spce\space ABC\space \endmubyte
        % vyhovuje ABC jako slovo s mezerami vpøedu i vzadu
\mubyte \foo #\echar ABC\endmubyte % 
        % je-li ABC na zaèátku øádku, vlo¾í pøed nìj \foo
\endtt


\sec Potlaèení expanze v~parametrech write
%    -------------------------------------

Chceme-li pøevádìt kontrolní sekvence zpìtnì na <byte_sequence> pøi
zápisu do "\write" souborù, musíme potlaèit pøípadnou expanzi tìchto
kontrolních sekvencí napøíklad pomocí "\let\macro=\relax". Proto¾e ale
"\write" èasto pracuje asynchronnì a kontrolních sekvencí mapujících
UTF-8 mù¾eme mít stovky nebo tisíce, umo¾òuje enc\TeX{} nastavit
v~dobì expanze parametrù "\write" pøíslu¹ným kontrolním sekvencím
význam "\relax" automaticky. Dìlá to pøi "\mubyteout>=3" a význam
"\relax" pøiøadí právì tìm kontrolním sekvencím, které mají 
ve výstupní èásti konverzní tabulky neprázdnou <byte_sequenci>. 
Jakékoli jiné expanze mimo parametr "\write" probíhají 
normálním zpùsobem. Pøíklad:

\begtt
\mubyte \foo ABC\endmubyte  \def\foo{macro body}
\mubyteout=2
\immediate\write16{testwrite: \foo}  % zapí¹e "testwrite: macro body"
\immediate\write16{testwrite: \noexpand\foo} % zapí¹e "testwrite: ABC"
\mubyteout=3
\immediate\write16{testwrite: \foo}  % zapí¹e "testwrite: ABC"
\message{testmessage: \foo}          % zapí¹e "testmessage: macro body"
\message{testmessage: \noexpand\foo} % zapí¹e "testmessage: \foo"
\edef\a{testedef: \foo}              % expanduje na macro body
\foo                                 % expanduje na macro body
\immediate\write16{\meaning\foo}     % zapí¹e "\relax"
\message{\meaning\foo}               % zapí¹e "macro:->macro body"
\endtt

Pomocí zápisu "\mubyte <control_sequence> \relax \endmubyte" je mo¾no
pøidìlit kontrolní sekvenci pøíznak, aby se neexpandovala 
v~parametrech "\write" pøi "\mubyteout>=3", ale na druhé stranì nebude
konvertována do ¾ádné <byte_sequence>, ale vypí¹e se jako obvykle.
Uvedený zápis má tedy stejný význam jako 
"\mubyte" <control_sequence>" __\string" <control_sequence>"\space\endmubyte",
ale navíc ¹etøí pamìtí \TeX{}u, nebo» \TeX{} není nucen ukládat 
string <byte_sequence> do poolu.

Popsanou vlastnost enc\TeX{}u mù¾ete vyu¾ít k~vytváøení vlastních 
maker, která jinak expandují v~parametrech "\write" a jinak
\uv{normálnì}. Pøíklad:

\begtt
\mubyte \writeparameter \relax \endmubyte \def\writeparameter{}
\def\mymacro{\ifx\writeparameter\relax Tady expanduji ve write.
             \else Tady expanduji normálnì.\fi}
\endtt


\sec Asynchronní zpracování pøíkazu write
%    ------------------------------------

Je známo, ¾e pokud nepou¾ijeme "\immediate", pak se argument pøíkazu
"\write" expanduje a¾ pozdìji: ne v~okam¾iku výskytu pøíkazu.
Pøíkaz "\write" si proto ulo¾í do své pamìti aktuální 
hodnotu registru "\mubyteout" v~dobì prvního zpracování a pak
pøi expanzi a zápisu do souboru tuto hodnotu pou¾ije.

Díky této vlastnosti mù¾eme tøeba pro soubor s~obsahem zapisovat
s~hodnotou "\mubyteout=3" a souèasnì pøi zápisu do jiného souboru
ponecháme hodnotu "\mubyteout=0". To mù¾e být ¾ádoucí
napøíklad proto, ¾e soubor je urèen ke zpracování programem, který
nemá implementovánu schopnost práce s~UTF-8 kódováním. Vyzkou¹ejte:

\begtt
\newwrite\tocfile \newwrite\indexfile
\immediate\openout\tocfile=\jobname.toc
\immediate\openout\indexfile=\jobname.idx
\mubyteout=3
\write\tocfile{parametr se bude pozdìji konvertovat do UTF-8}
{\mubyteout=0 \write\indexfile{parametr zùstane nezmìnìný bez konverze}}
\write\tocfile{zde se znovu provede konverze}
\end % a teprve v tento okam¾ik se v¹echny tøi zápisy provedou
\endtt


\sec Hodnoty registru mubyteout
%    --------------------------

Kromì ji¾ zmínìných hodnot 0, 1, 2 a 3 registru "\mubyteout" mù¾e být
nìkdy u¾iteèné nastavit tento registr na hodnoty $-1$, $-2$ a $-3$. 
Význam tìchto hodnot je vysvìtlen v~následující tabulce:

\vbox{
\begtt
\mubyteout  <byte>-><byte_sequence>  <cs_name>-><byte_sequence>  potlaèení expanze
----------------------------------------------------------------------------
   0             ne                       ne                   ne
   1             ano                      ne                   ne
   2             ano                      ano                  ne
   3             ano                      ano                  ano
  -1             ano                      ne                   ano
  -2             ne                       ne                   ano
\endtt
\relax}

Je-li zapnutá konverze <byte>"->"<byte_sequence>, pak se tato konverze
provádí i do logu a na terminál, zatímco konverze 
<cs_name>"->"<byte_sequence> a potlaèení
expanze se týkají jen argumentù "\write" a "\special". 


\kap Argumenty primitivu special
     %%%%%%%%%%%%%%%%%%%%%%%%%%%

V~argumentech "\special" se èasto objevují texty 
v~pøirozeném jazyce (napøíklad texty pro zálo¾ky do PDF dokumentu).
Pøi stále èastìj¹ím pou¾ívání UTF-8 je ¾ádoucí, aby tyto texty byly 
kódovány v~tomto kódování. Enc\TeX{} tuto mo¾nost nabízí.

Argument primitivu "\special" je zpracován podle hodnoty celoèíselného
registru "\specialout", který má implicitní hodnotu~0.

\begitems
* "\speialout=0" -- ¾ádná konverze argumentu se neprovede.
* "\speialout=1" -- provede se konverze jen podle vektoru xchr.
* "\speialout=2" -- provede se konverze jen podle hodnoty "\mubyteout".
* "\speialout=3" -- provede se konverze podle hodnoty "\mubyteout"
                    následovaná konverzí podle xchr.
\enditems

Primitiv "\special" expanduje svùj argument okam¾itì. Pøi
"\specialout" 2 nebo 3 se expanze provede podle hodnoty "\mubyteout"
stejnì jako u~primitivu "\write". Pak si pøíkaz "\special" ulo¾í do
pamìti aktuální hodnoty "\specialout" a "\mubyteout" a tyto hodnoty
pou¾ije je¹tì jednou pøi skuteèném výstupu argumentu do "dvi" souboru.


\kap Primitiv noconvert
     %%%%%%%%%%%%%%%%%%

Enc\TeX{} zavádí primitiv "\noconvert", který
potlaèí pøípadnou konverzi následujícího znaku nebo kontrolní sekvence.
Pøesnìji: primitiv "\noconvert" je neexpandující a v~sazbì neudìlá nic
(podobnì jako "\relax"). Pokud se ale 
tento primitiv vyskytne v~argumentu "\message" nebo "\errmessage",
pak jeho kontrolní sekvence není vùbec vyti¹tìna. Navíc pak následující 
znak není konvertován na <byte_sequenci>, aèkoli tøeba je "\mubytelog"
kladný a znak je uveden ve výstupní èásti konverzní tabulky. 

Primitiv "\noconvert" se chová stejnì i v~parametrech "\write" a
"\special". V~tomto pøípadì navíc mù¾e primitiv "\noconvert" potlaèit
konverzi následující kontrolní sekvence, aèkoli je tøeba "\mubyteout"
vì¹í ne¾~2.

Konstrukce "\noconvert\noconvert" vytiskne jedno "\noconvert".

Pokud se má primitiv "\noconvert" vypsat v~jiných situacích (napøíklad
pøi výpisu kontextu pøi hlá¹ení o~chybì nebo pøi rùzných
"\tracing..."), pak jeho kontrolní sekvence nemizí a navíc 
neovlivní tisk následujícího znaku.


\kap Seznam primitivù enc\TeX{}u
     %%%%%%%%%%%%%%%%%%%%%%%%%%%

Pro lep¹í orientaci uvádím pøehled nových primitivù enc\TeX{}u:

\begitems
* "\mubyte"    --- zaná¹í údaje do konverzní tabulky, viz~kap.~3.
* "\endmubyte" --- separátor pro "\mubyte".
* "\mubytein" --- registr integer. 0: vícebytová vstupní konverze
                  potlaèena, 1 a více: vícebytová vstupní konverze je
                  aktivována. 
* "\mubyteout" --- registr integer, ovlivní konverzi do výstupních
                  souborù "\write" a parametrù "\special", viz~3.10.
* "\mubytelog" --- registr integer, 0: vícebytová výstupní konverze do
                  logu a na terminál potlaèena, 1 a více:  vícebytová 
                  výstupní konverze je aktivována.
* "\specialout" --- registr integer, ovlivní zpracování parametrù
                  "\special", viz~kap.~4.
* "\noconvert" --- podobnì jako "\noexpand", ale pro konverze. Viz~kap.~5.
* "\xordcode" --- pøístup k~vektoru xord, viz 2.1.
* "\xchrcode" --- pøístup k~vektoru xchr, viz 2.1.
* "\xprncode" --- pøístup k~vektoru pro tisknutelnost znakù, viz 2.2.
\enditems

Pøehled prefixù pøi pou¾ití 
"\mubyte"<first_token><optional_space><prefix><byte_sequence>"\endmubyte".
Znak~"#" zde oznaèuje libovolný token kategorie~6 a znak~"_" oznaèuje
libovolný token kategorie~7.

\begitems
* ¾ádný prefix --- záznam do vstupní i výstupní tabulky.
* "_" --- záznam jen do vstupní èásti tabulky
* "__" --- záznam jen do výstupní èásti tabulky
* "#<èíslo>" --- vlo¾ení kontrolní sekvence, následujících <èíslo> znakù
  ponechá input procesor beze zmìny.
* "\relax" --- kontrolní sekvence nebude expandovat v~parametrech "\write"
\enditems

Dal¹í prefixy se mohou objevit v~budoucích verzích enc\TeX{}u. V¾dy
budou mít kategorie odli¹né od 11 a 12, tak¾e pro zaèátek
<byte_sequence> je vhodné v~makrech pou¾ít token kategorie 11 nebo 12,
aby se pøede¹lo pøípadnému konfliktu s~budoucí vezí enc\TeX{}u.


\kap Dokumentace k~pøilo¾eným souborùm maker
     %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Tato èást dokumentace nebyla ve verzi Dec. 2002 revidovaná a je
ponechána ve stavu z~roku 1997 s~výjimkou následujícího odstavce.

\sec Kódování UTF-8
%    --------------

Pro vstupní kódování UTF-8 jsou pøipraveny soubory "utf8-csf.tex" a
"utf8-t1.tex". V~tomto pøípadì je pøekódování implementováno pomocí
"\mubyte" a vektory xord, xchr jsou nastaveny tak, ¾e na jejich úrovni 
je zachováno identické zobrazení.

\sec Formáty typu {\tt plain-x-y}
%    ----------------------------

V~balíèku jsou pøipraveny inicializaèní soubory pro vygenerování formátu
podobnému standardnímu formátu plain. Napøíklad pøíkazem

\begtt
$ tex -ini -enc plain-1250-cs
\endtt

vygenerujeme formát analogický plainu, který ète vstupní soubory
v~kódování CP1250 a pracuje s~CS-fonty.

V~balíku jsou k~dispozici tyto inicializaèní soubory pro plain:

\begtt
plain-il2-cs   ...  vstup podle ISO8859-2, textové fonty v TeXu: CS-font
plain-kam-cs   ...  vstup podle Kamenických, textové fonty v TeXu: CS-font
plain-1250-cs  ...  vstup podle CP1250, textové fonty v TeXu: CS-font
plain-852-cs   ...  vstup podle CP852, textové fonty v TeXu: CS-font
plain-il2-dc   ...  vstup podle ISO8859-2, textové fonty v TeXu: DC
plain-kam-dc   ...  vstup podle Kamenických, textové fonty v TeXu: DC
plain-1250-dc  ...  vstup podle CP1250, textové fonty v TeXu: DC
plain-852-dc   ...  vstup podle CP852, textové fonty v TeXu: DC
\endtt

\sec Poznámka k~dlouhým názvùm souborù
%    ---------------------------------

V¹echny soubory "*.tex" v~balíèku splòují DOSové omezení na délku názvu
8+3. Výjimkou z~tohoto pravidla jsou pouze soubory plain-x-y popsané
vý¹e a analogické inicializaèní soubory pro La\TeX{}. Pokud pou¾íváte
systém, který je omezen na 8+3, doporuèuji pro ka¾dé kódování zvolit
jedno písmeno (napøíklad c=cs, d=dc, i=il2, w=1250, p=852, k=kam,
o=koi8, m=mac) a nahradit názvy souborù v~distribuci tìmito názvy:

\begtt
plain-il2-cs.tex     plain-ic.tex
plain-kam-cs.tex     plain-kc.tex
plain-1250-cs.tex    plain-wc.tex
plain-852-cs.tex     plain-pc.tex
plain-il2-dc.tex     plain-id.tex
plain-kam-dc.tex     plain-kd.tex
plain-1250-dc.tex    plain-wd.tex
plain-852-dc.tex     plain-pd.tex
kam-latex.tex        latex-ki.tex
852-latex.tex        latex-pi.tex
\endtt

Obsah "\message" v~souborech {\tt plain-x-y} nemìòte. Napøíklad formát
"plain-wc" se po spu¹tìní pøedstaví svým plným jménem

\catcode`\<=12
\begtt
The format: plain-1250-cs <Sep. 1997>.
\endtt
\catcode`\<=13

\sec Kódovací tabulky
%    ----------------

Proto¾e zmìna vektorù xord a xchr mù¾e totálnì rozhodit chování
\TeX{}u zcela k~nepoznání, doporuèuji pou¾ívat urèité soubory, které
nastaví po¾adované kódování, a dále s~primitivy "\xordcode",
"\xchrcode" a "\xprncode" za bìhu \TeX{}u moc nela¹kovat. V~balíèku
enc\TeX{} jsou k~dispozici soubory, které zmìnu vektorù pro bì¾ná
kódování definují. Tyto soubory mají obvyklou pøíponu tex. Øíkáme jim
kódovací tabulky. Rozli¹ujeme dva typy kódovacích tabulek.


\sec První typ kódovacích tabulek
%    ----------------------------

První typ tabulek deklaruje vnitøní kódování \TeX{}u ve vztahu ke kódování,
které je bì¾nì pou¾ívané v~hostitelském operaèním systému. Máme-li
napøíklad v~systému kódování ISO-8859-2 a vnitøní kódování \TeX{}u volíme
podle Corku (kódování je oznaèováno jako T1), pak tabulka musí pøedefinovat
xord vektor tak, aby mapoval znaky z~ISO-8859-2 do T1 a vektor xchr musí
pøevádìt zpátky z~T1 do kódování systému.

Tento typ tabulek je pou¾it v~inicializaèních souborech "plain-*.tex" a
obsahuje v~názvu souboru vstupní i cílové vnitøní kódování \TeX{}u. Podívejte
se, jak vypadá napøíklad tabulka "il2-t1.tex", která definuje vnitøní
kódování \TeX{}u podle Corku a vstupní kódování ISO8859-2.

Ka¾dá tabulka prvního typu ète soubor "encmacro.tex" s~definicemi maker
"\setcharcode", "\expandto", "\texaccent", "\texmacro" a "\redefaccent".

\begitems
* "\setcharcode #1 #2 #3 #4 #5 #6 #7" deklaruje \TeX{}ové kódy pro jeden znak.
  Nastaví xord["#1"]="#2", xchr["#2"]="#1", "\xprncode#2"="#7" a 
  postupnì nastaví "\lccode", "\uccode", "\sfcode" a "\catcode" znaku 
  s~kódem "#2" na hodnoty "#3", "#4", "#5" a "#6". 
  Je-li "#1" otazník, pak se xord a xchr nenastaví.

* "\expandto {<definice>}" definuje aktivní podobu znaku "#2" z~posledního
  "\setcharcode" tak, ¾e tento token expanduje na <definici>. Podrobnìji:
  je-li v~"\setcharcode" uvedeno "#6=13", pak bude ka¾dý výskyt znaku "#2"
  expandovat na <definici>. Není-li v~"\setcharcode" øeèeno "#6=13", pak
  k~expanzi znaku "#2" na <definici> dojde teprve tehdy, kdy¾ bude
  (tøeba pozdìji) nastaveno "\catcode" znaku "#2" na "13".

* "\texaccent" uv{zápis akcentu} pøipravuje expanzi \uv{zápisu akcentu} 
  na znak s~kódem "#2" z~naposledy pou¾itého "\setcharcode". Napøíklad 
  zápis "\v C" bude po naètení souboru il2-t1.tex expandovat na znak 
  s~kódem {\tt\char`\"83}. Pokud zápis pro akcent není v~tabulce uveden, 
  zùstává v~pùvodním významu, tj. tøeba "\v g" expanduje na primitiv 
  "\accent", který usadí háèek nad písmeno g.
  K~aktivaci v¹ech \uv{zápisù akcentu} dojde a¾ po pou¾ití makra
  "\redefaccent" (viz ní¾e).

* "\texmacro #1" deklaruje makro "#1" tak, ¾e bude expandovat na znak s~kódem
  "#2" z~naposledy pou¾itého "\setcharcode". K~pøedefinování makra "#1" 
  dojde (na rozdíl od "\texaccent") okam¾itì. Napøíklad makro "\S" bude 
  po naètení souboru "il2-t1.tex" expandovat na znak s~kódem "9F", proto¾e 
  na této pozici je podle Corku znak paragraf.

* "\redefaccent #1" aktivuje expanzi zápisù podle "\texaccent" pro jeden
  konkrétní akcent "#1".
\enditems

Kromì toho je na zaèátku tabulky èten soubor definic závislých na kódování
textového fontu \TeX{}u. V~na¹í ukázce jde napøíklad o~soubor "t1macro.tex".
Definují se tam sekvence "\promile", "\clqq" a dal¹í. 

Mù¾e se stát, ¾e nechceme uvedená makra pou¾ít, ale hodnoty z~tabulky
naèíst chceme. Pak mù¾eme pøistoupit k~následujícímu triku: Definujeme si
makra "\setcharcode" a¾ "\redefaccent" sami a dále provedeme naètení tabulky
takto:

\begtt
\let\originput=\input \def\input #1  \originput il2-t1
\let\input=\originput
\endtt

V~balíèku jsou pøipraveny tyto tabulky prvního druhu:

\begtt
Název souboru       vstupní kódování    vnitøní kódování TeXu
-------------------------------------------------------------
il2-csf.tex         ISO8859-2           CS-font
kam-csf.tex         Kamenických         CS-font
1250-csf.tex        CP1250, MS-Windows  CS-font
852-csf.tex         CP852, PC Latin2    CS-font
il2-t1.tex          ISO8859-2           T1 alias Cork
kam-t1.tex          Kamenických         T1 alias Cork
1250-t1.tex         CP1250, MS-Windows  T1 alias Cork
852-t1.tex          CP852, PC Latin2    T1 alias Cork
\endtt

Za zmínku stojí první uvedená tabulka "il2-csf.tex", proto¾e ta
jediná ponechává vektory xord a xchr beze zmìny. Tuto tabulku
je tedy mo¾né pou¾ít i v~\TeX{}u, který neobsahuje roz¹íøení
enc\TeX{}. V¹echny ostatní tabulky enc\TeX{} explicitnì vy¾adují.


\sec Druhý typ kódovacích tabulek
%    ----------------------------

Druhý typ tabulek provádí pøekódování pouze na vstupní stranì \TeX{}u. Poznáme
je podle toho, ¾e nemají na konci názvu znaèku pro vnitøní kódování \TeX{}u
(tj. "t1" nebo "csf"), ale znaèku pou¾ívanou pro kódování operaèního systému
(napø. "il2", "kam"). Tøeba tabulka "kam-il2.tex" provádí na vstupní stranì
konverzi z~kódování kamenických do kódování ISO8859-2. Tento typ tabulek
pozmìòuje pouze vektor xchr, ale výstupní vektor xord ponechává beze zmìny.
Takovou tabulku pou¾ijeme, pokud \TeX{}em naèítáme soubor, který je v~jiném
kódování, ne¾ bì¾nì pou¾íváme na na¹em operaèním systému. Pøitom výstup do
log, aux apod. ponecháme v~kódování podle na¹eho systému. Tyto zmìny
kódování je mo¾né provádìt i v~prùbìhu zpracování jediného dokumentu.

Druhý typ tabulek navazuje na vstupní kódování deklarované døíve
tabulkou prvního typu. Nastavení vnitøního kódování \TeX{}u není vùbec
druhým typem tabulek mìnìno. Uvedeme pøíklad. Pøi generování formátu
jsme pou¾ili tabulku prvního typu "il2-t1.tex", tak¾e vnitøní
kódování máme podle Corku. Nyní mù¾eme pøi zpracování dokumentu na
pøechodnou dobu vybrat nìkterou z~tabulek "*-il2.tex", tøeba:

\begtt
\input kam-il2  
\input dokument
\restoreinputencoding
nyní mohu pracovat v pùvodním kódování...
\end
\endtt

V~dobì, kdy probíhá naèítání souboru dokument.tex se provádí
pøekódování z~Kamenických do T1, uvnitø \TeX{}u se v¹e zpracovává
v~T1 a výstup na terminál a do logu máme v~ISO8859-2. V~tomto
kódování je také zapsán dal¹í text pod "\restoreinputencoding".
Tabulka toti¾ deklaruje toto makro, aby byl mo¾ný návrat k~pùvodnímu
nastavení vektoru xord.

Pøi pou¾ití tabulek druhého typu musíme dát velký pozor, abychom nìco
neudìlali ¹patnì. V~na¹em pøíkladì jsou v¹echny výstupy do souborù
typu aux v~ISO-8859-2, tak¾e je pøi opakovaném spu¹tìní \TeX{}u nesmíme
naèítat v~okam¾iku, kdy máme nastaven vstupní kód podle Kamenických. To je
také dùvod, proè nedoporuèuji generovat formát pøíkazem "\dump" v~situaci,
kdy máme naètenou tabulku druhého typu.

\end









